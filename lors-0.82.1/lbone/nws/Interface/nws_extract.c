/* $Id: nws_extract.c,v 1.60 2001/02/07 15:52:38 swany Exp $ */

#include <ctype.h>       /* isalpha() isspace() */
#include <stdio.h>       /* printf() */
#include <unistd.h>      /* getopt() sleep() */
#include <stdlib.h>      /* atoi() free() malloc() */
#include <sys/types.h>   /* size_t */
#include <stdarg.h>      /* Variable parameter stuff. */
#include <string.h>      /* strchr(), strncasecmp() strstr() */
#include <strings.h>     /* strncasecmp() on aix */
#include <time.h>        /* time() */
#include "config.h"
#include "diagnostic.h"  /* DirectDiagnostics() */
#define NWSAPI_SHORTNAMES
#include "nws_api.h"     /* NWS programming interface */


/*
** This program allows command-line extraction and display of the measurements
** and forecasts generated by the NWS.  See the user's guide for a description
** of the command-line options.
*/


#define SAFE_STRCPY(to, from) \
  do {strncpy(to, from, sizeof(to)); to[sizeof(to) - 1] = '\0'; if (1) break;} while (0)

#define NUMERIC_WIDTH 12

/*
** Returns #str# trimmed down to at most #len# characters.  The trimming is
** done by removing all trailing characters of words that begin with a capital
** letter, as well as any excess whitespace.  If this is not sufficient,
** trailing characters are truncated.
*/
static const char *
Abbreviate(const char *str,
           size_t len) {

  static char returnValue[255 + 1];
  char *end;
  const char *from;
  int leftToTrim;
  char *to;

  leftToTrim = strlen(str) - len;
  if(leftToTrim <= 0)
    return str; /* It's already short enough. */

  end = &returnValue[len];
  from = str;
  to = returnValue;

  while((to < end) && (leftToTrim > 0)) {
    if(isupper((int)*from)) {
      /* Trim everything to the end of the word except the initial capital. */
      *to++ = *from++;
      while((*from != '\0') && !isspace((int)*from)) {
        from++;
        leftToTrim--;
      }
    }
    else {
      /* No initial capital; copy the whole word and a trailing space. */
      while((to < end) && !isspace((int)*from))
        *to++ = *from++;
      if(to < end)
        *to++ = *from++;
    }
    /* Eliminate any excess whitespace. */
    while(isspace((int)*from) && (leftToTrim > 0)) {
      from++;
      leftToTrim--;
    }
  }

  /* Add a terminating nul, plus any trailing characters we have room for */
  strcpy(to, (leftToTrim <= 0) ? from : "");
  return returnValue;

}


/*
** Appends the #count# strings passed after the third parameter to the
** #len#-long string #dest#.  Terminates #dest# with a nul character.  Returns
** the number of characters appended.
*/
static int
MultiCat(char *dest,
         size_t len,
         int count,
         ...) {

  va_list paramList;
  int i;
  const char *source;
  char *end = dest + len - 1;
  char *next;

  next = dest + strlen(dest);
  va_start(paramList, count);
  for (i = 0; i < count; i++) {
    for (source = va_arg(paramList, const char*);
         (next < end) && (*source != '\0'); next++, source++)
      *next = *source;
  }
  *next = '\0';
  va_end(paramList);
  return next - dest;

}


/*
** Returns #str# padded on #where# to a total length (not including the
** terminating nul) of #len#.
*/
typedef enum {PAD_CENTER, PAD_LEFT, PAD_RIGHT} PadTypes;
static const char *
PadString(const char *str,
          size_t len,
          PadTypes where) {

  static char returnValue[255 + 1];
  size_t padding;
  size_t strSize = strlen(str);

  if(strSize > len)
    return str;  /* No room for any padding. */

  memset(returnValue, ' ', sizeof(returnValue));
  padding = len - strSize;
  strncpy(returnValue + ((where == PAD_CENTER) ? (padding / 2) :
                         (where == PAD_LEFT) ? padding : 0), str, strSize);
  returnValue[len] = '\0';
  return returnValue;

}


/*
** Returns #str# with all occurrences of #toReplace# changed to #replacement#.
*/
static const char *
ReplaceAll(const char *str,
           char toReplace,
           char replacement) {
  char *c;
  static char returnValue[255 + 1];
  SAFE_STRCPY(returnValue, str);
  for(c = returnValue; *c != '\0'; c++) {
    if(*c == toReplace)
      *c = replacement;
  }
  return returnValue;
}


/*
** Returns #str# with any trailing whitespace removed.
*/
static const char *
TrimString(const char *str) {
  static char returnValue[255 + 1];
  char *c;
  SAFE_STRCPY(returnValue, str);
  for(c = returnValue + strlen(returnValue) - 1;
      (c >= returnValue) && isspace((int)*c); c--)
    ; /* Nothing more to do. */
  *(c + 1) = '\0';
  return returnValue;
}


/*
** Info about series used to compute a running forecast and map series names
** back to host and resource names.
*/
typedef struct {
  char name[255 + 1];
  SeriesSpec series;
  ForecastState *forecast;
} SeriesInfo;


/*
** Look through the #howManySeries#-long array #series# to make sure every
** source/destination pair of the #howManySources#-long array #sources# and the
** #howManyDests#-long array #dests# has an entry.  (#howManyDests# may be
** zero, in which case only source coverage is checked.)  Prints a message to
** stdout warning the user about any missing series.
*/
static void
CheckSeriesCoverage(const SeriesInfo *series,
                    size_t howManySeries,
                    const char **sources,
                    size_t howManySources,
                    const char **dests,
                    size_t howManyDests,
                    const char *resourceName) {

  char covered[255];
  int coveredIndex;
  const char **currentDest;
  const SeriesInfo *currentSeries;
  const char **currentSource;
  int destIndex;
  const char **endOfDests;
  const SeriesInfo *endOfSeries;
  const char **endOfSources;
  int sourceIndex;

  endOfDests = (howManyDests == 0) ? NULL : (dests + howManyDests);
  endOfSeries = series + howManySeries;
  endOfSources = sources + howManySources;
  memset(covered, 0, sizeof(covered));

  for(currentSeries = series; currentSeries < endOfSeries; currentSeries++) {
    for(currentSource=sources; currentSource < endOfSources; currentSource++) {
      if(strncmp(currentSeries->series.sourceMachine,
                 *currentSource, strlen(*currentSource)) == 0) {
        if(howManyDests == 0) {
          coveredIndex = currentSource - sources;
          if(covered[coveredIndex])
            ; /* TBD Multiple series mapping to one source. */
          covered[coveredIndex] = 1;
          break;
        }
        else {
          for(currentDest = dests; currentDest < endOfDests; currentDest++) {
            if(strncmp(currentSeries->series.destinationMachine,
                       *currentDest, strlen(*currentDest)) == 0) {
              coveredIndex = (currentSource - sources) * howManySources +
                             currentDest - dests;
              if(covered[coveredIndex])
                ; /* TBD Multiple series mapping to one source/dest pair. */
              covered[coveredIndex] = 1;
              break;
            }
          }
          if(currentDest < endOfDests)
            break;
        }
      }
    }
  }

  for(coveredIndex = (howManyDests == 0) ?
                     (howManySources - 1) : (howManySources * howManyDests - 1);
      coveredIndex >= 0;
      coveredIndex--) {
    if(!covered[coveredIndex]) {
      if(howManyDests == 0)
        fprintf(stderr,
                "Warning: no %s series available from %s; ignored\n",
                resourceName, sources[coveredIndex]);
      else {
        sourceIndex = coveredIndex / howManyDests;
        destIndex = coveredIndex % howManyDests;
        if(strcmp(sources[sourceIndex], dests[destIndex]) != 0)
          fprintf(stderr,
                  "Warning: no %s series available from %s to %s; ignored\n",
                  resourceName,
                  sources[sourceIndex],
                  dests[destIndex]);
      }
    }
  }

}


#define SIGNIFICANT_HISTORY 1000


/*
** Fetches measurements for #seriesName# taken since #sinceWhen# and uses them
** to compute in #stateToUse# and return up to #atMost# forecasts in #whereTo#.
** If successful, returns 1 and sets #numberReturned# to the number of
** forecasts copied into #where#; otherwise, returns 0.
*/
int
ExtractForecasts(const char *seriesName,
                 double sinceWhen,
                 ForecastState *stateToUse,
                 FORECASTAPI_ForecastCollection *whereTo,
                 size_t atMost,
                 size_t *numberReturned) {

  size_t historySize;
  static Measurement *measurements = NULL;

  /*
  ** Retrieve enough history to generate reasonably accurate forecasts even if
  ** the user wants only a few measurements,
  */
  historySize = (SIGNIFICANT_HISTORY > atMost) ? SIGNIFICANT_HISTORY : atMost;

  if(measurements == NULL) {
    measurements = (Measurement *)malloc(historySize * sizeof(Measurement));
    if(measurements == NULL) {
      fprintf(stderr, "ExtractForecasts: malloc failed\n");
      return 0;
    }
  }

  if(!GetMeasurements(seriesName,
                      sinceWhen,
                      measurements,
                      historySize,
                      &historySize)) {
    fprintf(stderr,
            "ExtractForecasts: unable to retrieve measurements for series %s\n",
            seriesName);
    return 0;
  }

  UpdateForecastState(stateToUse, measurements, historySize, whereTo, atMost);
  *numberReturned = (atMost < historySize) ? atMost : historySize;
  return 1;

}


typedef enum {
  DESTINATION, MAE_ERROR, MAE_PREDICTION, MAE_METHOD, MEASUREMENT,
  MSE_ERROR, MSE_PREDICTION, MSE_METHOD, RESOURCE, SOURCE, TIME
} Fields;
typedef enum {
  FIELD_NAME, FIELD_VALUE, FIELD_WIDTH
} FieldAttributes;
#define FORECAST_FIELD_COUNT (TIME + 1)


/*
** Formats the fields of #collection# and #series# listed in the
** #howManyFields#-long array #fieldsDesired# and returns the result.  The
** #howManyFields#-long array #whichAttributes# specifies, for each field,
** whether the field value, padding blanks, or the field name should be
** included in the image.
*/
static const char *
ForecastCollectionImage(const SeriesSpec *series,
                        const ForecastCollection *collection,
                        const Fields *fieldsDesired,
                        const FieldAttributes *whichAttributes,
                        size_t howManyFields) {

  char fieldValue[127 + 1];
  int i;
  char *nextChar;
  Fields printField;
  static const size_t FIELD_WIDTHS[FORECAST_FIELD_COUNT] =
    {32, NUMERIC_WIDTH, NUMERIC_WIDTH, 15, NUMERIC_WIDTH, NUMERIC_WIDTH, \
	 NUMERIC_WIDTH, 15, 20, 32, NUMERIC_WIDTH};
  static const char* HEADERS[FORECAST_FIELD_COUNT] =
    {"Destination", "MAE Err", "MAE Fore", "MAE Method", "Measure",
     "MSE Err", "MSE Fore", "MSE Method", "Resource", "Source", "Time"};
  static char returnValue[255 + 1];

  nextChar = returnValue;
  for(i = 0; i < howManyFields; i++) {
    printField = fieldsDesired[i];
    if(whichAttributes[i] == FIELD_WIDTH) {
      fieldValue[0] = '\0';
    }
    else if(whichAttributes[i] == FIELD_NAME) {
      SAFE_STRCPY(fieldValue, HEADERS[printField]);
    }
    else if(printField == DESTINATION)
      SAFE_STRCPY(fieldValue, ReplaceAll(series->destinationMachine,':','\0'));
    else if(printField == MAE_ERROR)
      sprintf(fieldValue, "%.*g", NUMERIC_WIDTH,
			  collection->forecasts[MAE_FORECAST].error);
    else if(printField == MAE_PREDICTION)
      sprintf(fieldValue, "%.*g", NUMERIC_WIDTH,
			  collection->forecasts[MAE_FORECAST].forecast);
    else if(printField == MAE_METHOD)
      SAFE_STRCPY(fieldValue,
                  MethodName(collection->forecasts[MAE_FORECAST].methodUsed));
    else if(printField == MEASUREMENT)
      sprintf(fieldValue, "%.*g", NUMERIC_WIDTH,
			  collection->measurement.measurement);
    else if(printField == MSE_ERROR)
      sprintf(fieldValue, "%.*g", NUMERIC_WIDTH,
			  collection->forecasts[MSE_FORECAST].error);
    else if(printField == MSE_PREDICTION)
      sprintf(fieldValue, "%.*g", NUMERIC_WIDTH,
			  collection->forecasts[MSE_FORECAST].forecast);
    else if(printField == MSE_METHOD)
      SAFE_STRCPY(fieldValue,
                  MethodName(collection->forecasts[MSE_FORECAST].methodUsed));
    else if(printField == RESOURCE)
      SAFE_STRCPY(fieldValue, series->resourceName);
    else if(printField == SOURCE)
      SAFE_STRCPY(fieldValue, ReplaceAll(series->sourceMachine, ':', '\0'));
    else if(printField == TIME) 
      sprintf(fieldValue, "%d", (int)collection->measurement.timeStamp);
    strcpy(fieldValue, Abbreviate(fieldValue, FIELD_WIDTHS[printField] - 1));
    strcpy(fieldValue, ReplaceAll(fieldValue, ' ', '_'));
    strcpy(nextChar, PadString(fieldValue,FIELD_WIDTHS[printField],PAD_RIGHT));
    nextChar += FIELD_WIDTHS[printField];
  }
  return TrimString(returnValue);

}


/*
** Prints those fields of #series# and #forecast# included in the
** #howManyFields#-long array *fieldsToPrint# to stdout.  #headerFrequency#
** indicates how often header information should be interspersed among field
** values.
*/
static void
PrintForecastCollection(int headerFrequency,
                        const SeriesSpec *series,
                        const ForecastCollection *forecast,
                        const Fields *fieldsToPrint,
                        size_t howManyFields) {

  int i;
  FieldAttributes printControl[FORECAST_FIELD_COUNT];
  static SeriesSpec priorSeries = {"", "", ""};
  static int callsUntilHeader = 0;

  if((headerFrequency > 0) && (callsUntilHeader == 0)) {
    for(i = 0; i < howManyFields; i++) {
      printControl[i] = FIELD_NAME;
    }
    printf("%s\n",
           ForecastCollectionImage(NULL,
                                   NULL,
                                   fieldsToPrint,
                                   printControl,
                                   howManyFields));
    for(i = 0; i < howManyFields; i++) {
      printControl[i] = FIELD_VALUE;
    }
    callsUntilHeader = headerFrequency - 1;
  }
  else {
    if(headerFrequency > 0) {
      callsUntilHeader--;
    }
    for(i = 0; i < howManyFields; i++) {
      if((fieldsToPrint[i] == RESOURCE) &&
         (strcmp(series->resourceName, priorSeries.resourceName) == 0))
        printControl[i] = FIELD_WIDTH;
      else if((fieldsToPrint[i] == DESTINATION) &&
              (strcmp(series->destinationMachine,
                      priorSeries.destinationMachine) == 0))
        printControl[i] = FIELD_WIDTH;
      else if((fieldsToPrint[i] == SOURCE) &&
              (strcmp(series->sourceMachine, priorSeries.sourceMachine) == 0))
        printControl[i] = FIELD_WIDTH;
      else
        printControl[i] = FIELD_VALUE;
    }
  }
  printf("%s\n",
         ForecastCollectionImage(series,
                                 forecast,
                                 fieldsToPrint,
                                 printControl,
                                 howManyFields));
  fflush(stdout);
  priorSeries = *series;

}


/*
** Retrieves from the name server registrations for all series matching
** #filter# that have a source equal to any element of the #sourceCount#-long
** array #sources# and their source and a destination equal to any element of
** the #destCount#-long array #dests#.  #destCount# may be zero, in which case
** #dests# is ignored.  Returns an array of series info for the retrieved
** registration and sets #seriesCount# to its length.  Returns NULL on error.
*/
static SeriesInfo *
RetrieveSeriesInfo(const char **sources,
                   int sourceCount,
                   const char **dests,
                   int destCount,
                   const char *filter,
                   int *seriesCount) {

  const char *attributeName;
  SeriesInfo currentSeries;
  char fullFilter[4095 + 1] = "";
  int hostIndex;
  SeriesInfo *returnValue;
  Attribute seriesAttribute;
  Object seriesObject;
  ObjectSet seriesObjectSet;

  /*
  ** Combine #filter#, #sources# and, optionally, #dests# into a name server
  ** retrieval filter:
  ** (&(objectclass=nwsSeries)<filter>(|(source=<source>)...)(|(dest=<dest)...))
  ** The host names appear in the registration as <machine>:<port>; we allow
  ** the user to drop the port and the full qualification of the machine.
  */
  MultiCat(fullFilter, sizeof(fullFilter), 4, "(&", SERIES, filter, "(|");
  for(hostIndex = 0; hostIndex < sourceCount; hostIndex++) {
    MultiCat(fullFilter, sizeof(fullFilter), 5,
             "(", HOST_ATTR, "=", sources[hostIndex],
             (strchr(sources[hostIndex], ':') != NULL) ? ")" :
             (strchr(sources[hostIndex], '.') != NULL) ? ":*)" : ".*)");
  }
  if(destCount != 0) {
    MultiCat(fullFilter, sizeof(fullFilter), 2, ")", "(|");
    for(hostIndex = 0; hostIndex < destCount; hostIndex++) {
      MultiCat(fullFilter, sizeof(fullFilter), 5,
               "(", TARGET_ATTR, "=", dests[hostIndex],
               (strchr(sources[hostIndex], ':') != NULL) ? ")" :
               (strchr(sources[hostIndex], '.') != NULL) ? ":*)" : ".*)");
    }
  }
  strcat(fullFilter, "))");

  if(!GetObjects(fullFilter, &seriesObjectSet)) {
    fprintf(stderr, "RetrieveSeriesInfo: series retrieval failed\n");
    return NULL;
  }

  *seriesCount = 0;
  ForEachObject(seriesObjectSet, seriesObject) {
    (*seriesCount)++;
  }

  returnValue = malloc(*seriesCount * sizeof(SeriesInfo));

  if(returnValue == NULL) {
    FreeObjectSet(&seriesObjectSet);
    fprintf(stderr, "RetrieveSeriesInfo: malloc failed\n");
    return NULL;
  }

  /* Parse each retrieved series into a SeriesInfo struct. */
  *seriesCount = 0;
  ForEachObject(seriesObjectSet, seriesObject) {

    SAFE_STRCPY(currentSeries.series.sourceMachine, "");
    SAFE_STRCPY(currentSeries.series.destinationMachine, "");
    SAFE_STRCPY(currentSeries.series.resourceName, "");
    SAFE_STRCPY(currentSeries.name, "");
    currentSeries.forecast = NewForecastState();

    ForEachAttribute(seriesObject, seriesAttribute) {
      attributeName = AttributeName(seriesAttribute);
      if(strcmp(attributeName, TARGET_ATTR) == 0) {
        SAFE_STRCPY(currentSeries.series.destinationMachine,
                    AttributeValue(seriesAttribute));
      }
      else if(strcmp(attributeName, NAME_ATTR) == 0) {
        SAFE_STRCPY(currentSeries.name, AttributeValue(seriesAttribute));
      }
      else if(strcmp(attributeName, RESOURCE_ATTR) == 0) {
        SAFE_STRCPY(currentSeries.series.resourceName,
                    AttributeValue(seriesAttribute));
      }
      else if(strcmp(attributeName, HOST_ATTR) == 0) {
        SAFE_STRCPY(currentSeries.series.sourceMachine,
                    AttributeValue(seriesAttribute));
      }

    }

    returnValue[(*seriesCount)++] = currentSeries;

  }

  FreeObjectSet(&seriesObjectSet);
  return returnValue;

}


static const char *FIELD_NAMES[] =
  {"destination", "mae_error", "mae_forecast", "mae_method", "measurement",
   "mse_error", "mse_forecast", "mse_method", "resource", "source", "time"};

/* Defaults for command-line values and NWS host ports. */
#define DEFAULT_DISPLAY_SIZE 20
#define DEFAULT_HEADER_FREQ 20
#define DEFAULT_MEMORY_PORT "8050"
#define DEFAULT_NAME_SERVER_PORT "8090"
#define DEFAULT_SENSOR_PORT "8060"
#define DEFAULT_FIELDS "time,measurement,mae_forecast,mae_error,mse_forecast,mse_error,source,destination,resource"
static const char *DEFAULT_RESOURCES[] = {
  DEFAULT_BANDWIDTH_RESOURCE, DEFAULT_AVAILABLE_CPU_RESOURCE,
  DEFAULT_CURRENT_CPU_RESOURCE, DEFAULT_LATENCY_RESOURCE,
  DEFAULT_MEMORY_RESOURCE
};
#define DEFAULT_RESOURCE_COUNT \
        (sizeof(DEFAULT_RESOURCES) / sizeof(DEFAULT_RESOURCES[0]))

#define TEN_MINUTES 600
#define SWITCHES "ad:f:h:M:n:N:t:w"
static const char *USAGE =
  "nws_extract [-aw] [-f fields] [-hnt <n>] [-MN host] resource [filter] host [host ...]";

int debug;

int
main(int argc,
     char *argv[]) {

  extern char *optarg;
  extern int optind;
  /* User-settable parameters. */
  int autoFetch = 0;
  int extractAllPairs = 0;
  int headerFrequency = DEFAULT_HEADER_FREQ;
  size_t initialDisplaySize = DEFAULT_DISPLAY_SIZE;
  char printOrder[255 + 1];
  double sinceWhen = BEGINNING_OF_TIME;

  /* Other local variables. */
  Measurement autoMeasurement;
  ForecastCollection currentForecast;
  char autoName[127 + 1];
  int extractCount;
  SeriesInfo *extractSeries;
  char *fieldBegin;
  char *fieldEnd;
  char filter[1023 + 1];
  const char **firstHost;
  int forecastIndex;
  ForecastCollection *forecasts;
  HostSpec host;
  int hostCount;
  int i;
  int interMachine;
  int lookupSeries = 1;
  int opt;
  size_t optlen;
  Fields printFields[FORECAST_FIELD_COUNT];
  size_t printFieldsLen;
  const char *resourceName;
  size_t returnedCount;

  SAFE_STRCPY(printOrder,
              EnvironmentValue("EXTRACT_FIELDS", DEFAULT_FIELDS));

  while((opt = getopt(argc, argv, SWITCHES)) != EOF) {

    switch(opt) {

    case 'a':
      extractAllPairs = 1;
      break;

    case 'd':
      /* Undocumented -debug switch for internal debugging. */
      if(strcmp(optarg, "ebug") == 0) {
        DirectDiagnostics(DIAGINFO, stdout);
        DirectDiagnostics(DIAGLOG, stdout);
        DirectDiagnostics(DIAGWARN, stderr);
        DirectDiagnostics(DIAGERROR, stderr);
        DirectDiagnostics(DIAGFATAL, stderr);
      }
      break;

    case 'f':
      SAFE_STRCPY(printOrder, optarg);
      break;

    case 'h':
      headerFrequency = atoi(optarg);
      break;

    case 'M':
      host = *MakeHostSpec
        (optarg, atoi(EnvironmentValue("MEMORY_PORT", DEFAULT_MEMORY_PORT)));
      if(!UseMemory(&host)) {
        fprintf(stderr, "Unable to contact memory %s:%d\n",
                host.machineName, host.machinePort);
        exit(1);
      }
      lookupSeries = 0;
      break;

    case 'n':
      initialDisplaySize = atoi(optarg);
      break;

    case 'N':
      host = *MakeHostSpec
        (optarg,
         atoi(EnvironmentValue("NAME_SERVER_PORT", DEFAULT_NAME_SERVER_PORT)));
      if(!UseNameServer(&host)) {
        fprintf(stderr, "Unable to contact name server %s:%d\n",
                host.machineName, host.machinePort);
        exit(1);
      }
      break;

    case 't':
      sinceWhen = time(NULL) - atoi(optarg);
      break;

    case 'w':
      autoFetch = 1;
      break;

    default:
      fprintf(stderr, "nws_extract: unrecognized switch\n%s\n", USAGE);
      exit(1);
      break;

    }

  }

  /*
  ** Determine which resource we're being asked to extract and see if the user
  ** has specified the optional filter to distinguish between multiple series.
  */
  if((optind + 1) >= argc) {
    fprintf(stderr, "%s\n", USAGE);
    exit(1);
  }
  resourceName = argv[optind];
  optlen = strlen(resourceName);
  for(i = 0; i < DEFAULT_RESOURCE_COUNT; i++) {
    if(strncasecmp(resourceName, DEFAULT_RESOURCES[i], optlen) == 0) {
      resourceName = DEFAULT_RESOURCES[i];
      break;
    }
  }

  optind++;
  filter[0] = '\0';
  if(*argv[optind] == '(') {
    MultiCat(filter, sizeof(filter), 7,
             "(&", argv[optind], "(", RESOURCE_ATTR, "=", resourceName, "))");
    optind++;
    if(optind >= argc) {
      fprintf(stderr, "%s\n", USAGE);
      exit(1);
    }
  }
  else {
    MultiCat(filter, sizeof(filter), 5,
             "(", RESOURCE_ATTR, "=", resourceName, ")");
  }

  interMachine = IntermachineResource(resourceName);
  if(interMachine && ((optind + 1) >= argc))
    ABORT("You must specify at least one destination machine\n");

  /* Determine the field display order. */
  for(printFieldsLen = 0, fieldBegin = printOrder;
      ;
      fieldBegin = fieldEnd + 1) {
    fieldEnd = strchr(fieldBegin, ',');
    if(fieldEnd == NULL)
      fieldEnd = fieldBegin + strlen(fieldBegin);
    for(i = 0; i < FORECAST_FIELD_COUNT; i++) {
      if(strncasecmp(fieldBegin, FIELD_NAMES[i], fieldEnd - fieldBegin) == 0)
        break;
    }
    if(i == FORECAST_FIELD_COUNT) {
      fprintf(stderr, "Unknown field name %s\n", fieldBegin);
      exit(1);
    }
    /* Ignore destination for single-machine resources. */
    if(interMachine || ((Fields)i != DESTINATION))
      printFields[printFieldsLen++] = (Fields)i;
    if(*fieldEnd == '\0')
      break;
  }

  /* Get the information about the specified series from the name server. */
  hostCount = argc - optind;
  firstHost = (const char **)&argv[optind];
  if(lookupSeries) {
    extractSeries = RetrieveSeriesInfo(firstHost,
                                       (!interMachine || extractAllPairs) ?
                                        hostCount : 1,
                                       firstHost,
                                       interMachine ? hostCount : 0,
                                       filter,
                                       &extractCount);
    if(extractSeries == NULL)
      exit(1); /* Error message will come from RetrieveSeriesInfo */
    CheckSeriesCoverage(extractSeries,
                        extractCount,
                        firstHost,
                        (!interMachine || extractAllPairs) ?
                        hostCount : 1,
                        firstHost,
                        interMachine ? hostCount : 0,
                        resourceName);
  }
  else {
    /* Assume the user has correctly specified all series names. */
    extractCount = !interMachine ? hostCount :
                   extractAllPairs ? (hostCount * (hostCount - 1)) :
                   (hostCount - 1);
    extractSeries = (SeriesInfo *)malloc(extractCount * sizeof(SeriesInfo));
    extractCount = 0;
    if(!interMachine) {
      for(i = 0; i < hostCount; i++) {
        strcpy(extractSeries[extractCount].series.sourceMachine, firstHost[i]);
        strcpy(extractSeries[extractCount].series.destinationMachine, "");
        extractCount++;
      }
    }
    else if(extractAllPairs) {
      int j;
      for(i = 0; i < hostCount; i++) {
        for(j = 0; j < hostCount; j++) {
          if(i != j) {
            strcpy(extractSeries[i].series.sourceMachine,
                   firstHost[i]);
            strcpy(extractSeries[extractCount].series.destinationMachine,
                   firstHost[j]);
            extractCount++;
          }
        }
      }
    }
    else {
      for(i = 1; i < hostCount; i++) {
        strcpy(extractSeries[extractCount].series.sourceMachine,
               firstHost[0]);
        strcpy(extractSeries[extractCount].series.destinationMachine,
               firstHost[i]);
        extractCount++;
      }
    }
    for(i = 0; i < extractCount; i++) {
      strcpy(extractSeries[i].series.resourceName, resourceName);
      strcpy(extractSeries[i].name, SeriesName(&extractSeries[i].series));
      extractSeries[i].forecast = NewForecastState();
    }
  }
  forecasts = (ForecastCollection *)
    malloc(initialDisplaySize * sizeof(ForecastCollection));
  if(forecasts == NULL) {
    fprintf(stderr, "malloc failed\n");
    exit(1);
  }

  /* Compute and print the initial forecast set for each series. */
  for(i = 0; i < extractCount; i++) {

    if(ExtractForecasts(extractSeries[i].name,
                        sinceWhen,
                        extractSeries[i].forecast,
                        forecasts,
                        initialDisplaySize,
                        &returnedCount)) {
      if(returnedCount > 0) {
        for(forecastIndex = 0; forecastIndex < returnedCount; forecastIndex++) {
          currentForecast = forecasts[returnedCount - 1 - forecastIndex];
          PrintForecastCollection(headerFrequency,
                                  &extractSeries[i].series,
                                  &currentForecast,
                                  printFields,
                                  printFieldsLen);
        }
      }
      else {
        fprintf(stderr, "No measurements from %s qualified.\n",
                extractSeries[i].series.sourceMachine);
      }
    }

    if(autoFetch) {
      (void)AutoFetchBegin(extractSeries[extractCount].name);
    }

    fflush(stdout);

  }

  free(forecasts);

  /*
  ** If requested, continue to display new measurements and forecasts based on
  ** them as they come in.
  */
  if(autoFetch) {
    while(AutoFetchCheck(autoName,
                         sizeof(autoName),
                         &autoMeasurement,
                         TEN_MINUTES)) {
      for(i = 0;
          (i < extractCount) && (strcmp(autoName, extractSeries[i].name) != 0);
          i++)
        ; /* Nothing more to do. */
      if(i == extractCount)
        continue; /* Unknown series? */
      UpdateForecastState(extractSeries[i].forecast,
                          &autoMeasurement,
                          1,
                          &currentForecast,
                          1);
      PrintForecastCollection(headerFrequency,
                              &extractSeries[i].series,
                              &currentForecast,
                              printFields,
                              printFieldsLen);
    }
  }

  /* Tidy up. */
  for(i = 0; i < extractCount; i++) {
    FreeForecastState(&extractSeries[i].forecast);
  }
  free(extractSeries);

  return 0;

}
