/* $Id: nws_memory.h,v 1.11 2000/07/13 18:25:56 swany Exp $ */

#ifndef MEMORY_H
#define MEMORY_H


#include <stddef.h>      /* offsetof() */
#include "formatutil.h"  /* DataDescriptor */
#include "messages.h"    /* Message number ranges */


/*
** Messages recognized and/or generated by nws_memory.
**
** STORE_STATE(state,contents) -- sent to the nws_memory process to request
**   that the bytes #contents# should be stored with the characteristics
**   described by #state#.  nws_memory replies with either a STATE_STORED or a
**   MEMORY_FAILED message depending on the success of the store activity.
** STATE_STORED(void) -- sent from the nws_memory process as the successful
**   reply to a STORE_STATE message.
** FETCH_STATE(state) -- sent to the nws_memory process to request that the
**   contents of the state described by #state# be transmitted to the sender.
**   nws_memory replies with either a STATE_TYPE or or a MEMORY_FAILED message
**   depending on the success of the retrieval.
** STATE_FETCHED(state[,contents]) -- sent from the nws_memory process as the
**   successful reply to a LOAD_STATE message.  #contents# contains the bytes
**   of the loaded state; its characteristics are described by #state#.
** AUTOFETCH_BEGIN(nameList) -- sent to the nws_memory process to request that
**   it begin automatically forwarding STORE_STATE message for all of the state
**   names listed in the tab-delimited, nul-terminated string #nameList#.
**   nws_memory replies with an AUTOFETCH_ACK message.  Whenever the memory
**   receives a STORE_STATE message for any of these state names, it immediately
**   transmits a STATE_FETCHED message, containing the newly-stored records, on
**   the socket where the AUTOFETCH_BEGIN was received.  This continues until
**   the client either sends another AUTOFETCH_BEGIN message with an empty name
**   list or closes the connection.
** AUTOFETCH_ACK(void) -- sent from the nws_memory process as the successful
**   reply to a AUTOFETCH_BEGIN message.
** MEMORY_CLEAN(seconds) -- sent to the nws_memory process to direct it to
**   delete any state files that have not been accessed for the past #seconds#
**   (an unsigned integer) seconds.  nws_memory replies with a MEMORY_CLEANED
**   message.
** MEMORY_CLEANED(void) -- sent from the nws_memory process as the successful
**   reply to a MEMORY_CLEAN message.
** MEMORY_FAILED(void) -- sent from the nws_memory process as the unsuccessful
**   reply to either a STORE_STATE or LOAD_STATE message.
*/

#define STORE_STATE   MEMORY_FIRST_MESSAGE
#define STATE_STORED  (STORE_STATE + 1)

#define FETCH_STATE   (STATE_STORED + 1)
#define STATE_FETCHED (FETCH_STATE + 1)

#define AUTOFETCH_BEGIN (STATE_FETCHED + 1)
#define AUTOFETCH_ACK   (AUTOFETCH_BEGIN + 1)

#define MEMORY_CLEAN    (AUTOFETCH_ACK + 1)
#define MEMORY_CLEANED  (MEMORY_CLEAN + 1)

#define MEMORY_LOGDEST  (MEMORY_CLEANED + 1)
#define MEMORY_LOGDEST_ACK (MEMORY_LOGDEST + 1)

#define MEMORY_FAILED MEMORY_LAST_MESSAGE


/* Arbitrary limit on the length of state names. */
#define STATE_NAME_SIZE (127 + 1)


/*
** A structure that describes a stored state (basically, a file).  #id# is the
** client-supplied unique identifier for the state.  #rec_size# is the length
** of each record in the state (state files have fixed-length records).
** #rec_size# is the number of records that accompanies the state record in the
** {FETCH,STORE}_STATE message, *not* the total number of records in the file
** (the latter is determined by nws_memory).  #seq_no# is a time-stamp
** indicating the time that the state records were generated, #time_out# the
** number of seconds that they should be held before being discarded.
*/
struct state {
  char id[STATE_NAME_SIZE];
  int rec_size;
  int rec_count;
  double seq_no;
  double time_out;
};
const static DataDescriptor stateDescriptor[] =
  {SIMPLE_MEMBER(CHAR_TYPE, STATE_NAME_SIZE, offsetof(struct state, id)),
   SIMPLE_MEMBER(INT_TYPE, 1, offsetof(struct state, rec_size)),
   SIMPLE_MEMBER(INT_TYPE, 1, offsetof(struct state, rec_count)),
   SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(struct state, seq_no)),
   SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(struct state, time_out))};
#define stateDescriptorLength 5

#define LOCATION_NAME_SIZE 128

typedef enum {MEMORY_LOG_NONE, MEMORY_LOG_LOCAL, MEMORY_LOG_NETLOGGER,
			  MEMORY_LOG_REMOTE} MemLogDest;

struct loglocation {
  int loc_type; /* MEMORY_LOGLOCATION message types */
  char path[LOCATION_NAME_SIZE]; /* dir, host:port, host:dir */
};

const static DataDescriptor loglocationDescriptor[] =
  {SIMPLE_MEMBER(INT_TYPE, 1, offsetof(struct loglocation, loc_type)),
  SIMPLE_MEMBER(CHAR_TYPE, LOCATION_NAME_SIZE,
				offsetof(struct loglocation, path))};

#define loglocationDescriptorLength 2

#endif
