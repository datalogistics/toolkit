/* $Id: periodic.c,v 1.9 2000/06/28 19:15:56 swany Exp $ */

#include "config.h"
#include <unistd.h>     /* getppid(), sleep() */
#include <signal.h>     /* kill() */
#include <stdio.h>      /* sprintf() */
#include <stdlib.h>     /* atoi() free() malloc() REALLOC() */
#include <string.h>     /* strcmp() strlen() */

#include "exp_protocol.h"   /* experiment storage and registration */
#include "host_protocol.h"  /* MakeHostCookie() RegisterObject() */
#include "diagnostic.h"     /* ABORT() FAIL() WARN() */
#include "messages.h"       /* message facilities */
#include "osutil.h"         /* CurrentTime() */
#include "skills.h"         /* skill invocation */
#include "strutil.h"        /* GETTOK() SAFESTRCPY() */
#include "periodic.h"


/*
** Messages recognized and/or generated by the periodic module:
**
** PERIODIC_SERIES(name,series) -- sent from a child process to request
**   that the enclosed #series# (a registration Object) be registered as a
**   result of the activity named #name#.
**   NOTE: We assume below that registration Objects are implemented as
**   strings.  This presently is the case and is likely to continue so, but
**   we'll need Object transmission or translation functions in event of change.
*/
#define PERIODIC_SERIES PERIODIC_FIRST_MESSAGE


#define DEFAULT_PERIOD "10"
#define KEEP_A_LONG_TIME 315360000.0


#define SUPPORTED_SKILLS_COUNT 5
static KnownSkills SUPPORTED_SKILLS[SUPPORTED_SKILLS_COUNT] =
  {cpuMonitor, diskMonitor, memoryMonitor, tcpConnectMonitor,
   tcpMessageMonitor};


/*
** Information about a running monitor.  #name# is the registration name,
** #period# the frequency (in seconds) with which we take measurements, #pid#
** the process id of the forked process that's running the experiments, #skill#
** the skill being used, #skillOptions# the skill-specific option values, and
** #series# a tab-delimited list of series names generated by this activity.
*/
typedef struct {
  char name[63 + 1];
  int period;
  pid_t pid;
  KnownSkills skill;
  char skillOptions[EXP_LIST_SIZE];
  char *series;
} PeriodicActivity;


/*
** Module globals.  #activities# and #activityCount# track the currently-running
** monitors.  #memoryDesc# is a cached specification of where to store
** measurements and #memoryReg# its registration name.
*/
static PeriodicActivity *activities = NULL;
static int activityCount = 0;
static struct host_desc memoryDesc = {"", 0};
static char *memoryReg = NULL;


/*
** Handles a #messageType# periodic control message arrived on #sd# accompanied
** by #dataSize# bytes of data.
*/
static void
ProcessRequest(Socket *sd,
               MessageType messageType,
               size_t dataSize) {

  char *activityName;
  char *data;
  int i;
  DataDescriptor descriptor = SIMPLE_DATA(CHAR_TYPE, 0);
  const char *seriesName;
  Object toRegister;

  switch(messageType) {

  case PERIODIC_SERIES:

    data = (char *)malloc(dataSize);
    if(data == NULL) {
      ERROR("ProcessRequest: out of memory\n");
    }
    else {
      descriptor.repetitions = dataSize;
      if(!RecvData(*sd, data, &descriptor, 1, PktTimeOut(*sd))) {
        ERROR("ProcessRequest: data receive failed\n");
      }
      else {
        activityName = data;
        toRegister = activityName + strlen(activityName) + 1;
        for(i = 0; (i < activityCount); i++) {
          if(strcmp(activityName, activities[i].name) != 0) {
            RegisterObject(toRegister);
            seriesName = AttributeValue(FindAttribute(toRegister, "name"));
            activities[i].series =
               REALLOC(activities[i].series,
                       strlen(activities[i].series) + strlen(seriesName) + 2);
            strcat(activities[i].series, "\t");
            strcat(activities[i].series, seriesName);
            break;
          }
        }
      }
      free(data);
    }
    break;

  default:

    ERROR1("ProcessRequest: unknown message %d\n", messageType);
    break;

  }

}


/*
** Registers #periodic# with the name server.
*/
static void
RegisterActivity(const PeriodicActivity *periodic) {

  Activity activity;
  int i;
  int length;
  char option[EXP_LIST_SIZE];
  const MeasuredResources *resources;
  Object toRegister;

  SAFESTRCPY(activity.controlName, PERIODIC_CONTROL_NAME);
  SAFESTRCPY(activity.host, EstablishedRegistration());
  SkillResources(periodic->skill, periodic->skillOptions, &resources, &length);
  SAFESTRCPY(activity.resources, "");
  for(i = 0; i < length; i++) {
    if(i > 0)
      strcat(activity.resources, "\t");
    strcat(activity.resources, ResourceName(resources[i]));
  }
  SAFESTRCPY(activity.skillName, SkillName(periodic->skill));
  sprintf(option, "period:%d", periodic->period);
  if(periodic->skillOptions[0] != '\0') {
    strcat(option, "\t");
    strcat(option, periodic->skillOptions);
  }
  activity.options = strdup(option);
  toRegister = ObjectFromActivity(periodic->name, &activity);
  RegisterObject(toRegister);
  FreeObject(&toRegister);
  free(activity.options);

}


/*
** Unregisters all objects related to #periodic#.
*/
static void
UnregisterActivity(const PeriodicActivity *periodic) {
  const char *c;
  char seriesName[255 + 1];
  UnregisterObject(periodic->name);
  for(c = periodic->series; GETTOK(seriesName, c, "\t", &c); )
    UnregisterObject(seriesName);
}


void
PeriodicChildDeath(int pid) {
  int i;
  for(i = 0; i < activityCount; i++) {
    if(activities[i].pid == pid) {
      UnregisterActivity(&activities[i]);
      activities[i] = activities[--activityCount];
      break;
    }
  }
}


int
PeriodicInit(const char *memoryName,
             const struct host_desc *memory) {

  Control control;
  int i;
  Object toRegister;

  /* Cache sensor and memory for later use. */
  memoryDesc = *memory;
  memoryReg = strdup(memoryName);

  /* Register the periodic control. */
  SAFESTRCPY(control.controlName, PERIODIC_CONTROL_NAME);
  SAFESTRCPY(control.host, EstablishedRegistration());
  control.skills[0] = '\0';
  for(i = 0; i < SUPPORTED_SKILLS_COUNT; i++) {
    if(SkillAvailable(SUPPORTED_SKILLS[i], "")) {
      if(control.skills[0] != '\0')
        strcat(control.skills, "\t");
      strcat(control.skills, SkillName(SUPPORTED_SKILLS[i]));
    }
  }
  SAFESTRCPY(control.options, "period:0_to_1_int");
  toRegister = ObjectFromControl(NameOfControl(&control), &control);
  RegisterObject(toRegister);
  FreeObject(&toRegister);

  RegisterListener(PERIODIC_SERIES, "PERIODIC_SERIES", &ProcessRequest);
  return 1;

}


void
PeriodicWork(void) {
  /* Nothing to do because we fork. */
}


double
NextPeriodicWork(void) {
  return 0.0;  /* We never need to be called to do work because we fork. */
}


int
RecognizedPeriodicActivity(const char *name) {
  int i;
  for(i = 0; i < activityCount; i++) {
    if(strcmp(activities[i].name, name) == 0)
      return 1;
  }
  return 0;
}


int
StartPeriodicActivity(const char *activity,
                      const char *skill,
                      const char *options) {

  Socket childToParent;
  Experiment expToStore;
  int i;
  int length;
  struct host_cookie memory;
  DataDescriptor nameDescriptor = SIMPLE_DATA(CHAR_TYPE, 0);
  PeriodicActivity newActivity;
  DataDescriptor objectDescriptor = SIMPLE_DATA(CHAR_TYPE, 0);
  const SkillResult *results;
  Series series;
  const char *seriesName;
  double timeAfterExp;
  double timeBeforeExp;
  Object toRegister;

  newActivity.skill = SUPPORTED_SKILLS[0];
  for(i = 0; i < SUPPORTED_SKILLS_COUNT; i++) {
    if(strcmp(skill, SkillName(SUPPORTED_SKILLS[i])) == 0) {
      newActivity.skill = SUPPORTED_SKILLS[i];
      break;
    }
  }

  if(i == SUPPORTED_SKILLS_COUNT) {
    FAIL1("StartPeriodicActivity: Unsupported skill %s requested\n", skill);
  }
  else if(!SkillAvailable(SUPPORTED_SKILLS[i], options)) {
    FAIL1("StartPeriodicActivity: Skill %s unavailable on this host\n", skill);
  }

  SAFESTRCPY(newActivity.name, activity);
  newActivity.period = atoi(GetOptionValue(options, "period", DEFAULT_PERIOD));
  SkillOptions(newActivity.skill, options, newActivity.skillOptions);
  newActivity.series = strdup("");

  if(!CreateLocalChild(&newActivity.pid, NULL, &childToParent)) {
    free(newActivity.series);
    FAIL("StartPeriodicActivity: fork failed\n");
  }

  if(newActivity.pid != 0) {
    /* Parent process. */
    activityCount++;
    activities = (PeriodicActivity *)
      REALLOC(activities, activityCount * sizeof(PeriodicActivity));
    activities[activityCount - 1] = newActivity;
    RegisterActivity(&newActivity);
    return 1;
  }

  MakeHostCookie(memoryDesc.host_name, memoryDesc.port, &memory);

  /* Run as long as the parent process runs. */
  while(getppid() != 1) {
    timeBeforeExp = CurrentTime();
    UseSkill(newActivity.skill,
             newActivity.skillOptions,
             newActivity.period,
             &results,
             &length);
    expToStore.timeStamp = CurrentTime();
    for(i = 0; i < length; i++) {
      if(results[i].succeeded) {
        expToStore.value = results[i].measurement;
        SAFESTRCPY(series.host, EstablishedRegistration());
        SAFESTRCPY(series.label, ResourceLabel(results[i].resource));
        SAFESTRCPY(series.memory, memoryReg);
        SAFESTRCPY(series.options, results[i].options);
        SAFESTRCPY(series.resource, ResourceName(results[i].resource));
        seriesName = NameOfSeries(&series);
        if(StoreExperiments(&memory,
                            seriesName,
                            &expToStore,
                            1,
                            KEEP_A_LONG_TIME) &&
           (strstr(newActivity.series, seriesName) == NULL)) {
          /*
          ** We want the main sensor to handle the registration of new series,
          ** so we send the necessary information back to the parent.
          */
          toRegister = ObjectFromSeries(seriesName, &series);
          newActivity.series =
             REALLOC(newActivity.series,
                     strlen(newActivity.series) + strlen(seriesName) + 2);
          strcat(newActivity.series, "\t");
          strcat(newActivity.series, seriesName);
          nameDescriptor.repetitions = strlen(seriesName) + 1;
          objectDescriptor.repetitions = strlen(toRegister) + 1;
          SendMessageAndDatas(childToParent,
                              PERIODIC_SERIES,
                              seriesName,
                              &nameDescriptor,
                              1,
                              toRegister,
                              &objectDescriptor,
                              1,
                              PktTimeOut(childToParent));
          FreeObject(&toRegister);
        }
      }
      else {
        WARN1("PeriodicMonitor: %s failed\n", newActivity.name);
      }
    }
    timeAfterExp = CurrentTime();
    if((int)(timeAfterExp - timeBeforeExp) < newActivity.period) {
      sleep(newActivity.period - (int)(timeAfterExp - timeBeforeExp));
    }
  }

  exit(0);
  return 0;

}


int
StopPeriodicActivity(const char *registration) {
  int i;
  if(*registration == '\0') {
    for(i = 0; i < activityCount; i++) {
      UnregisterActivity(&activities[i]);
      kill(activities[i].pid, SIGKILL);
      free(activities[i].series);
    }
    activityCount = 0;
    return 1;
  }
  for(i = 0; i < activityCount; i++) {
    if(strcmp(activities[i].name, registration) == 0) {
      UnregisterActivity(&activities[i]);
      kill(activities[i].pid, SIGKILL);
      free(activities[i].series);
      activities[i] = activities[--activityCount];
      return 1;
    }
  }
  return 0;
}
