<HTML
><HEAD
><TITLE
>tree</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Gnome XML Library Reference Manual"
HREF="book1.html"><LINK
REL="UP"
TITLE="Libxml Library Reference"
HREF="libxml-lib.html"><LINK
REL="PREVIOUS"
TITLE="SAX"
HREF="libxml-sax.html"><LINK
REL="NEXT"
TITLE="entities"
HREF="libxml-entities.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="5"
>Gnome XML Library Reference Manual</FONT
></TH
></TR
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="libxml-sax.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#0000C0"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="book1.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#00C000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="libxml-lib.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="libxml-entities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="LIBXML-TREE">tree</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN3886"
></A
><H2
>Name</H2
>tree&nbsp;--&nbsp;</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN3889"><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>&#13;

struct      <A
HREF="libxml-tree.html#XMLPARSERINPUTBUFFER"
>xmlParserInputBuffer</A
>;
typedef     <A
HREF="libxml-tree.html#XMLPARSERINPUTBUFFERPTR"
>xmlParserInputBufferPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLOUTPUTBUFFER"
>xmlOutputBuffer</A
>;
typedef     <A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
>;
struct      <A
HREF="libxml-parser.html#XMLPARSERINPUT"
>xmlParserInput</A
>;
typedef     <A
HREF="libxml-tree.html#XMLPARSERINPUTPTR"
>xmlParserInputPtr</A
>;
struct      <A
HREF="libxml-parser.html#XMLPARSERCTXT"
>xmlParserCtxt</A
>;
typedef     <A
HREF="libxml-tree.html#XMLPARSERCTXTPTR"
>xmlParserCtxtPtr</A
>;
struct      <A
HREF="libxml-parser.html#XMLSAXLOCATOR"
>xmlSAXLocator</A
>;
typedef     <A
HREF="libxml-tree.html#XMLSAXLOCATORPTR"
>xmlSAXLocatorPtr</A
>;
struct      <A
HREF="libxml-parser.html#XMLSAXHANDLER"
>xmlSAXHandler</A
>;
typedef     <A
HREF="libxml-tree.html#XMLSAXHANDLERPTR"
>xmlSAXHandlerPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLENTITY"
>xmlEntity</A
>;
typedef     <A
HREF="libxml-tree.html#XMLENTITYPTR"
>xmlEntityPtr</A
>;
#define     <A
HREF="libxml-tree.html#BASE-BUFFER-SIZE-CAPS"
>BASE_BUFFER_SIZE</A
>
#define     <A
HREF="libxml-tree.html#XML-XML-NAMESPACE-CAPS"
>XML_XML_NAMESPACE</A
>
enum        <A
HREF="libxml-tree.html#XMLELEMENTTYPE"
>xmlElementType</A
>;
typedef     <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>;
#define     <A
HREF="libxml-tree.html#BAD-CAST-CAPS"
>BAD_CAST</A
>
struct      <A
HREF="libxml-tree.html#XMLNOTATION"
>xmlNotation</A
>;
typedef     <A
HREF="libxml-tree.html#XMLNOTATIONPTR"
>xmlNotationPtr</A
>;
enum        <A
HREF="libxml-tree.html#XMLATTRIBUTETYPE"
>xmlAttributeType</A
>;
enum        <A
HREF="libxml-tree.html#XMLATTRIBUTEDEFAULT"
>xmlAttributeDefault</A
>;
struct      <A
HREF="libxml-tree.html#XMLENUMERATION"
>xmlEnumeration</A
>;
typedef     <A
HREF="libxml-tree.html#XMLENUMERATIONPTR"
>xmlEnumerationPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLATTRIBUTE"
>xmlAttribute</A
>;
typedef     <A
HREF="libxml-tree.html#XMLATTRIBUTEPTR"
>xmlAttributePtr</A
>;
enum        <A
HREF="libxml-tree.html#XMLELEMENTCONTENTTYPE"
>xmlElementContentType</A
>;
enum        <A
HREF="libxml-tree.html#XMLELEMENTCONTENTOCCUR"
>xmlElementContentOccur</A
>;
struct      <A
HREF="libxml-tree.html#XMLELEMENTCONTENT"
>xmlElementContent</A
>;
typedef     <A
HREF="libxml-tree.html#XMLELEMENTCONTENTPTR"
>xmlElementContentPtr</A
>;
enum        <A
HREF="libxml-tree.html#XMLELEMENTTYPEVAL"
>xmlElementTypeVal</A
>;
struct      <A
HREF="libxml-tree.html#XMLELEMENT"
>xmlElement</A
>;
typedef     <A
HREF="libxml-tree.html#XMLELEMENTPTR"
>xmlElementPtr</A
>;
#define     <A
HREF="libxml-tree.html#XML-LOCAL-NAMESPACE-CAPS"
>XML_LOCAL_NAMESPACE</A
>
typedef     <A
HREF="libxml-tree.html#XMLNSTYPE"
>xmlNsType</A
>;
struct      <A
HREF="libxml-tree.html#XMLNS"
>xmlNs</A
>;
typedef     <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLDTD"
>xmlDtd</A
>;
typedef     <A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLATTR"
>xmlAttr</A
>;
typedef     <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLID"
>xmlID</A
>;
typedef     <A
HREF="libxml-tree.html#XMLIDPTR"
>xmlIDPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLREF"
>xmlRef</A
>;
typedef     <A
HREF="libxml-tree.html#XMLREFPTR"
>xmlRefPtr</A
>;
enum        <A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
>;
struct      <A
HREF="libxml-tree.html#XMLBUFFER"
>xmlBuffer</A
>;
typedef     <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
>;
struct      <A
HREF="libxml-tree.html#XMLNODE"
>xmlNode</A
>;
typedef     <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>;
#define     <A
HREF="libxml-tree.html#XML-GET-CONTENT-CAPS"
>XML_GET_CONTENT</A
>                 (n)
#define     <A
HREF="libxml-tree.html#XML-GET-LINE-CAPS"
>XML_GET_LINE</A
>                    (n)
struct      <A
HREF="libxml-tree.html#XMLDOC"
>xmlDoc</A
>;
typedef     <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>;
#define     <A
HREF="libxml-tree.html#XMLCHILDRENNODE"
>xmlChildrenNode</A
>
#define     <A
HREF="libxml-tree.html#XMLROOTNODE"
>xmlRootNode</A
>
void        <A
HREF="libxml-tree.html#XMLSETBUFFERALLOCATIONSCHEME"
>xmlSetBufferAllocationScheme</A
>    (<A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> scheme);
<A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> <A
HREF="libxml-tree.html#XMLGETBUFFERALLOCATIONSCHEME"
>xmlGetBufferAllocationScheme</A
>
                                            (void);
<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> <A
HREF="libxml-tree.html#XMLBUFFERCREATE"
>xmlBufferCreate</A
>                (void);
<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> <A
HREF="libxml-tree.html#XMLBUFFERCREATESIZE"
>xmlBufferCreateSize</A
>            (<GTKDOCLINK
HREF="SIZE-T"
>size_t</GTKDOCLINK
> size);
int         <A
HREF="libxml-tree.html#XMLBUFFERRESIZE"
>xmlBufferResize</A
>                 (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int size);
void        <A
HREF="libxml-tree.html#XMLBUFFERFREE"
>xmlBufferFree</A
>                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);
int         <A
HREF="libxml-tree.html#XMLBUFFERDUMP"
>xmlBufferDump</A
>                   (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *file,
                                             <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);
void        <A
HREF="libxml-tree.html#XMLBUFFERADD"
>xmlBufferAdd</A
>                    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str,
                                             int len);
void        <A
HREF="libxml-tree.html#XMLBUFFERADDHEAD"
>xmlBufferAddHead</A
>                (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str,
                                             int len);
void        <A
HREF="libxml-tree.html#XMLBUFFERCAT"
>xmlBufferCat</A
>                    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str);
void        <A
HREF="libxml-tree.html#XMLBUFFERCCAT"
>xmlBufferCCat</A
>                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const char *str);
int         <A
HREF="libxml-tree.html#XMLBUFFERSHRINK"
>xmlBufferShrink</A
>                 (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int len);
int         <A
HREF="libxml-tree.html#XMLBUFFERGROW"
>xmlBufferGrow</A
>                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int len);
void        <A
HREF="libxml-tree.html#XMLBUFFEREMPTY"
>xmlBufferEmpty</A
>                  (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);
const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>* <A
HREF="libxml-tree.html#XMLBUFFERCONTENT"
>xmlBufferContent</A
>             (const <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);
void        <A
HREF="libxml-tree.html#XMLBUFFERSETALLOCATIONSCHEME"
>xmlBufferSetAllocationScheme</A
>    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> scheme);
int         <A
HREF="libxml-tree.html#XMLBUFFERLENGTH"
>xmlBufferLength</A
>                 (const <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);
<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   <A
HREF="libxml-tree.html#XMLCREATEINTSUBSET"
>xmlCreateIntSubset</A
>              (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *ExternalID,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *SystemID);
<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   <A
HREF="libxml-tree.html#XMLNEWDTD"
>xmlNewDtd</A
>                       (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *ExternalID,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *SystemID);
<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   <A
HREF="libxml-tree.html#XMLGETINTSUBSET"
>xmlGetIntSubset</A
>                 (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
void        <A
HREF="libxml-tree.html#XMLFREEDTD"
>xmlFreeDtd</A
>                      (<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLNEWGLOBALNS"
>xmlNewGlobalNs</A
>                  (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *prefix);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLNEWNS"
>xmlNewNs</A
>                        (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *prefix);
void        <A
HREF="libxml-tree.html#XMLFREENS"
>xmlFreeNs</A
>                       (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLFREENSLIST"
>xmlFreeNsList</A
>                   (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>   <A
HREF="libxml-tree.html#XMLNEWDOC"
>xmlNewDoc</A
>                       (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *version);
void        <A
HREF="libxml-tree.html#XMLFREEDOC"
>xmlFreeDoc</A
>                      (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCPROP"
>xmlNewDocProp</A
>                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLNEWPROP"
>xmlNewProp</A
>                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLNEWNSPROP"
>xmlNewNsProp</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLNEWNSPROPEATNAME"
>xmlNewNsPropEatName</A
>             (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
void        <A
HREF="libxml-tree.html#XMLFREEPROPLIST"
>xmlFreePropList</A
>                 (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLFREEPROP"
>xmlFreeProp</A
>                     (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLCOPYPROP"
>xmlCopyProp</A
>                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> target,
                                             <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLCOPYPROPLIST"
>xmlCopyPropList</A
>                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> target,
                                             <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   <A
HREF="libxml-tree.html#XMLCOPYDTD"
>xmlCopyDtd</A
>                      (<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
> dtd);
<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>   <A
HREF="libxml-tree.html#XMLCOPYDOC"
>xmlCopyDoc</A
>                      (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int recursive);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCNODE"
>xmlNewDocNode</A
>                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCNODEEATNAME"
>xmlNewDocNodeEatName</A
>            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCRAWNODE"
>xmlNewDocRawNode</A
>                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWNODE"
>xmlNewNode</A
>                      (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWNODEEATNAME"
>xmlNewNodeEatName</A
>               (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWCHILD"
>xmlNewChild</A
>                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWTEXTCHILD"
>xmlNewTextChild</A
>                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCTEXT"
>xmlNewDocText</A
>                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWTEXT"
>xmlNewText</A
>                      (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWPI"
>xmlNewPI</A
>                        (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCTEXTLEN"
>xmlNewDocTextLen</A
>                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWTEXTLEN"
>xmlNewTextLen</A
>                   (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCCOMMENT"
>xmlNewDocComment</A
>                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWCOMMENT"
>xmlNewComment</A
>                   (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWCDATABLOCK"
>xmlNewCDataBlock</A
>                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWCHARREF"
>xmlNewCharRef</A
>                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWREFERENCE"
>xmlNewReference</A
>                 (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLCOPYNODE"
>xmlCopyNode</A
>                     (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             int recursive);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLDOCCOPYNODE"
>xmlDocCopyNode</A
>                  (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int recursive);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLCOPYNODELIST"
>xmlCopyNodeList</A
>                 (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLNEWDOCFRAGMENT"
>xmlNewDocFragment</A
>               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
<GTKDOCLINK
HREF="LONG"
>long</GTKDOCLINK
>        <A
HREF="libxml-tree.html#XMLGETLINENO"
>xmlGetLineNo</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLGETNODEPATH"
>xmlGetNodePath</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLDOCGETROOTELEMENT"
>xmlDocGetRootElement</A
>            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLGETLASTCHILD"
>xmlGetLastChild</A
>                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent);
int         <A
HREF="libxml-tree.html#XMLNODEISTEXT"
>xmlNodeIsText</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
int         <A
HREF="libxml-tree.html#XMLISBLANKNODE"
>xmlIsBlankNode</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLDOCSETROOTELEMENT"
>xmlDocSetRootElement</A
>            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> root);
void        <A
HREF="libxml-tree.html#XMLNODESETNAME"
>xmlNodeSetName</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLADDCHILD"
>xmlAddChild</A
>                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLADDCHILDLIST"
>xmlAddChildList</A
>                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLREPLACENODE"
>xmlReplaceNode</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> old,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLADDSIBLING"
>xmlAddSibling</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLADDPREVSIBLING"
>xmlAddPrevSibling</A
>               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLADDNEXTSIBLING"
>xmlAddNextSibling</A
>               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);
void        <A
HREF="libxml-tree.html#XMLUNLINKNODE"
>xmlUnlinkNode</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLTEXTMERGE"
>xmlTextMerge</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> first,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> second);
void        <A
HREF="libxml-tree.html#XMLTEXTCONCAT"
>xmlTextConcat</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
void        <A
HREF="libxml-tree.html#XMLFREENODELIST"
>xmlFreeNodeList</A
>                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLFREENODE"
>xmlFreeNode</A
>                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLSETTREEDOC"
>xmlSetTreeDoc</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> tree,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
void        <A
HREF="libxml-tree.html#XMLSETLISTDOC"
>xmlSetListDoc</A
>                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLSEARCHNS"
>xmlSearchNs</A
>                     (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLSEARCHNSBYHREF"
>xmlSearchNsByHref</A
>               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>*   <A
HREF="libxml-tree.html#XMLGETNSLIST"
>xmlGetNsList</A
>                    (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);
void        <A
HREF="libxml-tree.html#XMLSETNS"
>xmlSetNs</A
>                        (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLCOPYNAMESPACE"
>xmlCopyNamespace</A
>                (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    <A
HREF="libxml-tree.html#XMLCOPYNAMESPACELIST"
>xmlCopyNamespaceList</A
>            (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLSETPROP"
>xmlSetProp</A
>                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLGETPROP"
>xmlGetProp</A
>                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLHASPROP"
>xmlHasProp</A
>                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLHASNSPROP"
>xmlHasNsProp</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);
<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  <A
HREF="libxml-tree.html#XMLSETNSPROP"
>xmlSetNsProp</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLGETNSPROP"
>xmlGetNsProp</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLSTRINGGETNODELIST"
>xmlStringGetNodeList</A
>            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);
<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  <A
HREF="libxml-tree.html#XMLSTRINGLENGETNODELIST"
>xmlStringLenGetNodeList</A
>         (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value,
                                             int len);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLNODELISTGETSTRING"
>xmlNodeListGetString</A
>            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             int inLine);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLNODELISTGETRAWSTRING"
>xmlNodeListGetRawString</A
>         (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             int inLine);
void        <A
HREF="libxml-tree.html#XMLNODESETCONTENT"
>xmlNodeSetContent</A
>               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
void        <A
HREF="libxml-tree.html#XMLNODESETCONTENTLEN"
>xmlNodeSetContentLen</A
>            (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
void        <A
HREF="libxml-tree.html#XMLNODEADDCONTENT"
>xmlNodeAddContent</A
>               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);
void        <A
HREF="libxml-tree.html#XMLNODEADDCONTENTLEN"
>xmlNodeAddContentLen</A
>            (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLNODEGETCONTENT"
>xmlNodeGetContent</A
>               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLNODEGETLANG"
>xmlNodeGetLang</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLNODESETLANG"
>xmlNodeSetLang</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *lang);
int         <A
HREF="libxml-tree.html#XMLNODEGETSPACEPRESERVE"
>xmlNodeGetSpacePreserve</A
>         (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLNODESETSPACEPRESERVE"
>xmlNodeSetSpacePreserve</A
>         (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int val);
<A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    <A
HREF="libxml-tree.html#XMLNODEGETBASE"
>xmlNodeGetBase</A
>                  (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLNODESETBASE"
>xmlNodeSetBase</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *uri);
int         <A
HREF="libxml-tree.html#XMLREMOVEPROP"
>xmlRemoveProp</A
>                   (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);
int         <A
HREF="libxml-tree.html#XMLUNSETPROP"
>xmlUnsetProp</A
>                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
int         <A
HREF="libxml-tree.html#XMLUNSETNSPROP"
>xmlUnsetNsProp</A
>                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);
void        <A
HREF="libxml-tree.html#XMLBUFFERWRITEXMLCHAR"
>xmlBufferWriteXmlCHAR</A
>           (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);
void        <A
HREF="libxml-tree.html#XMLBUFFERWRITECHAR"
>xmlBufferWriteCHAR</A
>              (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);
void        <A
HREF="libxml-tree.html#XMLBUFFERWRITECHAR"
>xmlBufferWriteChar</A
>              (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const char *string);
void        <A
HREF="libxml-tree.html#XMLBUFFERWRITEQUOTEDSTRING"
>xmlBufferWriteQuotedString</A
>      (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);
int         <A
HREF="libxml-tree.html#XMLRECONCILIATENS"
>xmlReconciliateNs</A
>               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> tree);
void        <A
HREF="libxml-tree.html#XMLDOCDUMPFORMATMEMORY"
>xmlDocDumpFormatMemory</A
>          (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **mem,
                                             int *size,
                                             int format);
void        <A
HREF="libxml-tree.html#XMLDOCDUMPMEMORY"
>xmlDocDumpMemory</A
>                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **mem,
                                             int *size);
void        <A
HREF="libxml-tree.html#XMLDOCDUMPMEMORYENC"
>xmlDocDumpMemoryEnc</A
>             (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> out_doc,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **doc_txt_ptr,
                                             int *doc_txt_len,
                                             const char *txt_encoding);
void        <A
HREF="libxml-tree.html#XMLDOCDUMPFORMATMEMORYENC"
>xmlDocDumpFormatMemoryEnc</A
>       (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> out_doc,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **doc_txt_ptr,
                                             int *doc_txt_len,
                                             const char *txt_encoding,
                                             int format);
int         <A
HREF="libxml-tree.html#XMLDOCFORMATDUMP"
>xmlDocFormatDump</A
>                (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             int format);
int         <A
HREF="libxml-tree.html#XMLDOCDUMP"
>xmlDocDump</A
>                      (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);
void        <A
HREF="libxml-tree.html#XMLELEMDUMP"
>xmlElemDump</A
>                     (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);
int         <A
HREF="libxml-tree.html#XMLSAVEFILE"
>xmlSaveFile</A
>                     (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);
int         <A
HREF="libxml-tree.html#XMLSAVEFORMATFILE"
>xmlSaveFormatFile</A
>               (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             int format);
void        <A
HREF="libxml-tree.html#XMLNODEDUMP"
>xmlNodeDump</A
>                     (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int level,
                                             int format);
int         <A
HREF="libxml-tree.html#XMLSAVEFILETO"
>xmlSaveFileTo</A
>                   (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding);
int         <A
HREF="libxml-tree.html#XMLSAVEFORMATFILETO"
>xmlSaveFormatFileTo</A
>             (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding,
                                             int format);
void        <A
HREF="libxml-tree.html#XMLNODEDUMPOUTPUT"
>xmlNodeDumpOutput</A
>               (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int level,
                                             int format,
                                             const char *encoding);
int         <A
HREF="libxml-tree.html#XMLSAVEFORMATFILEENC"
>xmlSaveFormatFileEnc</A
>            (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding,
                                             int format);
int         <A
HREF="libxml-tree.html#XMLSAVEFILEENC"
>xmlSaveFileEnc</A
>                  (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding);
int         <A
HREF="libxml-tree.html#XMLGETDOCCOMPRESSMODE"
>xmlGetDocCompressMode</A
>           (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);
void        <A
HREF="libxml-tree.html#XMLSETDOCCOMPRESSMODE"
>xmlSetDocCompressMode</A
>           (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int mode);
int         <A
HREF="libxml-tree.html#XMLGETCOMPRESSMODE"
>xmlGetCompressMode</A
>              (void);
void        <A
HREF="libxml-tree.html#XMLSETCOMPRESSMODE"
>xmlSetCompressMode</A
>              (int mode);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN4393"
></A
><H2
>Description</H2
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN4396"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN4398"
></A
><H3
><A
NAME="XMLPARSERINPUTBUFFER"
></A
>struct xmlParserInputBuffer</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlParserInputBuffer {
    void*                  context;
    xmlInputReadCallback   readcallback;
    xmlInputCloseCallback  closecallback;
    
    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
    
    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 */
    xmlBufferPtr raw;       /* if encoder != NULL buffer for raw input */
};</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4403"
></A
><H3
><A
NAME="XMLPARSERINPUTBUFFERPTR"
></A
>xmlParserInputBufferPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlParserInputBuffer *xmlParserInputBufferPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4408"
></A
><H3
><A
NAME="XMLOUTPUTBUFFER"
></A
>struct xmlOutputBuffer</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlOutputBuffer {
    void*                   context;
    xmlOutputWriteCallback  writecallback;
    xmlOutputCloseCallback  closecallback;
    
    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
    
    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 or ISOLatin */
    xmlBufferPtr conv;      /* if encoder != NULL buffer for output */
    int written;            /* total number of byte written */
};</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4413"
></A
><H3
><A
NAME="XMLOUTPUTBUFFERPTR"
></A
>xmlOutputBufferPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlOutputBuffer *xmlOutputBufferPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4418"
></A
><H3
><A
NAME="XMLPARSERINPUT"
></A
>struct xmlParserInput</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlParserInput {
    /* Input buffer */
    xmlParserInputBufferPtr buf;      /* UTF-8 encoded buffer */

    const char *filename;             /* The file analyzed, if any */
    const char *directory;            /* the directory/base of the file */
    const xmlChar *base;              /* Base of the array to parse */
    const xmlChar *cur;               /* Current char being parsed */
    const xmlChar *end;               /* end of the array to parse */
    int length;                       /* length if known */
    int line;                         /* Current line */
    int col;                          /* Current column */
    int consumed;                     /* How many xmlChars already consumed */
    xmlParserInputDeallocate free;    /* function to deallocate the base */
    const xmlChar *encoding;          /* the encoding string for entity */
    const xmlChar *version;           /* the version string for entity */
    int standalone;                   /* Was that entity marked standalone */
};</PRE
></TD
></TR
></TABLE
><P
>An xmlParserInput is an input flow for the XML processor.
Each entity parsed is associated an xmlParserInput (except the
few predefined ones). This is the case both for internal entities
- in which case the flow is already completely in memory - or
external entities - in which case we use the buf structure for
progressive reading and I18N conversions to the internal UTF-8 format.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4424"
></A
><H3
><A
NAME="XMLPARSERINPUTPTR"
></A
>xmlParserInputPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlParserInput *xmlParserInputPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4429"
></A
><H3
><A
NAME="XMLPARSERCTXT"
></A
>struct xmlParserCtxt</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlParserCtxt {
    struct _xmlSAXHandler *sax;       /* The SAX handler */
    void            *userData;        /* For SAX interface only, used by DOM build */
    xmlDocPtr           myDoc;        /* the document being built */
    int            wellFormed;        /* is the document well formed */
    int       replaceEntities;        /* shall we replace entities ? */
    const xmlChar    *version;        /* the XML version string */
    const xmlChar   *encoding;        /* the declared encoding, if any */
    int            standalone;        /* standalone document */
    int                  html;        /* an HTML(1)/Docbook(2) document */

    /* Input stream stack */
    xmlParserInputPtr  input;         /* Current input stream */
    int                inputNr;       /* Number of current input streams */
    int                inputMax;      /* Max number of input streams */
    xmlParserInputPtr *inputTab;      /* stack of inputs */

    /* Node analysis stack only used for DOM building */
    xmlNodePtr         node;          /* Current parsed Node */
    int                nodeNr;        /* Depth of the parsing stack */
    int                nodeMax;       /* Max depth of the parsing stack */
    xmlNodePtr        *nodeTab;       /* array of nodes */

    int record_info;                  /* Whether node info should be kept */
    xmlParserNodeInfoSeq node_seq;    /* info about each node parsed */

    int errNo;                        /* error code */

    int     hasExternalSubset;        /* reference and external subset */
    int             hasPErefs;        /* the internal subset has PE refs */
    int              external;        /* are we parsing an external entity */

    int                 valid;        /* is the document valid */
    int              validate;        /* shall we try to validate ? */
    xmlValidCtxt        vctxt;        /* The validity context */

    xmlParserInputState instate;      /* current type of input */
    int                 token;        /* next char look-ahead */    

    char           *directory;        /* the data directory */

    /* Node name stack */
    xmlChar           *name;          /* Current parsed Node */
    int                nameNr;        /* Depth of the parsing stack */
    int                nameMax;       /* Max depth of the parsing stack */
    xmlChar *         *nameTab;       /* array of nodes */

    long               nbChars;       /* number of xmlChar processed */
    long            checkIndex;       /* used by progressive parsing lookup */
    int             keepBlanks;       /* ugly but ... */
    int             disableSAX;       /* SAX callbacks are disabled */
    int               inSubset;       /* Parsing is in int 1/ext 2 subset */
    xmlChar *          intSubName;    /* name of subset */
    xmlChar *          extSubURI;     /* URI of external subset */
    xmlChar *          extSubSystem;  /* SYSTEM ID of external subset */

    /* xml:space values */
    int *              space;         /* Should the parser preserve spaces */
    int                spaceNr;       /* Depth of the parsing stack */
    int                spaceMax;      /* Max depth of the parsing stack */
    int *              spaceTab;      /* array of space infos */

    int                depth;         /* to prevent entity substitution loops */
    xmlParserInputPtr  entity;        /* used to check entities boundaries */
    int                charset;       /* encoding of the in-memory content
				         actually an xmlCharEncoding */
    int                nodelen;       /* Those two fields are there to */
    int                nodemem;       /* Speed up large node parsing */
    int                pedantic;      /* signal pedantic warnings */
    void              *_private;      /* For user data, libxml won't touch it */

    int                loadsubset;    /* should the external subset be loaded */
    int                linenumbers;   /* set line number in element content */
    void              *catalogs;       /* document's own catalog */
};</PRE
></TD
></TR
></TABLE
><P
>The parser context.
NOTE This doesn't completely define the parser state, the (current ?)
design of the parser uses recursive function calls since this allow
and easy mapping from the production rules of the specification
to the actual code. The drawback is that the actual function call
also reflect the parser state. However most of the parsing routines
takes as the only argument the parser context pointer, so migrating
to a state based parser for progressive parsing shouldn't be too hard.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4435"
></A
><H3
><A
NAME="XMLPARSERCTXTPTR"
></A
>xmlParserCtxtPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlParserCtxt *xmlParserCtxtPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4440"
></A
><H3
><A
NAME="XMLSAXLOCATOR"
></A
>struct xmlSAXLocator</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlSAXLocator {
    const xmlChar *(*getPublicId)(void *ctx);
    const xmlChar *(*getSystemId)(void *ctx);
    int (*getLineNumber)(void *ctx);
    int (*getColumnNumber)(void *ctx);
};</PRE
></TD
></TR
></TABLE
><P
>A SAX Locator.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4446"
></A
><H3
><A
NAME="XMLSAXLOCATORPTR"
></A
>xmlSAXLocatorPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlSAXLocator *xmlSAXLocatorPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4451"
></A
><H3
><A
NAME="XMLSAXHANDLER"
></A
>struct xmlSAXHandler</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlSAXHandler {
    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError;
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    int initialized;
};</PRE
></TD
></TR
></TABLE
><P
>A SAX handler is bunch of callbacks called by the parser when processing
of the input generate data or structure informations.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4457"
></A
><H3
><A
NAME="XMLSAXHANDLERPTR"
></A
>xmlSAXHandlerPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlSAXHandler *xmlSAXHandlerPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4462"
></A
><H3
><A
NAME="XMLENTITY"
></A
>struct xmlEntity</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlEntity {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ENTITY_DECL, must be second ! */
    const xmlChar          *name;	/* Entity name */
    struct _xmlNode    *children;	/* First child link */
    struct _xmlNode        *last;	/* Last child link */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlChar                *orig;	/* content without ref substitution */
    xmlChar             *content;	/* content or ndata if unparsed */
    int                   length;	/* the content length */
    xmlEntityType          etype;	/* The entity type */
    const xmlChar    *ExternalID;	/* External identifier for PUBLIC */
    const xmlChar      *SystemID;	/* URI for a SYSTEM or PUBLIC Entity */

    struct _xmlEntity     *nexte;	/* unused */
    const xmlChar           *URI;	/* the full URI as computed */
};</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4467"
></A
><H3
><A
NAME="XMLENTITYPTR"
></A
>xmlEntityPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlEntity *xmlEntityPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4472"
></A
><H3
><A
NAME="BASE-BUFFER-SIZE-CAPS"
></A
>BASE_BUFFER_SIZE</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define BASE_BUFFER_SIZE 4000</PRE
></TD
></TR
></TABLE
><P
>default buffer size 4000.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4478"
></A
><H3
><A
NAME="XML-XML-NAMESPACE-CAPS"
></A
>XML_XML_NAMESPACE</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define     XML_XML_NAMESPACE</PRE
></TD
></TR
></TABLE
><P
>This is the namespace for the special xml: prefix predefined in the
XML Namespace specification.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4484"
></A
><H3
><A
NAME="XMLELEMENTTYPE"
></A
>enum xmlElementType</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ELEMENT_NODE=		1,
    XML_ATTRIBUTE_NODE=		2,
    XML_TEXT_NODE=		3,
    XML_CDATA_SECTION_NODE=	4,
    XML_ENTITY_REF_NODE=	5,
    XML_ENTITY_NODE=		6,
    XML_PI_NODE=		7,
    XML_COMMENT_NODE=		8,
    XML_DOCUMENT_NODE=		9,
    XML_DOCUMENT_TYPE_NODE=	10,
    XML_DOCUMENT_FRAG_NODE=	11,
    XML_NOTATION_NODE=		12,
    XML_HTML_DOCUMENT_NODE=	13,
    XML_DTD_NODE=		14,
    XML_ELEMENT_DECL=		15,
    XML_ATTRIBUTE_DECL=		16,
    XML_ENTITY_DECL=		17,
    XML_NAMESPACE_DECL=		18,
    XML_XINCLUDE_START=		19,
    XML_XINCLUDE_END=		20
#ifdef LIBXML_DOCB_ENABLED
   ,XML_DOCB_DOCUMENT_NODE=	21
#endif
} xmlElementType;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4489"
></A
><H3
><A
NAME="XMLCHAR"
></A
>xmlChar</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef unsigned char xmlChar;</PRE
></TD
></TR
></TABLE
><P
>This is a basic byte in an UTF-8 encoded string.
It's unsigned allowing to pinpoint case where char * are assigned
to xmlChar * (possibly making serialization back impossible).</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4495"
></A
><H3
><A
NAME="BAD-CAST-CAPS"
></A
>BAD_CAST</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define BAD_CAST (xmlChar *)</PRE
></TD
></TR
></TABLE
><P
>Macro to cast a string to an xmlChar * when one know its safe.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4501"
></A
><H3
><A
NAME="XMLNOTATION"
></A
>struct xmlNotation</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlNotation {
    const xmlChar               *name;	        /* Notation name */
    const xmlChar               *PublicID;	/* Public identifier, if any */
    const xmlChar               *SystemID;	/* System identifier, if any */
};</PRE
></TD
></TR
></TABLE
><P
>A DTD Notation definition.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4507"
></A
><H3
><A
NAME="XMLNOTATIONPTR"
></A
>xmlNotationPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlNotation *xmlNotationPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4512"
></A
><H3
><A
NAME="XMLATTRIBUTETYPE"
></A
>enum xmlAttributeType</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ATTRIBUTE_CDATA = 1,
    XML_ATTRIBUTE_ID,
    XML_ATTRIBUTE_IDREF	,
    XML_ATTRIBUTE_IDREFS,
    XML_ATTRIBUTE_ENTITY,
    XML_ATTRIBUTE_ENTITIES,
    XML_ATTRIBUTE_NMTOKEN,
    XML_ATTRIBUTE_NMTOKENS,
    XML_ATTRIBUTE_ENUMERATION,
    XML_ATTRIBUTE_NOTATION
} xmlAttributeType;</PRE
></TD
></TR
></TABLE
><P
>A DTD Attribute type definition.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4518"
></A
><H3
><A
NAME="XMLATTRIBUTEDEFAULT"
></A
>enum xmlAttributeDefault</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ATTRIBUTE_NONE = 1,
    XML_ATTRIBUTE_REQUIRED,
    XML_ATTRIBUTE_IMPLIED,
    XML_ATTRIBUTE_FIXED
} xmlAttributeDefault;</PRE
></TD
></TR
></TABLE
><P
>A DTD Attribute default definition.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4524"
></A
><H3
><A
NAME="XMLENUMERATION"
></A
>struct xmlEnumeration</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlEnumeration {
    struct _xmlEnumeration    *next;	/* next one */
    const xmlChar            *name;	/* Enumeration name */
};</PRE
></TD
></TR
></TABLE
><P
>List structure used when there is an enumeration in DTDs.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4530"
></A
><H3
><A
NAME="XMLENUMERATIONPTR"
></A
>xmlEnumerationPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlEnumeration *xmlEnumerationPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4535"
></A
><H3
><A
NAME="XMLATTRIBUTE"
></A
>struct xmlAttribute</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlAttribute {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */
    const xmlChar          *name;	/* Attribute name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    struct _xmlAttribute  *nexth;	/* next in hash table */
    xmlAttributeType       atype;	/* The attribute type */
    xmlAttributeDefault      def;	/* the default */
    const xmlChar  *defaultValue;	/* or the default value */
    xmlEnumerationPtr       tree;       /* or the enumeration tree if any */
    const xmlChar        *prefix;	/* the namespace prefix if any */
    const xmlChar          *elem;	/* Element holding the attribute */
};</PRE
></TD
></TR
></TABLE
><P
>An Attribute declaration in a DTD.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4541"
></A
><H3
><A
NAME="XMLATTRIBUTEPTR"
></A
>xmlAttributePtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlAttribute *xmlAttributePtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4546"
></A
><H3
><A
NAME="XMLELEMENTCONTENTTYPE"
></A
>enum xmlElementContentType</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ELEMENT_CONTENT_PCDATA = 1,
    XML_ELEMENT_CONTENT_ELEMENT,
    XML_ELEMENT_CONTENT_SEQ,
    XML_ELEMENT_CONTENT_OR
} xmlElementContentType;</PRE
></TD
></TR
></TABLE
><P
>Possible definitions of element content types.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4552"
></A
><H3
><A
NAME="XMLELEMENTCONTENTOCCUR"
></A
>enum xmlElementContentOccur</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ELEMENT_CONTENT_ONCE = 1,
    XML_ELEMENT_CONTENT_OPT,
    XML_ELEMENT_CONTENT_MULT,
    XML_ELEMENT_CONTENT_PLUS
} xmlElementContentOccur;</PRE
></TD
></TR
></TABLE
><P
>Possible definitions of element content occurrences.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4558"
></A
><H3
><A
NAME="XMLELEMENTCONTENT"
></A
>struct xmlElementContent</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlElementContent {
    xmlElementContentType     type;	/* PCDATA, ELEMENT, SEQ or OR */
    xmlElementContentOccur    ocur;	/* ONCE, OPT, MULT or PLUS */
    const xmlChar             *name;	/* Element name */
    struct _xmlElementContent *c1;	/* first child */
    struct _xmlElementContent *c2;	/* second child */
    struct _xmlElementContent *parent;	/* parent */
    const xmlChar             *prefix;	/* Element name */
};</PRE
></TD
></TR
></TABLE
><P
>An XML Element content as stored after parsing an element definition
in a DTD.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4564"
></A
><H3
><A
NAME="XMLELEMENTCONTENTPTR"
></A
>xmlElementContentPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlElementContent *xmlElementContentPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4569"
></A
><H3
><A
NAME="XMLELEMENTTYPEVAL"
></A
>enum xmlElementTypeVal</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_ELEMENT_TYPE_UNDEFINED = 0,
    XML_ELEMENT_TYPE_EMPTY = 1,
    XML_ELEMENT_TYPE_ANY,
    XML_ELEMENT_TYPE_MIXED,
    XML_ELEMENT_TYPE_ELEMENT
} xmlElementTypeVal;</PRE
></TD
></TR
></TABLE
><P
>The different possibilities for an element content type.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4575"
></A
><H3
><A
NAME="XMLELEMENT"
></A
>struct xmlElement</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlElement {
    void           *_private;	        /* application data */
    xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */
    const xmlChar          *name;	/* Element name */
    struct _xmlNode    *children;	/* NULL */
    struct _xmlNode        *last;	/* NULL */
    struct _xmlDtd       *parent;	/* -&gt; DTD */
    struct _xmlNode        *next;	/* next sibling link  */
    struct _xmlNode        *prev;	/* previous sibling link  */
    struct _xmlDoc          *doc;       /* the containing document */

    xmlElementTypeVal      etype;	/* The type */
    xmlElementContentPtr content;	/* the allowed element content */
    xmlAttributePtr   attributes;	/* List of the declared attributes */
    const xmlChar        *prefix;	/* the namespace prefix if any */
#ifdef LIBXML_REGEXP_ENABLED
    xmlRegexpPtr       contModel;	/* the validating regexp */
#else
    void	      *contModel;
#endif
};</PRE
></TD
></TR
></TABLE
><P
>An XML Element declaration from a DTD.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4581"
></A
><H3
><A
NAME="XMLELEMENTPTR"
></A
>xmlElementPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlElement *xmlElementPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4586"
></A
><H3
><A
NAME="XML-LOCAL-NAMESPACE-CAPS"
></A
>XML_LOCAL_NAMESPACE</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL</PRE
></TD
></TR
></TABLE
><P
>A namespace declaration node.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4592"
></A
><H3
><A
NAME="XMLNSTYPE"
></A
>xmlNsType</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlElementType xmlNsType;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4597"
></A
><H3
><A
NAME="XMLNS"
></A
>struct xmlNs</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlNs {
    struct _xmlNs  *next;	/* next Ns link for this node  */
    xmlNsType      type;	/* global or local */
    const xmlChar *href;	/* URL for the namespace */
    const xmlChar *prefix;	/* prefix for the namespace */
    void           *_private;   /* application data */
};</PRE
></TD
></TR
></TABLE
><P
>An XML namespace.
Note that prefix == NULL is valid, it defines the default namespace
within the subtree (until overridden).</P
><P
>xmlNsType is unified with xmlElementType.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4604"
></A
><H3
><A
NAME="XMLNSPTR"
></A
>xmlNsPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlNs *xmlNsPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4609"
></A
><H3
><A
NAME="XMLDTD"
></A
>struct xmlDtd</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlDtd {
    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DTD_NODE, must be second ! */
    const xmlChar *name;	/* Name of the DTD */
    struct _xmlNode *children;	/* the value of the property link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlDoc  *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    void          *notations;   /* Hash table for notations if any */
    void          *elements;    /* Hash table for elements if any */
    void          *attributes;  /* Hash table for attributes if any */
    void          *entities;    /* Hash table for entities if any */
    const xmlChar *ExternalID;	/* External identifier for PUBLIC DTD */
    const xmlChar *SystemID;	/* URI for a SYSTEM or PUBLIC DTD */
    void          *pentities;   /* Hash table for param entities if any */
};</PRE
></TD
></TR
></TABLE
><P
>An XML DTD, as defined by &lt;!DOCTYPE ... There is actually one for
the internal subset and for the external subset.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4615"
></A
><H3
><A
NAME="XMLDTDPTR"
></A
>xmlDtdPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlDtd *xmlDtdPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4620"
></A
><H3
><A
NAME="XMLATTR"
></A
>struct xmlAttr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlAttr {
    void           *_private;	/* application data */
    xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
    const xmlChar   *name;      /* the name of the property */
    struct _xmlNode *children;	/* the value of the property */
    struct _xmlNode *last;	/* NULL */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlAttr *next;	/* next sibling link  */
    struct _xmlAttr *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlAttributeType atype;     /* the attribute type if validating */
};</PRE
></TD
></TR
></TABLE
><P
>An attribute on an XML node.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4626"
></A
><H3
><A
NAME="XMLATTRPTR"
></A
>xmlAttrPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlAttr *xmlAttrPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4631"
></A
><H3
><A
NAME="XMLID"
></A
>struct xmlID</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlID {
    struct _xmlID    *next;	/* next ID */
    const xmlChar    *value;	/* The ID name */
    xmlAttrPtr        attr;	/* The attribute holding it */
};</PRE
></TD
></TR
></TABLE
><P
>An XML ID instance.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4637"
></A
><H3
><A
NAME="XMLIDPTR"
></A
>xmlIDPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlID *xmlIDPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4642"
></A
><H3
><A
NAME="XMLREF"
></A
>struct xmlRef</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlRef {
    struct _xmlRef    *next;	/* next Ref */
    const xmlChar     *value;	/* The Ref name */
    xmlAttrPtr        attr;	/* The attribute holding it */
};</PRE
></TD
></TR
></TABLE
><P
>An XML IDREF instance.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4648"
></A
><H3
><A
NAME="XMLREFPTR"
></A
>xmlRefPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlRef *xmlRefPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4653"
></A
><H3
><A
NAME="XMLBUFFERALLOCATIONSCHEME"
></A
>enum xmlBufferAllocationScheme</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum {
    XML_BUFFER_ALLOC_DOUBLEIT,
    XML_BUFFER_ALLOC_EXACT
} xmlBufferAllocationScheme;</PRE
></TD
></TR
></TABLE
><P
>A buffer allocation scheme can be defined to either match exactly the
need or double it's allocated size each time it is found too small.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4659"
></A
><H3
><A
NAME="XMLBUFFER"
></A
>struct xmlBuffer</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlBuffer {
    xmlChar *content;		/* The buffer content UTF8 */
    unsigned int use;		/* The buffer size used */
    unsigned int size;		/* The buffer size */
    xmlBufferAllocationScheme alloc; /* The realloc method */
};</PRE
></TD
></TR
></TABLE
><P
>A buffer structure.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4665"
></A
><H3
><A
NAME="XMLBUFFERPTR"
></A
>xmlBufferPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlBuffer *xmlBufferPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4670"
></A
><H3
><A
NAME="XMLNODE"
></A
>struct xmlNode</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlNode {
    void           *_private;	/* application data */
    xmlElementType   type;	/* type number, must be second ! */
    const xmlChar   *name;      /* the name of the node, or the entity */
    struct _xmlNode *children;	/* parent-&gt;childs link */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* the containing document */

    /* End of common part */
    xmlNs           *ns;        /* pointer to the associated namespace */
    xmlChar         *content;   /* the content */
    struct _xmlAttr *properties;/* properties list */
    xmlNs           *nsDef;     /* namespace definitions on this node */
};</PRE
></TD
></TR
></TABLE
><P
>A node in an XML tree.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4676"
></A
><H3
><A
NAME="XMLNODEPTR"
></A
>xmlNodePtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlNode *xmlNodePtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4681"
></A
><H3
><A
NAME="XML-GET-CONTENT-CAPS"
></A
>XML_GET_CONTENT()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define     XML_GET_CONTENT(n)</PRE
></TD
></TR
></TABLE
><P
>Macro to extract the content pointer of a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4687"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4696"
></A
><H3
><A
NAME="XML-GET-LINE-CAPS"
></A
>XML_GET_LINE()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define     XML_GET_LINE(n)</PRE
></TD
></TR
></TABLE
><P
>Macro to extract the line number of an element node. 
This will work only if line numbering is activated by
calling xmlLineNumbersDefault(1) before parsing.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4702"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4711"
></A
><H3
><A
NAME="XMLDOC"
></A
>struct xmlDoc</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct xmlDoc {
    void           *_private;	/* application data */
    xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */
    char           *name;	/* name/filename/URI of the document */
    struct _xmlNode *children;	/* the document tree */
    struct _xmlNode *last;	/* last child link */
    struct _xmlNode *parent;	/* child-&gt;parent link */
    struct _xmlNode *next;	/* next sibling link  */
    struct _xmlNode *prev;	/* previous sibling link  */
    struct _xmlDoc  *doc;	/* autoreference to itself */

    /* End of common part */
    int             compression;/* level of zlib compression */
    int             standalone; /* standalone document (no external refs) */
    struct _xmlDtd  *intSubset;	/* the document internal subset */
    struct _xmlDtd  *extSubset;	/* the document external subset */
    struct _xmlNs   *oldNs;	/* Global namespace, the old way */
    const xmlChar  *version;	/* the XML version string */
    const xmlChar  *encoding;   /* external initial encoding, if any */
    void           *ids;        /* Hash table for ID attributes if any */
    void           *refs;       /* Hash table for IDREFs attributes if any */
    const xmlChar  *URL;	/* The URI for that document */
    int             charset;    /* encoding of the in-memory content
				   actually an xmlCharEncoding */
};</PRE
></TD
></TR
></TABLE
><P
>An XML document.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4717"
></A
><H3
><A
NAME="XMLDOCPTR"
></A
>xmlDocPtr</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef xmlDoc *xmlDocPtr;</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4722"
></A
><H3
><A
NAME="XMLCHILDRENNODE"
></A
>xmlChildrenNode</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define xmlChildrenNode children</PRE
></TD
></TR
></TABLE
><P
>Macro for compatibility naming layer with libxml1.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4728"
></A
><H3
><A
NAME="XMLROOTNODE"
></A
>xmlRootNode</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define xmlRootNode children</PRE
></TD
></TR
></TABLE
><P
>Macro for compatibility naming layer with libxml1.</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4734"
></A
><H3
><A
NAME="XMLSETBUFFERALLOCATIONSCHEME"
></A
>xmlSetBufferAllocationScheme ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetBufferAllocationScheme    (<A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> scheme);</PRE
></TD
></TR
></TABLE
><P
>Set the buffer allocation method.  Types are
XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, 
improves performance</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4741"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>scheme</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  allocation method to use</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4750"
></A
><H3
><A
NAME="XMLGETBUFFERALLOCATIONSCHEME"
></A
>xmlGetBufferAllocationScheme ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> xmlGetBufferAllocationScheme
                                            (void);</PRE
></TD
></TR
></TABLE
><P
>Types are
XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down
XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, 
improves performance</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4757"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the current allocation scheme</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4766"
></A
><H3
><A
NAME="XMLBUFFERCREATE"
></A
>xmlBufferCreate ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> xmlBufferCreate                (void);</PRE
></TD
></TR
></TABLE
><P
>routine to create an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4773"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new structure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4782"
></A
><H3
><A
NAME="XMLBUFFERCREATESIZE"
></A
>xmlBufferCreateSize ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> xmlBufferCreateSize            (<GTKDOCLINK
HREF="SIZE-T"
>size_t</GTKDOCLINK
> size);</PRE
></TD
></TR
></TABLE
><P
>routine to create an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4790"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> initial size of buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new structure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4803"
></A
><H3
><A
NAME="XMLBUFFERRESIZE"
></A
>xmlBufferResize ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlBufferResize                 (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int size);</PRE
></TD
></TR
></TABLE
><P
>Resize a buffer to accommodate minimum size of <TT
CLASS="PARAMETER"
><I
>size</I
></TT
>.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4811"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to resize</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the desired size</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 in case of problems, 1 otherwise</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4828"
></A
><H3
><A
NAME="XMLBUFFERFREE"
></A
>xmlBufferFree ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferFree                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);</PRE
></TD
></TR
></TABLE
><P
>Frees an XML buffer. It frees both the content and the structure which
encapsulate it.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4835"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to free</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4844"
></A
><H3
><A
NAME="XMLBUFFERDUMP"
></A
>xmlBufferDump ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlBufferDump                   (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *file,
                                             <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);</PRE
></TD
></TR
></TABLE
><P
>Dumps an XML buffer to  a FILE *.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4852"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>file</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the file output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to dump</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the number of <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> written</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4870"
></A
><H3
><A
NAME="XMLBUFFERADD"
></A
>xmlBufferAdd ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferAdd                    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Add a string range to an XML buffer. if len == -1, the length of
str is recomputed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4878"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to dump</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> string</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the number of <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4897"
></A
><H3
><A
NAME="XMLBUFFERADDHEAD"
></A
>xmlBufferAddHead ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferAddHead                (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Add a string range to the beginning of an XML buffer.
if len == -1, the length of <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> is recomputed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4906"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> string</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the number of <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4925"
></A
><H3
><A
NAME="XMLBUFFERCAT"
></A
>xmlBufferCat ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferCat                    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *str);</PRE
></TD
></TR
></TABLE
><P
>Append a zero terminated string to an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4933"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to dump</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> string</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4947"
></A
><H3
><A
NAME="XMLBUFFERCCAT"
></A
>xmlBufferCCat ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferCCat                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const char *str);</PRE
></TD
></TR
></TABLE
><P
>Append a zero terminated C string to an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4954"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to dump</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the C char string</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4967"
></A
><H3
><A
NAME="XMLBUFFERSHRINK"
></A
>xmlBufferShrink ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlBufferShrink                 (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int len);</PRE
></TD
></TR
></TABLE
><P
>Remove the beginning of an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4974"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to dump</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the number of xmlChar to remove</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the number of <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> removed, or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN4992"
></A
><H3
><A
NAME="XMLBUFFERGROW"
></A
>xmlBufferGrow ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlBufferGrow                   (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             unsigned int len);</PRE
></TD
></TR
></TABLE
><P
>Grow the available space of an XML buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN4999"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the minimum free size to allocate</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new available space or -1 in case of error</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5016"
></A
><H3
><A
NAME="XMLBUFFEREMPTY"
></A
>xmlBufferEmpty ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferEmpty                  (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);</PRE
></TD
></TR
></TABLE
><P
>empty a buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5023"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5032"
></A
><H3
><A
NAME="XMLBUFFERCONTENT"
></A
>xmlBufferContent ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>* xmlBufferContent             (const <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);</PRE
></TD
></TR
></TABLE
><P
>Function to extract the content of a buffer</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5040"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the internal content</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5053"
></A
><H3
><A
NAME="XMLBUFFERSETALLOCATIONSCHEME"
></A
>xmlBufferSetAllocationScheme ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferSetAllocationScheme    (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLBUFFERALLOCATIONSCHEME"
>xmlBufferAllocationScheme</A
> scheme);</PRE
></TD
></TR
></TABLE
><P
>Sets the allocation scheme for this buffer</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5061"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer to tune</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>scheme</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  allocation scheme to use</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5074"
></A
><H3
><A
NAME="XMLBUFFERLENGTH"
></A
>xmlBufferLength ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlBufferLength                 (const <A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf);</PRE
></TD
></TR
></TABLE
><P
>Function to get the length of a buffer</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5081"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the buffer </TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the length of data in the internal content</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5094"
></A
><H3
><A
NAME="XMLCREATEINTSUBSET"
></A
>xmlCreateIntSubset ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   xmlCreateIntSubset              (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *ExternalID,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *SystemID);</PRE
></TD
></TR
></TABLE
><P
>Create the internal subset of a document</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5105"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document pointer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the DTD name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ExternalID</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the external (PUBLIC) ID</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>SystemID</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the system ID</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new DTD structure</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5130"
></A
><H3
><A
NAME="XMLNEWDTD"
></A
>xmlNewDtd ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   xmlNewDtd                       (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *ExternalID,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *SystemID);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new DTD for the external subset. To create an
internal subset, use <A
HREF="libxml-tree.html#XMLCREATEINTSUBSET"
>xmlCreateIntSubset</A
>().</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5142"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document pointer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the DTD name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ExternalID</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the external ID</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>SystemID</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the system ID</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new DTD structure</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5167"
></A
><H3
><A
NAME="XMLGETINTSUBSET"
></A
>xmlGetIntSubset ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   xmlGetIntSubset                 (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>Get the internal subset of a document</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5175"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document pointer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the DTD structure or NULL if not found</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5188"
></A
><H3
><A
NAME="XMLFREEDTD"
></A
>xmlFreeDtd ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeDtd                      (<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free a DTD structure.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5195"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the DTD structure to free up</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5204"
></A
><H3
><A
NAME="XMLNEWGLOBALNS"
></A
>xmlNewGlobalNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlNewGlobalNs                  (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *prefix);</PRE
></TD
></TR
></TABLE
><P
>Creation of a Namespace, the old way using PI and without scoping
DEPRECATED !!!
It now create a namespace on the root element of the document if found.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5214"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document carrying the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>href</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the URI associated</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>prefix</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the prefix for the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>NULL this functionality had been removed</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5235"
></A
><H3
><A
NAME="XMLNEWNS"
></A
>xmlNewNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlNewNs                        (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *prefix);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new Namespace. This function will refuse to create
a namespace with a similar prefix than an existing one present on this
node.
We use href==NULL in the case of an element creation where the namespace
was not defined.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5245"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the element carrying the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>href</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the URI associated</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>prefix</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the prefix for the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a new namespace pointer or NULL</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5266"
></A
><H3
><A
NAME="XMLFREENS"
></A
>xmlFreeNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeNs                       (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free up the structures associated to a namespace</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5273"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace pointer</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5282"
></A
><H3
><A
NAME="XMLFREENSLIST"
></A
>xmlFreeNsList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeNsList                   (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free up all the structures associated to the chained namespaces.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5289"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first namespace pointer</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5298"
></A
><H3
><A
NAME="XMLNEWDOC"
></A
>xmlNewDoc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>   xmlNewDoc                       (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *version);</PRE
></TD
></TR
></TABLE
><P
>Creates a new XML document</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5306"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>version</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  xmlChar string giving the version of XML "1.0"</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a new document</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5319"
></A
><H3
><A
NAME="XMLFREEDOC"
></A
>xmlFreeDoc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeDoc                      (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free up all the structures used by a document, tree included.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5326"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  pointer to the document</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5335"
></A
><H3
><A
NAME="XMLNEWDOCPROP"
></A
>xmlNewDocProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlNewDocProp                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Create a new property carried by a document.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5345"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the attribute</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5366"
></A
><H3
><A
NAME="XMLNEWPROP"
></A
>xmlNewProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlNewProp                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Create a new property carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5376"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the holding node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the attribute</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5397"
></A
><H3
><A
NAME="XMLNEWNSPROP"
></A
>xmlNewNsProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlNewNsProp                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Create a new property tagged with a namespace and carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5408"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the holding node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the attribute</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5433"
></A
><H3
><A
NAME="XMLNEWNSPROPEATNAME"
></A
>xmlNewNsPropEatName ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlNewNsPropEatName             (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Create a new property tagged with a namespace and carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5444"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the holding node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the attribute</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5469"
></A
><H3
><A
NAME="XMLFREEPROPLIST"
></A
>xmlFreePropList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreePropList                 (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free a property and all its siblings, all the children are freed too.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5476"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first property in the list</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5485"
></A
><H3
><A
NAME="XMLFREEPROP"
></A
>xmlFreeProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeProp                     (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free one attribute, all the content is freed too</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5492"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  an attribute</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5501"
></A
><H3
><A
NAME="XMLCOPYPROP"
></A
>xmlCopyProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlCopyProp                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> target,
                                             <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the attribute.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5510"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>target</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the element where the attribute will be grafted</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5528"
></A
><H3
><A
NAME="XMLCOPYPROPLIST"
></A
>xmlCopyPropList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlCopyPropList                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> target,
                                             <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of an attribute list.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5537"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>target</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the element where the attributes will be grafted</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5555"
></A
><H3
><A
NAME="XMLCOPYDTD"
></A
>xmlCopyDtd ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>   xmlCopyDtd                      (<A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
> dtd);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the dtd.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5563"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>dtd</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the dtd</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLDTDPTR"
>xmlDtdPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5577"
></A
><H3
><A
NAME="XMLCOPYDOC"
></A
>xmlCopyDoc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>   xmlCopyDoc                      (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int recursive);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the document info. If recursive, the content tree will
be copied too as well as DTD, namespaces and entities.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5585"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>recursive</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  if 1 do a recursive copy.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5603"
></A
><H3
><A
NAME="XMLNEWDOCNODE"
></A
>xmlNewDocNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocNode                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node element within a document. <TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>content</I
></TT
>
are optional (NULL).
NOTE: <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> is supposed to be a piece of XML CDATA, so it allow entities
references, but XML special chars need to be escaped first by using
<A
HREF="libxml-entities.html#XMLENCODEENTITIESREENTRANT"
>xmlEncodeEntitiesReentrant</A
>(). Use <A
HREF="libxml-tree.html#XMLNEWDOCRAWNODE"
>xmlNewDocRawNode</A
>() if you don't
need entities support.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5619"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML text content if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5644"
></A
><H3
><A
NAME="XMLNEWDOCNODEEATNAME"
></A
>xmlNewDocNodeEatName ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocNodeEatName            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node element within a document. <TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>content</I
></TT
>
are optional (NULL).
NOTE: <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> is supposed to be a piece of XML CDATA, so it allow entities
references, but XML special chars need to be escaped first by using
<A
HREF="libxml-entities.html#XMLENCODEENTITIESREENTRANT"
>xmlEncodeEntitiesReentrant</A
>(). Use <A
HREF="libxml-tree.html#XMLNEWDOCRAWNODE"
>xmlNewDocRawNode</A
>() if you don't
need entities support.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5660"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML text content if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5685"
></A
><H3
><A
NAME="XMLNEWDOCRAWNODE"
></A
>xmlNewDocRawNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocRawNode                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node element within a document. <TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>content</I
></TT
>
are optional (NULL).</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5698"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5723"
></A
><H3
><A
NAME="XMLNEWNODE"
></A
>xmlNewNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewNode                      (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node element. <TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> is optional (NULL).</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5733"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5750"
></A
><H3
><A
NAME="XMLNEWNODEEATNAME"
></A
>xmlNewNodeEatName ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewNodeEatName               (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node element. <TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> is optional (NULL).</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5760"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5777"
></A
><H3
><A
NAME="XMLNEWCHILD"
></A
>xmlNewChild ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewChild                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new child element, added at the end of <TT
CLASS="PARAMETER"
><I
>parent</I
></TT
> children list.
<TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> parameters are optional (NULL). If content is non NULL,
a child list containing the TEXTs and ENTITY_REFs node will be created.
NOTE: <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> is supposed to be a piece of XML CDATA, so it allow entities
references, but XML special chars need to be escaped first by using
<A
HREF="libxml-entities.html#XMLENCODEENTITIESREENTRANT"
>xmlEncodeEntitiesReentrant</A
>(). Use <A
HREF="libxml-tree.html#XMLNEWTEXTCHILD"
>xmlNewTextChild</A
>() if entities
support is not needed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5794"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the parent node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the child</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML content of the child if any.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5819"
></A
><H3
><A
NAME="XMLNEWTEXTCHILD"
></A
>xmlNewTextChild ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewTextChild                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new child element, added at the end of <TT
CLASS="PARAMETER"
><I
>parent</I
></TT
> children list.
<TT
CLASS="PARAMETER"
><I
>ns</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> parameters are optional (NULL). If content is non NULL,
a child TEXT node will be created containing the string content.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5833"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the parent node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a namespace if any</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the child</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content of the child if any.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5858"
></A
><H3
><A
NAME="XMLNEWDOCTEXT"
></A
>xmlNewDocText ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocText                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new text node within a document.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5867"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5884"
></A
><H3
><A
NAME="XMLNEWTEXT"
></A
>xmlNewText ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewText                      (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new text node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5892"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5905"
></A
><H3
><A
NAME="XMLNEWPI"
></A
>xmlNewPI ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewPI                        (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a processing instruction element.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5914"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the processing instruction name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the PI content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5931"
></A
><H3
><A
NAME="XMLNEWDOCTEXTLEN"
></A
>xmlNewDocTextLen ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocTextLen                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new text node with an extra content length parameter. The
text node pertain to a given document.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5940"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text len.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5961"
></A
><H3
><A
NAME="XMLNEWTEXTLEN"
></A
>xmlNewTextLen ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewTextLen                   (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new text node with an extra parameter for the content's length</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5969"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the text len.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN5986"
></A
><H3
><A
NAME="XMLNEWDOCCOMMENT"
></A
>xmlNewDocComment ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocComment                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node containing a comment within a document.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN5995"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the comment content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6012"
></A
><H3
><A
NAME="XMLNEWCOMMENT"
></A
>xmlNewComment ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewComment                   (const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node containing a comment.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6020"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the comment content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6033"
></A
><H3
><A
NAME="XMLNEWCDATABLOCK"
></A
>xmlNewCDataBlock ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewCDataBlock                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new node containing a CDATA block.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6042"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the CDATA block content content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the length of the block</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6063"
></A
><H3
><A
NAME="XMLNEWCHARREF"
></A
>xmlNewCharRef ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewCharRef                   (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new character reference node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6072"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the char ref string, starting with # or "&amp;# ... ;"</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6089"
></A
><H3
><A
NAME="XMLNEWREFERENCE"
></A
>xmlNewReference ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewReference                 (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new reference node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6098"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the reference name, or the reference string with &amp; and ;</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6115"
></A
><H3
><A
NAME="XMLCOPYNODE"
></A
>xmlCopyNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlCopyNode                     (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             int recursive);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6123"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>recursive</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  if 1 do a recursive copy.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6141"
></A
><H3
><A
NAME="XMLDOCCOPYNODE"
></A
>xmlDocCopyNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlDocCopyNode                  (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int recursive);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the node to a given document.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6150"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>recursive</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  if 1 do a recursive copy.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6172"
></A
><H3
><A
NAME="XMLCOPYNODELIST"
></A
>xmlCopyNodeList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlCopyNodeList                 (const <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Do a recursive copy of the node list.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6180"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first node in the list.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6194"
></A
><H3
><A
NAME="XMLNEWDOCFRAGMENT"
></A
>xmlNewDocFragment ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlNewDocFragment               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>Creation of a new Fragment node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6202"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document owning the fragment</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the new node object.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6215"
></A
><H3
><A
NAME="XMLGETLINENO"
></A
>xmlGetLineNo ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><GTKDOCLINK
HREF="LONG"
>long</GTKDOCLINK
>        xmlGetLineNo                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Get line number of node. this requires activation of this option
before invoking the parser by calling xmlLineNumbersDefault(1)</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6223"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> valid node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the line number if successful, -1 otherwise</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6236"
></A
><H3
><A
NAME="XMLGETNODEPATH"
></A
>xmlGetNodePath ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlGetNodePath                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Build a structure based Path for the given node</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6244"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new path or NULL in case of error. The caller must free
the returned string</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6257"
></A
><H3
><A
NAME="XMLDOCGETROOTELEMENT"
></A
>xmlDocGetRootElement ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlDocGetRootElement            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>Get the root element of the document (doc-&gt;children is a list
containing possibly comments, PIs, etc ...).</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6265"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> for the root or NULL</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6279"
></A
><H3
><A
NAME="XMLGETLASTCHILD"
></A
>xmlGetLastChild ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlGetLastChild                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent);</PRE
></TD
></TR
></TABLE
><P
>Search the last child of a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6287"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the parent node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the last child or NULL if none.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6300"
></A
><H3
><A
NAME="XMLNODEISTEXT"
></A
>xmlNodeIsText ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlNodeIsText                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Is this node a Text node ?</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6307"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>1 yes, 0 no</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6320"
></A
><H3
><A
NAME="XMLISBLANKNODE"
></A
>xmlIsBlankNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlIsBlankNode                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Checks whether this node is an empty or whitespace only
(and possibly ignorable) text-node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6327"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>1 yes, 0 no</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6340"
></A
><H3
><A
NAME="XMLDOCSETROOTELEMENT"
></A
>xmlDocSetRootElement ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlDocSetRootElement            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> root);</PRE
></TD
></TR
></TABLE
><P
>Set the root element of the document (doc-&gt;children is a list
containing possibly comments, PIs, etc ...).</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6349"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>root</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new document root element</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the old root element if any was found</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6366"
></A
><H3
><A
NAME="XMLNODESETNAME"
></A
>xmlNodeSetName ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetName                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Set (or reset) the name of a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6374"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being changed</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new tag name</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6387"
></A
><H3
><A
NAME="XMLADDCHILD"
></A
>xmlAddChild ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlAddChild                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Add a new node to <TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>, at the end of the child (or property) list
merging adjacent TEXT nodes (in which case <TT
CLASS="PARAMETER"
><I
>cur</I
></TT
> is freed)
If the new node was already inserted in a document it is
first unlinked from its existing context.
If the new node is ATTRIBUTE, it is added into properties instead of children.
If there is an attribute with equal name, it is first destroyed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6398"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the parent node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the child node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the child or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6415"
></A
><H3
><A
NAME="XMLADDCHILDLIST"
></A
>xmlAddChildList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlAddChildList                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> parent,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Add a list of node at the end of the child list of the parent
merging adjacent TEXT nodes (<TT
CLASS="PARAMETER"
><I
>cur</I
></TT
> may be freed)</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6425"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parent</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the parent node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first node in the list</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the last child or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6442"
></A
><H3
><A
NAME="XMLREPLACENODE"
></A
>xmlReplaceNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlReplaceNode                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> old,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Unlink the old node from it's current context, prune the new one
at the same place. If <TT
CLASS="PARAMETER"
><I
>cur</I
></TT
> was already inserted in a document it is
first unlinked from its existing context.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6452"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>old</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the old node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the <TT
CLASS="PARAMETER"
><I
>old</I
></TT
> node</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6470"
></A
><H3
><A
NAME="XMLADDSIBLING"
></A
>xmlAddSibling ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlAddSibling                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);</PRE
></TD
></TR
></TABLE
><P
>Add a new element <TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> to the list of siblings of <TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>
merging adjacent TEXT nodes (<TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> may be freed)
If the new element was already inserted in a document it is
first unlinked from its existing context.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6482"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the child node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>elem</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new element or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6499"
></A
><H3
><A
NAME="XMLADDPREVSIBLING"
></A
>xmlAddPrevSibling ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlAddPrevSibling               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);</PRE
></TD
></TR
></TABLE
><P
>Add a new node <TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> as the previous sibling of <TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>
merging adjacent TEXT nodes (<TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> may be freed)
If the new node was already inserted in a document it is
first unlinked from its existing context.
If the new node is ATTRIBUTE, it is added into properties instead of children.
If there is an attribute with equal name, it is first destroyed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6511"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the child node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>elem</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new node or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6528"
></A
><H3
><A
NAME="XMLADDNEXTSIBLING"
></A
>xmlAddNextSibling ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlAddNextSibling               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> elem);</PRE
></TD
></TR
></TABLE
><P
>Add a new node <TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> as the next sibling of <TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>
If the new node was already inserted in a document it is
first unlinked from its existing context.
As a result of text merging <TT
CLASS="PARAMETER"
><I
>elem</I
></TT
> may be freed.
If the new node is ATTRIBUTE, it is added into properties instead of children.
If there is an attribute with equal name, it is first destroyed.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6540"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the child node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>elem</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the new node or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6557"
></A
><H3
><A
NAME="XMLUNLINKNODE"
></A
>xmlUnlinkNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlUnlinkNode                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Unlink a node from it's current context, the node is not freed</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6564"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6573"
></A
><H3
><A
NAME="XMLTEXTMERGE"
></A
>xmlTextMerge ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlTextMerge                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> first,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> second);</PRE
></TD
></TR
></TABLE
><P
>Merge two text nodes into one</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6582"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>first</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first text node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>second</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the second text node being merged</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the first text node augmented</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6599"
></A
><H3
><A
NAME="XMLTEXTCONCAT"
></A
>xmlTextConcat ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlTextConcat                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Concat the given string at the end of the existing node content</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6607"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  <TT
CLASS="PARAMETER"
><I
>content</I
></TT
> length</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6625"
></A
><H3
><A
NAME="XMLFREENODELIST"
></A
>xmlFreeNodeList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeNodeList                 (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free a node and all its siblings, this is a recursive behaviour, all
the children are freed too.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6632"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first node in the list</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6641"
></A
><H3
><A
NAME="XMLFREENODE"
></A
>xmlFreeNode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlFreeNode                     (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Free a node, this is a recursive behaviour, all the children are freed too.
This doesn't unlink the child from the list, use <A
HREF="libxml-tree.html#XMLUNLINKNODE"
>xmlUnlinkNode</A
>() first.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6649"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6658"
></A
><H3
><A
NAME="XMLSETTREEDOC"
></A
>xmlSetTreeDoc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetTreeDoc                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> tree,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>update all nodes under the tree to point to the right document</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6666"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>tree</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the top element</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6679"
></A
><H3
><A
NAME="XMLSETLISTDOC"
></A
>xmlSetListDoc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetListDoc                   (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>update all nodes in the list to point to the right document</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6687"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>list</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first element</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6700"
></A
><H3
><A
NAME="XMLSEARCHNS"
></A
>xmlSearchNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlSearchNs                     (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);</PRE
></TD
></TR
></TABLE
><P
>Search a Ns registered under a given name space for a document.
recurse on the parents until it finds the defined namespace
or return NULL otherwise.
<TT
CLASS="PARAMETER"
><I
>nameSpace</I
></TT
> can be NULL, this is a search for the default namespace.
We don't allow to cross entities boundaries. If you don't declare
the namespace within those you will be in troubles !!! A warning
is generated to cover this case.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6711"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>nameSpace</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace prefix</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the namespace pointer or NULL.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6732"
></A
><H3
><A
NAME="XMLSEARCHNSBYHREF"
></A
>xmlSearchNsByHref ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlSearchNsByHref               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *href);</PRE
></TD
></TR
></TABLE
><P
>Search a Ns aliasing a given URI. Recurse on the parents until it finds
the defined namespace or return NULL otherwise.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6742"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>href</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace value</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the namespace pointer or NULL.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6763"
></A
><H3
><A
NAME="XMLGETNSLIST"
></A
>xmlGetNsList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>*   xmlGetNsList                    (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node);</PRE
></TD
></TR
></TABLE
><P
>Search all the namespace applying to a given element.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6772"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>an NULL terminated array of all the <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> found
that need to be freed by the caller or NULL if no
namespace if defined</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6790"
></A
><H3
><A
NAME="XMLSETNS"
></A
>xmlSetNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetNs                        (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns);</PRE
></TD
></TR
></TABLE
><P
>Associate a namespace to a node, a posteriori.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6798"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a node in the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a namespace pointer</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6811"
></A
><H3
><A
NAME="XMLCOPYNAMESPACE"
></A
>xmlCopyNamespace ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlCopyNamespace                (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of the namespace.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6819"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6833"
></A
><H3
><A
NAME="XMLCOPYNAMESPACELIST"
></A
>xmlCopyNamespaceList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>    xmlCopyNamespaceList            (<A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Do a copy of an namespace list.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6841"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the first namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> a new <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
>, or NULL in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6855"
></A
><H3
><A
NAME="XMLSETPROP"
></A
>xmlSetProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlSetProp                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Set (or reset) an attribute carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6865"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute value</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute pointer.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6886"
></A
><H3
><A
NAME="XMLGETPROP"
></A
>xmlGetProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlGetProp                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Search and get the value of an attribute associated to a node
This does the entity substitution.
This function looks in DTD attribute declaration for <GTKDOCLINK
HREF="FIXED-CAPS"
>FIXED</GTKDOCLINK
> or
default declaration values unless DTD use has been turned off.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6896"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute value or NULL if not found.
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6914"
></A
><H3
><A
NAME="XMLHASPROP"
></A
>xmlHasProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlHasProp                      (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Search an attribute associated to a node
This function also looks in DTD attribute declaration for <GTKDOCLINK
HREF="FIXED-CAPS"
>FIXED</GTKDOCLINK
> or
default declaration values unless DTD use has been turned off.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6924"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute or the attribute declaration or NULL if 
neither was found.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6941"
></A
><H3
><A
NAME="XMLHASNSPROP"
></A
>xmlHasNsProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlHasNsProp                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);</PRE
></TD
></TR
></TABLE
><P
>Search for an attribute associated to a node
This attribute has to be anchored in the namespace specified.
This does the entity substitution.
This function looks in DTD attribute declaration for <GTKDOCLINK
HREF="FIXED-CAPS"
>FIXED</GTKDOCLINK
> or
default declaration values unless DTD use has been turned off.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6952"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>nameSpace</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the URI of the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute or the attribute declaration or NULL
if neither was found.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN6973"
></A
><H3
><A
NAME="XMLSETNSPROP"
></A
>xmlSetNsProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
>  xmlSetNsProp                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Set (or reset) an attribute carried by a node.
The ns structure must be in scope, this is not checked.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN6984"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace definition</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute value</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute pointer.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7009"
></A
><H3
><A
NAME="XMLGETNSPROP"
></A
>xmlGetNsProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlGetNsProp                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *nameSpace);</PRE
></TD
></TR
></TABLE
><P
>Search and get the value of an attribute associated to a node
This attribute has to be anchored in the namespace specified.
This does the entity substitution.
This function looks in DTD attribute declaration for <GTKDOCLINK
HREF="FIXED-CAPS"
>FIXED</GTKDOCLINK
> or
default declaration values unless DTD use has been turned off.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7020"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>nameSpace</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the URI of the namespace</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the attribute value or NULL if not found.
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7042"
></A
><H3
><A
NAME="XMLSTRINGGETNODELIST"
></A
>xmlStringGetNodeList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlStringGetNodeList            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value);</PRE
></TD
></TR
></TABLE
><P
>Parse the value string and build the node list associated. Should
produce a flat tree with only TEXTs and ENTITY_REFs.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7051"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the first child</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7068"
></A
><H3
><A
NAME="XMLSTRINGLENGETNODELIST"
></A
>xmlStringLenGetNodeList ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
>  xmlStringLenGetNodeList         (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *value,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Parse the value string and build the node list associated. Should
produce a flat tree with only TEXTs and ENTITY_REFs.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7077"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>value</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the value of the text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the length of the string value</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the first child</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7098"
></A
><H3
><A
NAME="XMLNODELISTGETSTRING"
></A
>xmlNodeListGetString ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlNodeListGetString            (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             int inLine);</PRE
></TD
></TR
></TABLE
><P
>Returns the string equivalent to the text contained in the Node list
made of TEXTs and ENTITY_REFs</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7107"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>list</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a Node list</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>inLine</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should we replace entity contents or show their external form</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the string copy, the caller must free it with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7129"
></A
><H3
><A
NAME="XMLNODELISTGETRAWSTRING"
></A
>xmlNodeListGetRawString ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlNodeListGetRawString         (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> list,
                                             int inLine);</PRE
></TD
></TR
></TABLE
><P
>Returns the string equivalent to the text contained in the Node list
made of TEXTs and ENTITY_REFs, contrary to <A
HREF="libxml-tree.html#XMLNODELISTGETSTRING"
>xmlNodeListGetString</A
>()
this function doesn't do any character encoding handling.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7139"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>list</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a Node list</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>inLine</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should we replace entity contents or show their external form</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the string copy, the caller must free it with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7161"
></A
><H3
><A
NAME="XMLNODESETCONTENT"
></A
>xmlNodeSetContent ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetContent               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Replace the content of a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7169"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being modified</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new value of the content</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7182"
></A
><H3
><A
NAME="XMLNODESETCONTENTLEN"
></A
>xmlNodeSetContentLen ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetContentLen            (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Replace the content of a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7190"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being modified</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new value of the content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the size of <TT
CLASS="PARAMETER"
><I
>content</I
></TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7208"
></A
><H3
><A
NAME="XMLNODEADDCONTENT"
></A
>xmlNodeAddContent ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeAddContent               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content);</PRE
></TD
></TR
></TABLE
><P
>Append the extra substring to the node content.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7216"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being modified</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  extra content</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7229"
></A
><H3
><A
NAME="XMLNODEADDCONTENTLEN"
></A
>xmlNodeAddContentLen ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeAddContentLen            (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *content,
                                             int len);</PRE
></TD
></TR
></TABLE
><P
>Append the extra substring to the node content.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7237"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being modified</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>content</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  extra content</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the size of <TT
CLASS="PARAMETER"
><I
>content</I
></TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7255"
></A
><H3
><A
NAME="XMLNODEGETCONTENT"
></A
>xmlNodeGetContent ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlNodeGetContent               (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Read the value of a node, this can be either the text carried
directly by this node if it's a TEXT node or the aggregate string
of the values carried by this node child's (TEXT and ENTITY_REF).
Entity references are substituted.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7263"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being read</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a new <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> * or NULL if no content is available.
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7278"
></A
><H3
><A
NAME="XMLNODEGETLANG"
></A
>xmlNodeGetLang ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlNodeGetLang                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Searches the language of a node, i.e. the values of the xml:lang
attribute or the one carried by the nearest ancestor.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7286"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being checked</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the lang value, or NULL if not found
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7300"
></A
><H3
><A
NAME="XMLNODESETLANG"
></A
>xmlNodeSetLang ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetLang                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *lang);</PRE
></TD
></TR
></TABLE
><P
>Set the language of a node, i.e. the values of the xml:lang
attribute.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7308"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being changed</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>lang</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the language description</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7321"
></A
><H3
><A
NAME="XMLNODEGETSPACEPRESERVE"
></A
>xmlNodeGetSpacePreserve ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlNodeGetSpacePreserve         (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Searches the space preserving behaviour of a node, i.e. the values
of the xml:space attribute or the one carried by the nearest
ancestor.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7328"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being checked</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>-1 if xml:space is not inherited, 0 if "default", 1 if "preserve"</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7341"
></A
><H3
><A
NAME="XMLNODESETSPACEPRESERVE"
></A
>xmlNodeSetSpacePreserve ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetSpacePreserve         (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int val);</PRE
></TD
></TR
></TABLE
><P
>Set (or reset) the space preserving behaviour of a node, i.e. the
value of the xml:space attribute.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7348"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being changed</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>val</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the xml:space value ("0": default, 1: "preserve")</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7361"
></A
><H3
><A
NAME="XMLNODEGETBASE"
></A
>xmlNodeGetBase ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
>*    xmlNodeGetBase                  (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Searches for the BASE URL. The code should work on both XML
and HTML document even if base mechanisms are completely different.
It returns the base as defined in RFC 2396 sections
5.1.1. Base URI within Document Content
and
5.1.2. Base URI from the Encapsulating Entity
However it does not return the document base (5.1.3), use
<GTKDOCLINK
HREF="XMLDOCUMENTGETBASE"
>xmlDocumentGetBase</GTKDOCLINK
>() for this</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7371"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document the node pertains to</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being checked</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>a pointer to the base URL, or NULL if not found
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7389"
></A
><H3
><A
NAME="XMLNODESETBASE"
></A
>xmlNodeSetBase ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeSetBase                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *uri);</PRE
></TD
></TR
></TABLE
><P
>Set (or reset) the base URI of a node, i.e. the value of the
xml:base attribute.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7397"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node being changed</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>uri</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the new base URI</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7410"
></A
><H3
><A
NAME="XMLREMOVEPROP"
></A
>xmlRemoveProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlRemoveProp                   (<A
HREF="libxml-tree.html#XMLATTRPTR"
>xmlAttrPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Unlink and free one attribute, all the content is freed too
Note this doesn't work for namespace definition attributes</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7417"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  an attribute</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 if success and -1 in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7430"
></A
><H3
><A
NAME="XMLUNSETPROP"
></A
>xmlUnsetProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlUnsetProp                    (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Remove an attribute carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7438"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 if successful, -1 if not found</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7455"
></A
><H3
><A
NAME="XMLUNSETNSPROP"
></A
>xmlUnsetNsProp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlUnsetNsProp                  (<A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> node,
                                             <A
HREF="libxml-tree.html#XMLNSPTR"
>xmlNsPtr</A
> ns,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *name);</PRE
></TD
></TR
></TABLE
><P
>Remove an attribute carried by a node.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7464"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>node</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>ns</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the namespace definition</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>name</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the attribute name</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 if successful, -1 if not found</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7485"
></A
><H3
><A
NAME="XMLBUFFERWRITEXMLCHAR"
></A
>xmlBufferWriteXmlCHAR ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferWriteXmlCHAR           (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>For VMS only.
routine which manages and grows an output buffer. This one adds
xmlChars at the end of the buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7493"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the string to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7506"
></A
><H3
><A
NAME="XMLBUFFERWRITECHAR"
></A
>xmlBufferWriteCHAR ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferWriteCHAR              (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>routine which manages and grows an output buffer. This one adds
xmlChars at the end of the buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7514"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the string to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7527"
></A
><H3
><A
NAME="XMLBUFFERWRITECHAR"
></A
>xmlBufferWriteChar ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferWriteChar              (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const char *string);</PRE
></TD
></TR
></TABLE
><P
>routine which manage and grows an output buffer. This one add
C chars at the end of the array.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7534"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the string to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7547"
></A
><H3
><A
NAME="XMLBUFFERWRITEQUOTEDSTRING"
></A
>xmlBufferWriteQuotedString ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlBufferWriteQuotedString      (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             const <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>routine which manage and grows an output buffer. This one writes
a quoted or double quoted <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> string, checking first if it holds
quote or double-quotes internally</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7556"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the string to add</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7569"
></A
><H3
><A
NAME="XMLRECONCILIATENS"
></A
>xmlReconciliateNs ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlReconciliateNs               (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> tree);</PRE
></TD
></TR
></TABLE
><P
>This function checks that all the namespaces declared within the given
tree are properly declared. This is needed for example after Copy or Cut
and then paste operations. The subtree may still hold pointers to
namespace declarations outside the subtree or invalid/masked. As much
as possible the function try to reuse the existing namespaces found in
the new environment. If not possible the new namespaces are redeclared
on <TT
CLASS="PARAMETER"
><I
>tree</I
></TT
> at the top of the given subtree.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7578"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>tree</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  a node defining the subtree to reconciliate</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the number of namespace declarations created or -1 in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7595"
></A
><H3
><A
NAME="XMLDOCDUMPFORMATMEMORY"
></A
>xmlDocDumpFormatMemory ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlDocDumpFormatMemory          (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **mem,
                                             int *size,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document in memory and return the <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> * and it's size.
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().
Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1
or xmlKeepBlanksDefault(0) was called</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7605"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>mem</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  OUT: the memory pointer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  OUT: the memory length</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should formatting spaces been added</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7626"
></A
><H3
><A
NAME="XMLDOCDUMPMEMORY"
></A
>xmlDocDumpMemory ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlDocDumpMemory                (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **mem,
                                             int *size);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document in memory and return the <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> * and it's size.
It's up to the caller to free the memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7636"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>mem</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  OUT: the memory pointer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>size</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  OUT: the memory length</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7653"
></A
><H3
><A
NAME="XMLDOCDUMPMEMORYENC"
></A
>xmlDocDumpMemoryEnc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlDocDumpMemoryEnc             (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> out_doc,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **doc_txt_ptr,
                                             int *doc_txt_len,
                                             const char *txt_encoding);</PRE
></TD
></TR
></TABLE
><P
>Dump the current DOM tree into memory using the character encoding specified
by the caller.  Note it is up to the caller of this function to free the
allocated memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7662"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>out_doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Document to generate XML text from</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc_txt_ptr</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Memory pointer for allocated XML text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc_txt_len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Length of the generated XML text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>txt_encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Character encoding to use when generating XML text</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7683"
></A
><H3
><A
NAME="XMLDOCDUMPFORMATMEMORYENC"
></A
>xmlDocDumpFormatMemoryEnc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlDocDumpFormatMemoryEnc       (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> out_doc,
                                             <A
HREF="libxml-tree.html#XMLCHAR"
>xmlChar</A
> **doc_txt_ptr,
                                             int *doc_txt_len,
                                             const char *txt_encoding,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump the current DOM tree into memory using the character encoding specified
by the caller.  Note it is up to the caller of this function to free the
allocated memory with <A
HREF="libxml-globals.html#XMLFREE"
>xmlFree</A
>().
Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1
or xmlKeepBlanksDefault(0) was called</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7692"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>out_doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Document to generate XML text from</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc_txt_ptr</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Memory pointer for allocated XML text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc_txt_len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Length of the generated XML text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>txt_encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  Character encoding to use when generating XML text</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should formatting spaces been added</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7717"
></A
><H3
><A
NAME="XMLDOCFORMATDUMP"
></A
>xmlDocFormatDump ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlDocFormatDump                (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to an open FILE.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7725"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>f</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the FILE*</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> should formatting spaces been added</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7746"
></A
><H3
><A
NAME="XMLDOCDUMP"
></A
>xmlDocDump ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlDocDump                      (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to an open FILE.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7754"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>f</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the FILE*</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7771"
></A
><H3
><A
NAME="XMLELEMDUMP"
></A
>xmlElemDump ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlElemDump                     (<GTKDOCLINK
HREF="FILE-CAPS"
>FILE</GTKDOCLINK
> *f,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML/HTML node, recursive behaviour, children are printed too.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7780"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>f</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the FILE * for the output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7797"
></A
><H3
><A
NAME="XMLSAVEFILE"
></A
>xmlSaveFile ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFile                     (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to a file. Will use compression if
compiled in and enabled. If <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is "-" the stdout file is
used.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7805"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the filename (or URL)</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7822"
></A
><H3
><A
NAME="XMLSAVEFORMATFILE"
></A
>xmlSaveFormatFile ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFormatFile               (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to a file. Will use compression if
compiled in and enabled. If <TT
CLASS="PARAMETER"
><I
>filename</I
></TT
> is "-" the stdout file is
used. If <TT
CLASS="PARAMETER"
><I
>format</I
></TT
> is set then the document will be indented on output.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7831"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the filename (or URL)</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should formatting spaces been added</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7852"
></A
><H3
><A
NAME="XMLNODEDUMP"
></A
>xmlNodeDump ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeDump                     (<A
HREF="libxml-tree.html#XMLBUFFERPTR"
>xmlBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int level,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML node, recursive behaviour,children are printed too.
Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1
or xmlKeepBlanksDefault(0) was called</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7861"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>level</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the imbrication level for indenting</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> is formatting allowed</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7886"
></A
><H3
><A
NAME="XMLSAVEFILETO"
></A
>xmlSaveFileTo ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFileTo                   (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to an I/O buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7894"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  an output I/O buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the encoding if any assuming the I/O layer handles the trancoding</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7915"
></A
><H3
><A
NAME="XMLSAVEFORMATFILETO"
></A
>xmlSaveFormatFileTo ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFormatFileTo             (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document to an I/O buffer.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7923"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  an output I/O buffer</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the encoding if any assuming the I/O layer handles the trancoding</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> should formatting spaces been added</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7948"
></A
><H3
><A
NAME="XMLNODEDUMPOUTPUT"
></A
>xmlNodeDumpOutput ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlNodeDumpOutput               (<A
HREF="libxml-tree.html#XMLOUTPUTBUFFERPTR"
>xmlOutputBufferPtr</A
> buf,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             <A
HREF="libxml-tree.html#XMLNODEPTR"
>xmlNodePtr</A
> cur,
                                             int level,
                                             int format,
                                             const char *encoding);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML node, recursive behaviour, children are printed too.
Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1
or xmlKeepBlanksDefault(0) was called</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7957"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>buf</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the XML buffer output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the current node</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>level</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the imbrication level for indenting</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> is formatting allowed</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  an optional encoding string</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7986"
></A
><H3
><A
NAME="XMLSAVEFORMATFILEENC"
></A
>xmlSaveFormatFileEnc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFormatFileEnc            (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding,
                                             int format);</PRE
></TD
></TR
></TABLE
><P
></P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN7993"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the filename or URL to output</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document being saved</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of the encoding to use or NULL.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  should formatting spaces be added.</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>the number of bytes written or -1 in case of error.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN8018"
></A
><H3
><A
NAME="XMLSAVEFILEENC"
></A
>xmlSaveFileEnc ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlSaveFileEnc                  (const char *filename,
                                             <A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> cur,
                                             const char *encoding);</PRE
></TD
></TR
></TABLE
><P
>Dump an XML document, converting it to the given encoding</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN8025"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the filename (or URL)</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>cur</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>encoding</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the name of an encoding (or NULL)</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of bytes written or -1 in case of failure.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN8046"
></A
><H3
><A
NAME="XMLGETDOCCOMPRESSMODE"
></A
>xmlGetDocCompressMode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlGetDocCompressMode           (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc);</PRE
></TD
></TR
></TABLE
><P
>get the compression ratio for a document, ZLIB based</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN8053"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 (uncompressed) to 9 (max compression)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN8066"
></A
><H3
><A
NAME="XMLSETDOCCOMPRESSMODE"
></A
>xmlSetDocCompressMode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetDocCompressMode           (<A
HREF="libxml-tree.html#XMLDOCPTR"
>xmlDocPtr</A
> doc,
                                             int mode);</PRE
></TD
></TR
></TABLE
><P
>set the compression ratio for a document, ZLIB based
Correct values: 0 (uncompressed) to 9 (max compression)</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN8073"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>doc</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the document</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the compression ratio</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN8086"
></A
><H3
><A
NAME="XMLGETCOMPRESSMODE"
></A
>xmlGetCompressMode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>int         xmlGetCompressMode              (void);</PRE
></TD
></TR
></TABLE
><P
>get the default compression mode used, ZLIB based.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN8092"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>0 (uncompressed) to 9 (max compression)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN8101"
></A
><H3
><A
NAME="XMLSETCOMPRESSMODE"
></A
>xmlSetCompressMode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        xmlSetCompressMode              (int mode);</PRE
></TD
></TR
></TABLE
><P
>set the default compression mode used, ZLIB based
Correct values: 0 (uncompressed) to 9 (max compression)</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN8107"><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>mode</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>  the compression ratio</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><BR
CLEAR="all"><BR><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="libxml-sax.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#0000C0"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="book1.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#00C000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="libxml-lib.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="libxml-entities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="left"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>SAX</B
></FONT
></TD
><TD
COLSPAN="2"
ALIGN="right"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>entities</B
></FONT
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>