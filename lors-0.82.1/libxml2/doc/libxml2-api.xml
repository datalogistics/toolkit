<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libxml2'>
  <files>
    <file name='parserInternals'>
     <exports symbol='XML_MAX_NAMELEN'/>
     <exports symbol='INPUT_CHUNK'/>
     <exports symbol='IS_CHAR'/>
     <exports symbol='IS_BLANK'/>
     <exports symbol='IS_BASECHAR'/>
     <exports symbol='IS_DIGIT'/>
     <exports symbol='IS_COMBINING'/>
     <exports symbol='IS_EXTENDER'/>
     <exports symbol='IS_IDEOGRAPHIC'/>
     <exports symbol='IS_LETTER'/>
     <exports symbol='IS_PUBIDCHAR'/>
     <exports symbol='SKIP_EOL'/>
     <exports symbol='MOVETO_ENDTAG'/>
     <exports symbol='MOVETO_STARTTAG'/>
     <exports symbol='xmlIsBaseChar'/>
     <exports symbol='xmlIsBlank'/>
     <exports symbol='xmlIsPubidChar'/>
     <exports symbol='xmlIsLetter'/>
     <exports symbol='xmlIsDigit'/>
     <exports symbol='xmlIsIdeographic'/>
     <exports symbol='xmlIsExtender'/>
     <exports symbol='xmlIsCombining'/>
     <exports symbol='xmlIsChar'/>
     <exports symbol='xmlCreateFileParserCtxt'/>
     <exports symbol='xmlCreateMemoryParserCtxt'/>
     <exports symbol='xmlNewParserCtxt'/>
     <exports symbol='xmlCreateEntityParserCtxt'/>
     <exports symbol='xmlSwitchEncoding'/>
     <exports symbol='xmlSwitchToEncoding'/>
     <exports symbol='xmlHandleEntity'/>
     <exports symbol='xmlNewStringInputStream'/>
     <exports symbol='xmlNewEntityInputStream'/>
     <exports symbol='xmlPushInput'/>
     <exports symbol='xmlPopInput'/>
     <exports symbol='xmlFreeInputStream'/>
     <exports symbol='xmlNewInputFromFile'/>
     <exports symbol='xmlNewInputStream'/>
     <exports symbol='xmlSplitQName'/>
     <exports symbol='xmlNamespaceParseNCName'/>
     <exports symbol='xmlNamespaceParseQName'/>
     <exports symbol='xmlNamespaceParseNSDef'/>
     <exports symbol='xmlParseQuotedString'/>
     <exports symbol='xmlParseNamespace'/>
     <exports symbol='xmlScanName'/>
     <exports symbol='xmlParseName'/>
     <exports symbol='xmlParseNmtoken'/>
     <exports symbol='xmlParseEntityValue'/>
     <exports symbol='xmlParseAttValue'/>
     <exports symbol='xmlParseSystemLiteral'/>
     <exports symbol='xmlParsePubidLiteral'/>
     <exports symbol='xmlParseCharData'/>
     <exports symbol='xmlParseExternalID'/>
     <exports symbol='xmlParseComment'/>
     <exports symbol='xmlParsePITarget'/>
     <exports symbol='xmlParsePI'/>
     <exports symbol='xmlParseNotationDecl'/>
     <exports symbol='xmlParseEntityDecl'/>
     <exports symbol='xmlParseDefaultDecl'/>
     <exports symbol='xmlParseNotationType'/>
     <exports symbol='xmlParseEnumerationType'/>
     <exports symbol='xmlParseEnumeratedType'/>
     <exports symbol='xmlParseAttributeType'/>
     <exports symbol='xmlParseAttributeListDecl'/>
     <exports symbol='xmlParseElementMixedContentDecl'/>
     <exports symbol='xmlParseElementChildrenContentD'/>
     <exports symbol='xmlParseElementChildrenContentDecl'/>
     <exports symbol='xmlParseElementContentDecl'/>
     <exports symbol='xmlParseElementDecl'/>
     <exports symbol='xmlParseMarkupDecl'/>
     <exports symbol='xmlParseCharRef'/>
     <exports symbol='xmlParseEntityRef'/>
     <exports symbol='xmlParseReference'/>
     <exports symbol='xmlParsePEReference'/>
     <exports symbol='xmlParseDocTypeDecl'/>
     <exports symbol='xmlParseAttribute'/>
     <exports symbol='xmlParseStartTag'/>
     <exports symbol='xmlParseEndTag'/>
     <exports symbol='xmlParseCDSect'/>
     <exports symbol='xmlParseContent'/>
     <exports symbol='xmlParseElement'/>
     <exports symbol='xmlParseVersionNum'/>
     <exports symbol='xmlParseVersionInfo'/>
     <exports symbol='xmlParseEncName'/>
     <exports symbol='xmlParseEncodingDecl'/>
     <exports symbol='xmlParseSDDecl'/>
     <exports symbol='xmlParseXMLDecl'/>
     <exports symbol='xmlParseTextDecl'/>
     <exports symbol='xmlParseMisc'/>
     <exports symbol='xmlParseExternalSubset'/>
     <exports symbol='XML_SUBSTITUTE_NONE'/>
     <exports symbol='XML_SUBSTITUTE_REF'/>
     <exports symbol='XML_SUBSTITUTE_PEREF'/>
     <exports symbol='XML_SUBSTITUTE_BOTH'/>
     <exports symbol='xmlDecodeEntities'/>
     <exports symbol='xmlStringDecodeEntities'/>
     <exports symbol='nodePush'/>
     <exports symbol='nodePop'/>
     <exports symbol='inputPush'/>
     <exports symbol='inputPop'/>
     <exports symbol='namePop'/>
     <exports symbol='namePush'/>
     <exports symbol='xmlSkipBlankChars'/>
     <exports symbol='xmlStringCurrentChar'/>
     <exports symbol='xmlParserHandlePEReference'/>
     <exports symbol='xmlParserHandleReference'/>
     <exports symbol='xmlCheckLanguageID'/>
     <exports symbol='xmlCurrentChar'/>
     <exports symbol='xmlCopyCharMultiByte'/>
     <exports symbol='xmlCopyChar'/>
     <exports symbol='xmlNextChar'/>
     <exports symbol='xmlParserInputShrink'/>
     <exports symbol='htmlInitAutoClose'/>
     <exports symbol='htmlCreateFileParserCtxt'/>
     <exports symbol='xmlEntityReferenceFunc'/>
     <exports symbol='xmlSetEntityReferenceFunc'/>
    </file>
    <file name='SAX'>
     <exports symbol='getPublicId'/>
     <exports symbol='getSystemId'/>
     <exports symbol='setDocumentLocator'/>
     <exports symbol='getLineNumber'/>
     <exports symbol='getColumnNumber'/>
     <exports symbol='isStandalone'/>
     <exports symbol='hasInternalSubset'/>
     <exports symbol='hasExternalSubset'/>
     <exports symbol='internalSubset'/>
     <exports symbol='externalSubset'/>
     <exports symbol='getEntity'/>
     <exports symbol='getParameterEntity'/>
     <exports symbol='resolveEntity'/>
     <exports symbol='entityDecl'/>
     <exports symbol='attributeDecl'/>
     <exports symbol='elementDecl'/>
     <exports symbol='notationDecl'/>
     <exports symbol='unparsedEntityDecl'/>
     <exports symbol='startDocument'/>
     <exports symbol='endDocument'/>
     <exports symbol='attribute'/>
     <exports symbol='startElement'/>
     <exports symbol='endElement'/>
     <exports symbol='reference'/>
     <exports symbol='characters'/>
     <exports symbol='ignorableWhitespace'/>
     <exports symbol='processingInstruction'/>
     <exports symbol='globalNamespace'/>
     <exports symbol='setNamespace'/>
     <exports symbol='getNamespace'/>
     <exports symbol='checkNamespace'/>
     <exports symbol='namespaceDecl'/>
     <exports symbol='comment'/>
     <exports symbol='cdataBlock'/>
     <exports symbol='initxmlDefaultSAXHandler'/>
     <exports symbol='inithtmlDefaultSAXHandler'/>
     <exports symbol='initdocbDefaultSAXHandler'/>
     <exports symbol='xmlDefaultSAXHandlerInit'/>
     <exports symbol='htmlDefaultSAXHandlerInit'/>
     <exports symbol='docbDefaultSAXHandlerInit'/>
    </file>
    <file name='DOCBparser'>
     <exports symbol='docbParserCtxt'/>
     <exports symbol='docbParserCtxtPtr'/>
     <exports symbol='docbParserNodeInfo'/>
     <exports symbol='docbSAXHandler'/>
     <exports symbol='docbSAXHandlerPtr'/>
     <exports symbol='docbParserInput'/>
     <exports symbol='docbParserInputPtr'/>
     <exports symbol='docbDocPtr'/>
     <exports symbol='docbNodePtr'/>
     <exports symbol='docbEncodeEntities'/>
     <exports symbol='docbSAXParseDoc'/>
     <exports symbol='docbParseDoc'/>
     <exports symbol='docbSAXParseFile'/>
     <exports symbol='docbParseFile'/>
     <exports symbol='docbFreeParserCtxt'/>
     <exports symbol='docbCreatePushParserCtxt'/>
     <exports symbol='docbParseChunk'/>
     <exports symbol='docbCreateFileParserCtxt'/>
     <exports symbol='docbParseDocument'/>
    </file>
    <file name='xmlregexp'>
     <exports symbol='xmlRegexp'/>
     <exports symbol='xmlRegexpPtr'/>
     <exports symbol='xmlRegExecCtxt'/>
     <exports symbol='xmlRegExecCtxtPtr'/>
     <exports symbol='xmlRegexpCompile'/>
     <exports symbol='xmlRegFreeRegexp'/>
     <exports symbol='xmlRegexpExec'/>
     <exports symbol='xmlRegexpPrint'/>
     <exports symbol='xmlRegexpIsDeterminist'/>
     <exports symbol='xmlRegExecCallbacks'/>
     <exports symbol='xmlRegNewExecCtxt'/>
     <exports symbol='xmlRegFreeExecCtxt'/>
     <exports symbol='xmlRegExecPushString'/>
    </file>
    <file name='HTMLparser'>
     <exports symbol='htmlParserCtxt'/>
     <exports symbol='htmlParserCtxtPtr'/>
     <exports symbol='htmlParserNodeInfo'/>
     <exports symbol='htmlSAXHandler'/>
     <exports symbol='htmlSAXHandlerPtr'/>
     <exports symbol='htmlParserInput'/>
     <exports symbol='htmlParserInputPtr'/>
     <exports symbol='htmlDocPtr'/>
     <exports symbol='htmlNodePtr'/>
     <exports symbol='htmlElemDesc'/>
     <exports symbol='htmlElemDescPtr'/>
     <exports symbol='htmlEntityDesc'/>
     <exports symbol='htmlEntityDescPtr'/>
     <exports symbol='htmlTagLookup'/>
     <exports symbol='htmlEntityLookup'/>
     <exports symbol='htmlEntityValueLookup'/>
     <exports symbol='htmlIsAutoClosed'/>
     <exports symbol='htmlAutoCloseTag'/>
     <exports symbol='htmlParseEntityRef'/>
     <exports symbol='htmlParseCharRef'/>
     <exports symbol='htmlParseElement'/>
     <exports symbol='htmlParseDocument'/>
     <exports symbol='htmlSAXParseDoc'/>
     <exports symbol='htmlParseDoc'/>
     <exports symbol='htmlSAXParseFile'/>
     <exports symbol='htmlParseFile'/>
     <exports symbol='UTF8ToHtml'/>
     <exports symbol='htmlEncodeEntities'/>
     <exports symbol='htmlIsScriptAttribute'/>
     <exports symbol='htmlHandleOmittedElem'/>
     <exports symbol='htmlFreeParserCtxt'/>
     <exports symbol='htmlCreatePushParserCtxt'/>
     <exports symbol='htmlParseChunk'/>
    </file>
    <file name='valid'>
     <exports symbol='xmlValidState'/>
     <exports symbol='xmlValidStatePtr'/>
     <exports symbol='xmlValidityErrorFunc'/>
     <exports symbol='xmlValidityWarningFunc'/>
     <exports symbol='xmlValidCtxt'/>
     <exports symbol='xmlValidCtxtPtr'/>
     <exports symbol='xmlNotationTablePtr'/>
     <exports symbol='xmlElementTablePtr'/>
     <exports symbol='xmlAttributeTablePtr'/>
     <exports symbol='xmlIDTablePtr'/>
     <exports symbol='xmlRefTablePtr'/>
     <exports symbol='xmlSplitQName2'/>
     <exports symbol='xmlAddNotationDecl'/>
     <exports symbol='xmlCopyNotationTable'/>
     <exports symbol='xmlFreeNotationTable'/>
     <exports symbol='xmlDumpNotationDecl'/>
     <exports symbol='xmlDumpNotationTable'/>
     <exports symbol='xmlNewElementContent'/>
     <exports symbol='xmlCopyElementContent'/>
     <exports symbol='xmlFreeElementContent'/>
     <exports symbol='xmlSnprintfElementContent'/>
     <exports symbol='xmlSprintfElementContent'/>
     <exports symbol='xmlAddElementDecl'/>
     <exports symbol='xmlCopyElementTable'/>
     <exports symbol='xmlFreeElementTable'/>
     <exports symbol='xmlDumpElementTable'/>
     <exports symbol='xmlDumpElementDecl'/>
     <exports symbol='xmlCreateEnumeration'/>
     <exports symbol='xmlFreeEnumeration'/>
     <exports symbol='xmlCopyEnumeration'/>
     <exports symbol='xmlAddAttributeDecl'/>
     <exports symbol='xmlCopyAttributeTable'/>
     <exports symbol='xmlFreeAttributeTable'/>
     <exports symbol='xmlDumpAttributeTable'/>
     <exports symbol='xmlDumpAttributeDecl'/>
     <exports symbol='xmlAddID'/>
     <exports symbol='xmlFreeIDTable'/>
     <exports symbol='xmlGetID'/>
     <exports symbol='xmlIsID'/>
     <exports symbol='xmlRemoveID'/>
     <exports symbol='xmlAddRef'/>
     <exports symbol='xmlFreeRefTable'/>
     <exports symbol='xmlIsRef'/>
     <exports symbol='xmlRemoveRef'/>
     <exports symbol='xmlGetRefs'/>
     <exports symbol='xmlValidateRoot'/>
     <exports symbol='xmlValidateElementDecl'/>
     <exports symbol='xmlValidNormalizeAttributeValue'/>
     <exports symbol='xmlValidCtxtNormalizeAttributeValue'/>
     <exports symbol='xmlValidateAttributeDecl'/>
     <exports symbol='xmlValidateAttributeValue'/>
     <exports symbol='xmlValidateNotationDecl'/>
     <exports symbol='xmlValidateDtd'/>
     <exports symbol='xmlValidateDtdFinal'/>
     <exports symbol='xmlValidateDocument'/>
     <exports symbol='xmlValidateElement'/>
     <exports symbol='xmlValidateOneElement'/>
     <exports symbol='xmlValidateOneAttribute'/>
     <exports symbol='xmlValidateOneNamespace'/>
     <exports symbol='xmlValidateDocumentFinal'/>
     <exports symbol='xmlValidateNotationUse'/>
     <exports symbol='xmlIsMixedElement'/>
     <exports symbol='xmlGetDtdAttrDesc'/>
     <exports symbol='xmlGetDtdQAttrDesc'/>
     <exports symbol='xmlGetDtdNotationDesc'/>
     <exports symbol='xmlGetDtdQElementDesc'/>
     <exports symbol='xmlGetDtdElementDesc'/>
     <exports symbol='xmlValidGetValidElements'/>
     <exports symbol='xmlValidGetPotentialChildren'/>
     <exports symbol='xmlValidateNameValue'/>
     <exports symbol='xmlValidateNamesValue'/>
     <exports symbol='xmlValidateNmtokenValue'/>
     <exports symbol='xmlValidateNmtokensValue'/>
     <exports symbol='xmlValidBuildContentModel'/>
    </file>
    <file name='nanohttp'>
     <exports symbol='xmlNanoHTTPInit'/>
     <exports symbol='xmlNanoHTTPCleanup'/>
     <exports symbol='xmlNanoHTTPScanProxy'/>
     <exports symbol='xmlNanoHTTPFetch'/>
     <exports symbol='xmlNanoHTTPMethod'/>
     <exports symbol='xmlNanoHTTPMethodRedir'/>
     <exports symbol='xmlNanoHTTPOpen'/>
     <exports symbol='xmlNanoHTTPOpenRedir'/>
     <exports symbol='xmlNanoHTTPReturnCode'/>
     <exports symbol='xmlNanoHTTPAuthHeader'/>
     <exports symbol='xmlNanoHTTPRead'/>
     <exports symbol='xmlNanoHTTPSave'/>
     <exports symbol='xmlNanoHTTPClose'/>
    </file>
    <file name='entities'>
     <exports symbol='xmlEntityType'/>
     <exports symbol='xmlEntity'/>
     <exports symbol='xmlEntitiesTablePtr'/>
     <exports symbol='xmlInitializePredefinedEntities'/>
     <exports symbol='xmlAddDocEntity'/>
     <exports symbol='xmlAddDtdEntity'/>
     <exports symbol='xmlGetPredefinedEntity'/>
     <exports symbol='xmlGetDocEntity'/>
     <exports symbol='xmlGetDtdEntity'/>
     <exports symbol='xmlGetParameterEntity'/>
     <exports symbol='xmlEncodeEntities'/>
     <exports symbol='xmlEncodeEntitiesReentrant'/>
     <exports symbol='xmlEncodeSpecialChars'/>
     <exports symbol='xmlCreateEntitiesTable'/>
     <exports symbol='xmlCopyEntitiesTable'/>
     <exports symbol='xmlFreeEntitiesTable'/>
     <exports symbol='xmlDumpEntitiesTable'/>
     <exports symbol='xmlDumpEntityDecl'/>
     <exports symbol='xmlCleanupPredefinedEntities'/>
    </file>
    <file name='xmlmemory'>
     <exports symbol='DEBUG_MEMORY'/>
     <exports symbol='xmlFreeFunc'/>
     <exports symbol='xmlMallocFunc'/>
     <exports symbol='xmlReallocFunc'/>
     <exports symbol='xmlStrdupFunc'/>
     <exports symbol='xmlMemSetup'/>
     <exports symbol='xmlMemGet'/>
     <exports symbol='xmlInitMemory'/>
     <exports symbol='xmlMemUsed'/>
     <exports symbol='xmlMemDisplay'/>
     <exports symbol='xmlMemShow'/>
     <exports symbol='xmlMemoryDump'/>
     <exports symbol='xmlMalloc'/>
     <exports symbol='xmlRealloc'/>
     <exports symbol='xmlMemStrdup'/>
     <exports symbol='xmlMallocLoc'/>
     <exports symbol='xmlReallocLoc'/>
     <exports symbol='xmlMemStrdupLoc'/>
    </file>
    <file name='uri'>
     <exports symbol='xmlURI'/>
     <exports symbol='xmlURIPtr'/>
     <exports symbol='xmlCreateURI'/>
     <exports symbol='xmlBuildURI'/>
     <exports symbol='xmlParseURI'/>
     <exports symbol='xmlParseURIReference'/>
     <exports symbol='xmlSaveUri'/>
     <exports symbol='xmlPrintURI'/>
     <exports symbol='xmlURIEscapeStr'/>
     <exports symbol='xmlURIUnescapeString'/>
     <exports symbol='xmlNormalizeURIPath'/>
     <exports symbol='xmlURIEscape'/>
     <exports symbol='xmlFreeURI'/>
    </file>
    <file name='list'>
     <exports symbol='xmlLink'/>
     <exports symbol='xmlLinkPtr'/>
     <exports symbol='xmlList'/>
     <exports symbol='xmlListPtr'/>
     <exports symbol='xmlListDeallocator'/>
     <exports symbol='xmlListDataCompare'/>
     <exports symbol='xmlListWalker'/>
     <exports symbol='xmlListCreate'/>
     <exports symbol='xmlListDelete'/>
     <exports symbol='xmlListSearch'/>
     <exports symbol='xmlListReverseSearch'/>
     <exports symbol='xmlListInsert'/>
     <exports symbol='xmlListAppend'/>
     <exports symbol='xmlListRemoveFirst'/>
     <exports symbol='xmlListRemoveLast'/>
     <exports symbol='xmlListRemoveAll'/>
     <exports symbol='xmlListClear'/>
     <exports symbol='xmlListEmpty'/>
     <exports symbol='xmlListFront'/>
     <exports symbol='xmlListEnd'/>
     <exports symbol='xmlListSize'/>
     <exports symbol='xmlListPopFront'/>
     <exports symbol='xmlListPopBack'/>
     <exports symbol='xmlListPushFront'/>
     <exports symbol='xmlListPushBack'/>
     <exports symbol='xmlListReverse'/>
     <exports symbol='xmlListSort'/>
     <exports symbol='xmlListWalk'/>
     <exports symbol='xmlListReverseWalk'/>
     <exports symbol='xmlListMerge'/>
     <exports symbol='xmlListDup'/>
     <exports symbol='xmlListCopy'/>
     <exports symbol='xmlLinkGetData'/>
    </file>
    <file name='nanoftp'>
     <exports symbol='ftpListCallback'/>
     <exports symbol='ftpDataCallback'/>
     <exports symbol='xmlNanoFTPInit'/>
     <exports symbol='xmlNanoFTPCleanup'/>
     <exports symbol='xmlNanoFTPNewCtxt'/>
     <exports symbol='xmlNanoFTPFreeCtxt'/>
     <exports symbol='xmlNanoFTPConnectTo'/>
     <exports symbol='xmlNanoFTPOpen'/>
     <exports symbol='xmlNanoFTPConnect'/>
     <exports symbol='xmlNanoFTPClose'/>
     <exports symbol='xmlNanoFTPQuit'/>
     <exports symbol='xmlNanoFTPScanProxy'/>
     <exports symbol='xmlNanoFTPProxy'/>
     <exports symbol='xmlNanoFTPUpdateURL'/>
     <exports symbol='xmlNanoFTPGetResponse'/>
     <exports symbol='xmlNanoFTPCheckResponse'/>
     <exports symbol='xmlNanoFTPCwd'/>
     <exports symbol='xmlNanoFTPGetConnection'/>
     <exports symbol='xmlNanoFTPCloseConnection'/>
     <exports symbol='xmlNanoFTPList'/>
     <exports symbol='xmlNanoFTPGetSocket'/>
     <exports symbol='xmlNanoFTPGet'/>
     <exports symbol='xmlNanoFTPRead'/>
    </file>
    <file name='tree'>
     <exports symbol='xmlParserInputBuffer'/>
     <exports symbol='xmlParserInputBufferPtr'/>
     <exports symbol='xmlOutputBuffer'/>
     <exports symbol='xmlOutputBufferPtr'/>
     <exports symbol='xmlParserInput'/>
     <exports symbol='xmlParserInputPtr'/>
     <exports symbol='xmlParserCtxt'/>
     <exports symbol='xmlParserCtxtPtr'/>
     <exports symbol='xmlSAXLocator'/>
     <exports symbol='xmlSAXLocatorPtr'/>
     <exports symbol='xmlSAXHandler'/>
     <exports symbol='xmlSAXHandlerPtr'/>
     <exports symbol='xmlEntity'/>
     <exports symbol='xmlEntityPtr'/>
     <exports symbol='BASE_BUFFER_SIZE'/>
     <exports symbol='XML_XML_NAMESPACE'/>
     <exports symbol='xmlElementType'/>
     <exports symbol='xmlChar'/>
     <exports symbol='BAD_CAST'/>
     <exports symbol='xmlNotation'/>
     <exports symbol='xmlNotationPtr'/>
     <exports symbol='xmlAttributeType'/>
     <exports symbol='xmlAttributeDefault'/>
     <exports symbol='xmlEnumeration'/>
     <exports symbol='xmlEnumerationPtr'/>
     <exports symbol='xmlAttribute'/>
     <exports symbol='xmlAttributePtr'/>
     <exports symbol='xmlElementContentType'/>
     <exports symbol='xmlElementContentOccur'/>
     <exports symbol='xmlElementContent'/>
     <exports symbol='xmlElementContentPtr'/>
     <exports symbol='xmlElementTypeVal'/>
     <exports symbol='xmlElement'/>
     <exports symbol='xmlElementPtr'/>
     <exports symbol='XML_LOCAL_NAMESPACE'/>
     <exports symbol='xmlNsType'/>
     <exports symbol='xmlNs'/>
     <exports symbol='xmlNsPtr'/>
     <exports symbol='xmlDtd'/>
     <exports symbol='xmlDtdPtr'/>
     <exports symbol='xmlAttr'/>
     <exports symbol='xmlAttrPtr'/>
     <exports symbol='xmlID'/>
     <exports symbol='xmlIDPtr'/>
     <exports symbol='xmlRef'/>
     <exports symbol='xmlRefPtr'/>
     <exports symbol='xmlBufferAllocationScheme'/>
     <exports symbol='xmlBuffer'/>
     <exports symbol='xmlBufferPtr'/>
     <exports symbol='xmlNode'/>
     <exports symbol='xmlNodePtr'/>
     <exports symbol='XML_GET_CONTENT'/>
     <exports symbol='XML_GET_LINE'/>
     <exports symbol='xmlDoc'/>
     <exports symbol='xmlDocPtr'/>
     <exports symbol='xmlChildrenNode'/>
     <exports symbol='xmlRootNode'/>
     <exports symbol='xmlSetBufferAllocationScheme'/>
     <exports symbol='xmlGetBufferAllocationScheme'/>
     <exports symbol='xmlBufferCreate'/>
     <exports symbol='xmlBufferCreateSize'/>
     <exports symbol='xmlBufferResize'/>
     <exports symbol='xmlBufferFree'/>
     <exports symbol='xmlBufferDump'/>
     <exports symbol='xmlBufferAdd'/>
     <exports symbol='xmlBufferAddHead'/>
     <exports symbol='xmlBufferCat'/>
     <exports symbol='xmlBufferCCat'/>
     <exports symbol='xmlBufferShrink'/>
     <exports symbol='xmlBufferGrow'/>
     <exports symbol='xmlBufferEmpty'/>
     <exports symbol='xmlBufferContent'/>
     <exports symbol='xmlBufferSetAllocationScheme'/>
     <exports symbol='xmlBufferLength'/>
     <exports symbol='xmlCreateIntSubset'/>
     <exports symbol='xmlNewDtd'/>
     <exports symbol='xmlGetIntSubset'/>
     <exports symbol='xmlFreeDtd'/>
     <exports symbol='xmlNewGlobalNs'/>
     <exports symbol='xmlNewNs'/>
     <exports symbol='xmlFreeNs'/>
     <exports symbol='xmlFreeNsList'/>
     <exports symbol='xmlNewDoc'/>
     <exports symbol='xmlFreeDoc'/>
     <exports symbol='xmlNewDocProp'/>
     <exports symbol='xmlNewProp'/>
     <exports symbol='xmlNewNsProp'/>
     <exports symbol='xmlNewNsPropEatName'/>
     <exports symbol='xmlFreePropList'/>
     <exports symbol='xmlFreeProp'/>
     <exports symbol='xmlCopyProp'/>
     <exports symbol='xmlCopyPropList'/>
     <exports symbol='xmlCopyDtd'/>
     <exports symbol='xmlCopyDoc'/>
     <exports symbol='xmlNewDocNode'/>
     <exports symbol='xmlNewDocNodeEatName'/>
     <exports symbol='xmlNewDocRawNode'/>
     <exports symbol='xmlNewNode'/>
     <exports symbol='xmlNewNodeEatName'/>
     <exports symbol='xmlNewChild'/>
     <exports symbol='xmlNewTextChild'/>
     <exports symbol='xmlNewDocText'/>
     <exports symbol='xmlNewText'/>
     <exports symbol='xmlNewPI'/>
     <exports symbol='xmlNewDocTextLen'/>
     <exports symbol='xmlNewTextLen'/>
     <exports symbol='xmlNewDocComment'/>
     <exports symbol='xmlNewComment'/>
     <exports symbol='xmlNewCDataBlock'/>
     <exports symbol='xmlNewCharRef'/>
     <exports symbol='xmlNewReference'/>
     <exports symbol='xmlCopyNode'/>
     <exports symbol='xmlDocCopyNode'/>
     <exports symbol='xmlCopyNodeList'/>
     <exports symbol='xmlNewDocFragment'/>
     <exports symbol='xmlGetLineNo'/>
     <exports symbol='xmlGetNodePath'/>
     <exports symbol='xmlDocGetRootElement'/>
     <exports symbol='xmlGetLastChild'/>
     <exports symbol='xmlNodeIsText'/>
     <exports symbol='xmlIsBlankNode'/>
     <exports symbol='xmlDocSetRootElement'/>
     <exports symbol='xmlNodeSetName'/>
     <exports symbol='xmlAddChild'/>
     <exports symbol='xmlAddChildList'/>
     <exports symbol='xmlReplaceNode'/>
     <exports symbol='xmlAddSibling'/>
     <exports symbol='xmlAddPrevSibling'/>
     <exports symbol='xmlAddNextSibling'/>
     <exports symbol='xmlUnlinkNode'/>
     <exports symbol='xmlTextMerge'/>
     <exports symbol='xmlTextConcat'/>
     <exports symbol='xmlFreeNodeList'/>
     <exports symbol='xmlFreeNode'/>
     <exports symbol='xmlSetTreeDoc'/>
     <exports symbol='xmlSetListDoc'/>
     <exports symbol='xmlSearchNs'/>
     <exports symbol='xmlSearchNsByHref'/>
     <exports symbol='xmlGetNsList'/>
     <exports symbol='xmlSetNs'/>
     <exports symbol='xmlCopyNamespace'/>
     <exports symbol='xmlCopyNamespaceList'/>
     <exports symbol='xmlSetProp'/>
     <exports symbol='xmlGetProp'/>
     <exports symbol='xmlHasProp'/>
     <exports symbol='xmlHasNsProp'/>
     <exports symbol='xmlSetNsProp'/>
     <exports symbol='xmlGetNsProp'/>
     <exports symbol='xmlStringGetNodeList'/>
     <exports symbol='xmlStringLenGetNodeList'/>
     <exports symbol='xmlNodeListGetString'/>
     <exports symbol='xmlNodeListGetRawString'/>
     <exports symbol='xmlNodeSetContent'/>
     <exports symbol='xmlNodeSetContentLen'/>
     <exports symbol='xmlNodeAddContent'/>
     <exports symbol='xmlNodeAddContentLen'/>
     <exports symbol='xmlNodeGetContent'/>
     <exports symbol='xmlNodeGetLang'/>
     <exports symbol='xmlNodeSetLang'/>
     <exports symbol='xmlNodeGetSpacePreserve'/>
     <exports symbol='xmlNodeSetSpacePreserve'/>
     <exports symbol='xmlNodeGetBase'/>
     <exports symbol='xmlNodeSetBase'/>
     <exports symbol='xmlRemoveProp'/>
     <exports symbol='xmlUnsetProp'/>
     <exports symbol='xmlUnsetNsProp'/>
     <exports symbol='xmlBufferWriteXmlCHAR'/>
     <exports symbol='xmlBufferWriteCHAR'/>
     <exports symbol='xmlBufferWriteChar'/>
     <exports symbol='xmlBufferWriteQuotedString'/>
     <exports symbol='xmlReconciliateNs'/>
     <exports symbol='xmlDocDumpFormatMemory'/>
     <exports symbol='xmlDocDumpMemory'/>
     <exports symbol='xmlDocDumpMemoryEnc'/>
     <exports symbol='xmlDocDumpFormatMemoryEnc'/>
     <exports symbol='xmlDocFormatDump'/>
     <exports symbol='xmlDocDump'/>
     <exports symbol='xmlElemDump'/>
     <exports symbol='xmlSaveFile'/>
     <exports symbol='xmlSaveFormatFile'/>
     <exports symbol='xmlNodeDump'/>
     <exports symbol='xmlSaveFileTo'/>
     <exports symbol='xmlSaveFormatFileTo'/>
     <exports symbol='xmlNodeDumpOutput'/>
     <exports symbol='xmlSaveFormatFileEnc'/>
     <exports symbol='xmlSaveFileEnc'/>
     <exports symbol='xmlGetDocCompressMode'/>
     <exports symbol='xmlSetDocCompressMode'/>
     <exports symbol='xmlGetCompressMode'/>
     <exports symbol='xmlSetCompressMode'/>
    </file>
    <file name='xmlunicode'>
     <exports symbol='xmlUCSIsAlphabeticPresentationForms'/>
     <exports symbol='xmlUCSIsArabic'/>
     <exports symbol='xmlUCSIsArabicPresentationFormsA'/>
     <exports symbol='xmlUCSIsArabicPresentationFormsB'/>
     <exports symbol='xmlUCSIsArmenian'/>
     <exports symbol='xmlUCSIsArrows'/>
     <exports symbol='xmlUCSIsBasicLatin'/>
     <exports symbol='xmlUCSIsBengali'/>
     <exports symbol='xmlUCSIsBlockElements'/>
     <exports symbol='xmlUCSIsBopomofo'/>
     <exports symbol='xmlUCSIsBopomofoExtended'/>
     <exports symbol='xmlUCSIsBoxDrawing'/>
     <exports symbol='xmlUCSIsBraillePatterns'/>
     <exports symbol='xmlUCSIsByzantineMusicalSymbols'/>
     <exports symbol='xmlUCSIsCJKCompatibility'/>
     <exports symbol='xmlUCSIsCJKCompatibilityForms'/>
     <exports symbol='xmlUCSIsCJKCompatibilityIdeographs'/>
     <exports symbol='xmlUCSIsCJKCompatibilityIdeographsSupplement'/>
     <exports symbol='xmlUCSIsCJKRadicalsSupplement'/>
     <exports symbol='xmlUCSIsCJKSymbolsandPunctuation'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographs'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographsExtensionA'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographsExtensionB'/>
     <exports symbol='xmlUCSIsCherokee'/>
     <exports symbol='xmlUCSIsCombiningDiacriticalMarks'/>
     <exports symbol='xmlUCSIsCombiningHalfMarks'/>
     <exports symbol='xmlUCSIsCombiningMarksforSymbols'/>
     <exports symbol='xmlUCSIsControlPictures'/>
     <exports symbol='xmlUCSIsCurrencySymbols'/>
     <exports symbol='xmlUCSIsCyrillic'/>
     <exports symbol='xmlUCSIsDeseret'/>
     <exports symbol='xmlUCSIsDevanagari'/>
     <exports symbol='xmlUCSIsDingbats'/>
     <exports symbol='xmlUCSIsEnclosedAlphanumerics'/>
     <exports symbol='xmlUCSIsEnclosedCJKLettersandMonths'/>
     <exports symbol='xmlUCSIsEthiopic'/>
     <exports symbol='xmlUCSIsGeneralPunctuation'/>
     <exports symbol='xmlUCSIsGeometricShapes'/>
     <exports symbol='xmlUCSIsGeorgian'/>
     <exports symbol='xmlUCSIsGothic'/>
     <exports symbol='xmlUCSIsGreek'/>
     <exports symbol='xmlUCSIsGreekExtended'/>
     <exports symbol='xmlUCSIsGujarati'/>
     <exports symbol='xmlUCSIsGurmukhi'/>
     <exports symbol='xmlUCSIsHalfwidthandFullwidthForms'/>
     <exports symbol='xmlUCSIsHangulCompatibilityJamo'/>
     <exports symbol='xmlUCSIsHangulJamo'/>
     <exports symbol='xmlUCSIsHangulSyllables'/>
     <exports symbol='xmlUCSIsHebrew'/>
     <exports symbol='xmlUCSIsHighPrivateUseSurrogates'/>
     <exports symbol='xmlUCSIsHighSurrogates'/>
     <exports symbol='xmlUCSIsHiragana'/>
     <exports symbol='xmlUCSIsIPAExtensions'/>
     <exports symbol='xmlUCSIsIdeographicDescriptionCharacters'/>
     <exports symbol='xmlUCSIsKanbun'/>
     <exports symbol='xmlUCSIsKangxiRadicals'/>
     <exports symbol='xmlUCSIsKannada'/>
     <exports symbol='xmlUCSIsKatakana'/>
     <exports symbol='xmlUCSIsKhmer'/>
     <exports symbol='xmlUCSIsLao'/>
     <exports symbol='xmlUCSIsLatin1Supplement'/>
     <exports symbol='xmlUCSIsLatinExtendedA'/>
     <exports symbol='xmlUCSIsLatinExtendedB'/>
     <exports symbol='xmlUCSIsLatinExtendedAdditional'/>
     <exports symbol='xmlUCSIsLetterlikeSymbols'/>
     <exports symbol='xmlUCSIsLowSurrogates'/>
     <exports symbol='xmlUCSIsMalayalam'/>
     <exports symbol='xmlUCSIsMathematicalAlphanumericSymbols'/>
     <exports symbol='xmlUCSIsMathematicalOperators'/>
     <exports symbol='xmlUCSIsMiscellaneousSymbols'/>
     <exports symbol='xmlUCSIsMiscellaneousTechnical'/>
     <exports symbol='xmlUCSIsMongolian'/>
     <exports symbol='xmlUCSIsMusicalSymbols'/>
     <exports symbol='xmlUCSIsMyanmar'/>
     <exports symbol='xmlUCSIsNumberForms'/>
     <exports symbol='xmlUCSIsOgham'/>
     <exports symbol='xmlUCSIsOldItalic'/>
     <exports symbol='xmlUCSIsOpticalCharacterRecognition'/>
     <exports symbol='xmlUCSIsOriya'/>
     <exports symbol='xmlUCSIsPrivateUse'/>
     <exports symbol='xmlUCSIsRunic'/>
     <exports symbol='xmlUCSIsSinhala'/>
     <exports symbol='xmlUCSIsSmallFormVariants'/>
     <exports symbol='xmlUCSIsSpacingModifierLetters'/>
     <exports symbol='xmlUCSIsSpecials'/>
     <exports symbol='xmlUCSIsSuperscriptsandSubscripts'/>
     <exports symbol='xmlUCSIsSyriac'/>
     <exports symbol='xmlUCSIsTags'/>
     <exports symbol='xmlUCSIsTamil'/>
     <exports symbol='xmlUCSIsTelugu'/>
     <exports symbol='xmlUCSIsThaana'/>
     <exports symbol='xmlUCSIsThai'/>
     <exports symbol='xmlUCSIsTibetan'/>
     <exports symbol='xmlUCSIsUnifiedCanadianAboriginalSyllabics'/>
     <exports symbol='xmlUCSIsYiRadicals'/>
     <exports symbol='xmlUCSIsYiSyllables'/>
     <exports symbol='xmlUCSIsBlock'/>
     <exports symbol='xmlUCSIsCatC'/>
     <exports symbol='xmlUCSIsCatCc'/>
     <exports symbol='xmlUCSIsCatCf'/>
     <exports symbol='xmlUCSIsCatCo'/>
     <exports symbol='xmlUCSIsCatCs'/>
     <exports symbol='xmlUCSIsCatL'/>
     <exports symbol='xmlUCSIsCatLl'/>
     <exports symbol='xmlUCSIsCatLm'/>
     <exports symbol='xmlUCSIsCatLo'/>
     <exports symbol='xmlUCSIsCatLt'/>
     <exports symbol='xmlUCSIsCatLu'/>
     <exports symbol='xmlUCSIsCatM'/>
     <exports symbol='xmlUCSIsCatMc'/>
     <exports symbol='xmlUCSIsCatMe'/>
     <exports symbol='xmlUCSIsCatMn'/>
     <exports symbol='xmlUCSIsCatN'/>
     <exports symbol='xmlUCSIsCatNd'/>
     <exports symbol='xmlUCSIsCatNl'/>
     <exports symbol='xmlUCSIsCatNo'/>
     <exports symbol='xmlUCSIsCatP'/>
     <exports symbol='xmlUCSIsCatPc'/>
     <exports symbol='xmlUCSIsCatPd'/>
     <exports symbol='xmlUCSIsCatPe'/>
     <exports symbol='xmlUCSIsCatPf'/>
     <exports symbol='xmlUCSIsCatPi'/>
     <exports symbol='xmlUCSIsCatPo'/>
     <exports symbol='xmlUCSIsCatPs'/>
     <exports symbol='xmlUCSIsCatS'/>
     <exports symbol='xmlUCSIsCatSc'/>
     <exports symbol='xmlUCSIsCatSk'/>
     <exports symbol='xmlUCSIsCatSm'/>
     <exports symbol='xmlUCSIsCatSo'/>
     <exports symbol='xmlUCSIsCatZ'/>
     <exports symbol='xmlUCSIsCatZl'/>
     <exports symbol='xmlUCSIsCatZp'/>
     <exports symbol='xmlUCSIsCatZs'/>
     <exports symbol='xmlUCSIsCat'/>
    </file>
    <file name='encoding'>
     <exports symbol='xmlCharEncoding'/>
     <exports symbol='xmlCharEncodingInputFunc'/>
     <exports symbol='xmlCharEncodingOutputFunc'/>
     <exports symbol='xmlCharEncodingHandler'/>
     <exports symbol='xmlCharEncodingHandlerPtr'/>
     <exports symbol='xmlInitCharEncodingHandlers'/>
     <exports symbol='xmlCleanupCharEncodingHandlers'/>
     <exports symbol='xmlRegisterCharEncodingHandler'/>
     <exports symbol='xmlGetCharEncodingHandler'/>
     <exports symbol='xmlFindCharEncodingHandler'/>
     <exports symbol='xmlNewCharEncodingHandler'/>
     <exports symbol='xmlAddEncodingAlias'/>
     <exports symbol='xmlDelEncodingAlias'/>
     <exports symbol='xmlGetEncodingAlias'/>
     <exports symbol='xmlCleanupEncodingAliases'/>
     <exports symbol='xmlParseCharEncoding'/>
     <exports symbol='xmlGetCharEncodingName'/>
     <exports symbol='xmlDetectCharEncoding'/>
     <exports symbol='xmlCharEncOutFunc'/>
     <exports symbol='xmlCharEncInFunc'/>
     <exports symbol='xmlCharEncFirstLine'/>
     <exports symbol='xmlCharEncCloseFunc'/>
     <exports symbol='UTF8Toisolat1'/>
     <exports symbol='isolat1ToUTF8'/>
     <exports symbol='xmlCheckUTF8'/>
     <exports symbol='xmlUTF8Strsize'/>
     <exports symbol='xmlUTF8Strndup'/>
     <exports symbol='xmlUTF8Strpos'/>
     <exports symbol='xmlUTF8Strloc'/>
     <exports symbol='xmlUTF8Strsub'/>
     <exports symbol='xmlUTF8Strlen'/>
    </file>
    <file name='HTMLtree'>
     <exports symbol='HTML_TEXT_NODE'/>
     <exports symbol='HTML_ENTITY_REF_NODE'/>
     <exports symbol='HTML_COMMENT_NODE'/>
     <exports symbol='HTML_PRESERVE_NODE'/>
     <exports symbol='HTML_PI_NODE'/>
     <exports symbol='htmlNewDoc'/>
     <exports symbol='htmlNewDocNoDtD'/>
     <exports symbol='htmlGetMetaEncoding'/>
     <exports symbol='htmlSetMetaEncoding'/>
     <exports symbol='htmlDocDumpMemory'/>
     <exports symbol='htmlDocDump'/>
     <exports symbol='htmlSaveFile'/>
     <exports symbol='htmlNodeDump'/>
     <exports symbol='htmlNodeDumpFile'/>
     <exports symbol='htmlNodeDumpFileFormat'/>
     <exports symbol='htmlSaveFileEnc'/>
     <exports symbol='htmlSaveFileFormat'/>
     <exports symbol='htmlNodeDumpFormatOutput'/>
     <exports symbol='htmlDocContentDumpOutput'/>
     <exports symbol='htmlDocContentDumpFormatOutput'/>
     <exports symbol='htmlIsBooleanAttr'/>
    </file>
    <file name='c14n'>
     <exports symbol='xmlC14NDocSaveTo'/>
     <exports symbol='xmlC14NDocDumpMemory'/>
     <exports symbol='xmlC14NDocSave'/>
     <exports symbol='xmlC14NIsVisibleCallback'/>
     <exports symbol='xmlC14NExecute'/>
    </file>
    <file name='xpathInternals'>
     <exports symbol='xmlXPathSetError'/>
     <exports symbol='xmlXPathSetArityError'/>
     <exports symbol='xmlXPathSetTypeError'/>
     <exports symbol='xmlXPathGetError'/>
     <exports symbol='xmlXPathCheckError'/>
     <exports symbol='xmlXPathGetDocument'/>
     <exports symbol='xmlXPathGetContextNode'/>
     <exports symbol='xmlXPathPopBoolean'/>
     <exports symbol='xmlXPathPopNumber'/>
     <exports symbol='xmlXPathPopString'/>
     <exports symbol='xmlXPathPopNodeSet'/>
     <exports symbol='xmlXPathPopExternal'/>
     <exports symbol='xmlXPathReturnBoolean'/>
     <exports symbol='xmlXPathReturnTrue'/>
     <exports symbol='xmlXPathReturnFalse'/>
     <exports symbol='xmlXPathReturnNumber'/>
     <exports symbol='xmlXPathReturnString'/>
     <exports symbol='xmlXPathReturnEmptyString'/>
     <exports symbol='xmlXPathReturnNodeSet'/>
     <exports symbol='xmlXPathReturnEmptyNodeSet'/>
     <exports symbol='xmlXPathReturnExternal'/>
     <exports symbol='xmlXPathStackIsNodeSet'/>
     <exports symbol='xmlXPathStackIsExternal'/>
     <exports symbol='xmlXPathEmptyNodeSet'/>
     <exports symbol='CHECK_ERROR'/>
     <exports symbol='CHECK_ERROR0'/>
     <exports symbol='XP_ERROR'/>
     <exports symbol='XP_ERROR0'/>
     <exports symbol='CHECK_TYPE'/>
     <exports symbol='CHECK_TYPE0'/>
     <exports symbol='CHECK_ARITY'/>
     <exports symbol='CAST_TO_STRING'/>
     <exports symbol='CAST_TO_NUMBER'/>
     <exports symbol='CAST_TO_BOOLEAN'/>
     <exports symbol='xmlXPathVariableLookupFunc'/>
     <exports symbol='xmlXPathRegisterVariableLookup'/>
     <exports symbol='xmlXPathFuncLookupFunc'/>
     <exports symbol='xmlXPathRegisterFuncLookup'/>
     <exports symbol='xmlXPatherror'/>
     <exports symbol='xmlXPathDebugDumpObject'/>
     <exports symbol='xmlXPathDebugDumpCompExpr'/>
     <exports symbol='xmlXPathNodeSetContains'/>
     <exports symbol='xmlXPathDifference'/>
     <exports symbol='xmlXPathIntersection'/>
     <exports symbol='xmlXPathDistinctSorted'/>
     <exports symbol='xmlXPathDistinct'/>
     <exports symbol='xmlXPathHasSameNodes'/>
     <exports symbol='xmlXPathNodeLeadingSorted'/>
     <exports symbol='xmlXPathLeadingSorted'/>
     <exports symbol='xmlXPathNodeLeading'/>
     <exports symbol='xmlXPathLeading'/>
     <exports symbol='xmlXPathNodeTrailingSorted'/>
     <exports symbol='xmlXPathTrailingSorted'/>
     <exports symbol='xmlXPathNodeTrailing'/>
     <exports symbol='xmlXPathTrailing'/>
     <exports symbol='xmlXPathRegisterNs'/>
     <exports symbol='xmlXPathNsLookup'/>
     <exports symbol='xmlXPathRegisteredNsCleanup'/>
     <exports symbol='xmlXPathRegisterFunc'/>
     <exports symbol='xmlXPathRegisterFuncNS'/>
     <exports symbol='xmlXPathRegisterVariable'/>
     <exports symbol='xmlXPathRegisterVariableNS'/>
     <exports symbol='xmlXPathFunctionLookup'/>
     <exports symbol='xmlXPathFunctionLookupNS'/>
     <exports symbol='xmlXPathRegisteredFuncsCleanup'/>
     <exports symbol='xmlXPathVariableLookup'/>
     <exports symbol='xmlXPathVariableLookupNS'/>
     <exports symbol='xmlXPathRegisteredVariablesCleanup'/>
     <exports symbol='xmlXPathNewParserContext'/>
     <exports symbol='xmlXPathFreeParserContext'/>
     <exports symbol='valuePop'/>
     <exports symbol='valuePush'/>
     <exports symbol='xmlXPathNewString'/>
     <exports symbol='xmlXPathNewCString'/>
     <exports symbol='xmlXPathWrapString'/>
     <exports symbol='xmlXPathWrapCString'/>
     <exports symbol='xmlXPathNewFloat'/>
     <exports symbol='xmlXPathNewBoolean'/>
     <exports symbol='xmlXPathNewNodeSet'/>
     <exports symbol='xmlXPathNewValueTree'/>
     <exports symbol='xmlXPathNodeSetAdd'/>
     <exports symbol='xmlXPathNodeSetAddUnique'/>
     <exports symbol='xmlXPathNodeSetAddNs'/>
     <exports symbol='xmlXPathNodeSetSort'/>
     <exports symbol='xmlXPathRoot'/>
     <exports symbol='xmlXPathEvalExpr'/>
     <exports symbol='xmlXPathParseName'/>
     <exports symbol='xmlXPathParseNCName'/>
     <exports symbol='xmlXPathStringEvalNumber'/>
     <exports symbol='xmlXPathEvaluatePredicateResult'/>
     <exports symbol='xmlXPathRegisterAllFunctions'/>
     <exports symbol='xmlXPathNodeSetMerge'/>
     <exports symbol='xmlXPathNodeSetDel'/>
     <exports symbol='xmlXPathNodeSetRemove'/>
     <exports symbol='xmlXPathNewNodeSetList'/>
     <exports symbol='xmlXPathWrapNodeSet'/>
     <exports symbol='xmlXPathWrapExternal'/>
     <exports symbol='xmlXPathEqualValues'/>
     <exports symbol='xmlXPathNotEqualValues'/>
     <exports symbol='xmlXPathCompareValues'/>
     <exports symbol='xmlXPathValueFlipSign'/>
     <exports symbol='xmlXPathAddValues'/>
     <exports symbol='xmlXPathSubValues'/>
     <exports symbol='xmlXPathMultValues'/>
     <exports symbol='xmlXPathDivValues'/>
     <exports symbol='xmlXPathModValues'/>
     <exports symbol='xmlXPathIsNodeType'/>
     <exports symbol='xmlXPathNextSelf'/>
     <exports symbol='xmlXPathNextChild'/>
     <exports symbol='xmlXPathNextDescendant'/>
     <exports symbol='xmlXPathNextDescendantOrSelf'/>
     <exports symbol='xmlXPathNextParent'/>
     <exports symbol='xmlXPathNextAncestorOrSelf'/>
     <exports symbol='xmlXPathNextFollowingSibling'/>
     <exports symbol='xmlXPathNextFollowing'/>
     <exports symbol='xmlXPathNextNamespace'/>
     <exports symbol='xmlXPathNextAttribute'/>
     <exports symbol='xmlXPathNextPreceding'/>
     <exports symbol='xmlXPathNextAncestor'/>
     <exports symbol='xmlXPathNextPrecedingSibling'/>
     <exports symbol='xmlXPathLastFunction'/>
     <exports symbol='xmlXPathPositionFunction'/>
     <exports symbol='xmlXPathCountFunction'/>
     <exports symbol='xmlXPathIdFunction'/>
     <exports symbol='xmlXPathLocalNameFunction'/>
     <exports symbol='xmlXPathNamespaceURIFunction'/>
     <exports symbol='xmlXPathStringFunction'/>
     <exports symbol='xmlXPathStringLengthFunction'/>
     <exports symbol='xmlXPathConcatFunction'/>
     <exports symbol='xmlXPathContainsFunction'/>
     <exports symbol='xmlXPathStartsWithFunction'/>
     <exports symbol='xmlXPathSubstringFunction'/>
     <exports symbol='xmlXPathSubstringBeforeFunction'/>
     <exports symbol='xmlXPathSubstringAfterFunction'/>
     <exports symbol='xmlXPathNormalizeFunction'/>
     <exports symbol='xmlXPathTranslateFunction'/>
     <exports symbol='xmlXPathNotFunction'/>
     <exports symbol='xmlXPathTrueFunction'/>
     <exports symbol='xmlXPathFalseFunction'/>
     <exports symbol='xmlXPathLangFunction'/>
     <exports symbol='xmlXPathNumberFunction'/>
     <exports symbol='xmlXPathSumFunction'/>
     <exports symbol='xmlXPathFloorFunction'/>
     <exports symbol='xmlXPathCeilingFunction'/>
     <exports symbol='xmlXPathRoundFunction'/>
     <exports symbol='xmlXPathBooleanFunction'/>
     <exports symbol='xmlXPathNodeSetFreeNs'/>
    </file>
    <file name='xinclude'>
     <exports symbol='xmlXIncludeProcess'/>
    </file>
    <file name='schemasInternals'>
     <exports symbol='xmlSchemaTypeType'/>
     <exports symbol='xmlSchemaContentType'/>
     <exports symbol='xmlSchemaVal'/>
     <exports symbol='xmlSchemaValPtr'/>
     <exports symbol='xmlSchemaType'/>
     <exports symbol='xmlSchemaTypePtr'/>
     <exports symbol='xmlSchemaFacet'/>
     <exports symbol='xmlSchemaFacetPtr'/>
     <exports symbol='xmlSchemaAnnot'/>
     <exports symbol='xmlSchemaAnnotPtr'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_SKIP'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_LAX'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_STRICT'/>
     <exports symbol='xmlSchemaAttribute'/>
     <exports symbol='xmlSchemaAttributePtr'/>
     <exports symbol='xmlSchemaAttributeGroup'/>
     <exports symbol='xmlSchemaAttributeGroupPtr'/>
     <exports symbol='XML_SCHEMAS_TYPE_MIXED'/>
     <exports symbol='XML_SCHEMAS_ELEM_NILLABLE'/>
     <exports symbol='XML_SCHEMAS_ELEM_GLOBAL'/>
     <exports symbol='XML_SCHEMAS_ELEM_DEFAULT'/>
     <exports symbol='XML_SCHEMAS_ELEM_FIXED'/>
     <exports symbol='XML_SCHEMAS_ELEM_ABSTRACT'/>
     <exports symbol='XML_SCHEMAS_ELEM_TOPLEVEL'/>
     <exports symbol='XML_SCHEMAS_ELEM_REF'/>
     <exports symbol='xmlSchemaElement'/>
     <exports symbol='xmlSchemaElementPtr'/>
     <exports symbol='XML_SCHEMAS_FACET_UNKNOWN'/>
     <exports symbol='XML_SCHEMAS_FACET_PRESERVE'/>
     <exports symbol='XML_SCHEMAS_FACET_REPLACE'/>
     <exports symbol='XML_SCHEMAS_FACET_COLLAPSE'/>
     <exports symbol='xmlSchemaNotation'/>
     <exports symbol='xmlSchemaNotationPtr'/>
     <exports symbol='XML_SCHEMAS_QUALIF_ELEM'/>
     <exports symbol='XML_SCHEMAS_QUALIF_ATTR'/>
     <exports symbol='xmlSchema'/>
     <exports symbol='xmlSchemaFreeType'/>
    </file>
    <file name='xpath'>
     <exports symbol='xmlXPathContext'/>
     <exports symbol='xmlXPathContextPtr'/>
     <exports symbol='xmlXPathParserContext'/>
     <exports symbol='xmlXPathParserContextPtr'/>
     <exports symbol='xmlXPathError'/>
     <exports symbol='xmlNodeSet'/>
     <exports symbol='xmlNodeSetPtr'/>
     <exports symbol='xmlXPathObjectType'/>
     <exports symbol='xmlXPathObject'/>
     <exports symbol='xmlXPathObjectPtr'/>
     <exports symbol='xmlXPathConvertFunc'/>
     <exports symbol='xmlXPathType'/>
     <exports symbol='xmlXPathTypePtr'/>
     <exports symbol='xmlXPathVariable'/>
     <exports symbol='xmlXPathVariablePtr'/>
     <exports symbol='xmlXPathEvalFunc'/>
     <exports symbol='xmlXPathFunct'/>
     <exports symbol='xmlXPathFuncPtr'/>
     <exports symbol='xmlXPathAxisFunc'/>
     <exports symbol='xmlXPathAxis'/>
     <exports symbol='xmlXPathAxisPtr'/>
     <exports symbol='xmlXPathCompExpr'/>
     <exports symbol='xmlXPathCompExprPtr'/>
     <exports symbol='xmlXPathFunction'/>
     <exports symbol='xmlXPathIsNaN'/>
     <exports symbol='xmlXPathIsInf'/>
     <exports symbol='xmlXPathNodeSetGetLength'/>
     <exports symbol='xmlXPathNodeSetItem'/>
     <exports symbol='xmlXPathNodeSetIsEmpty'/>
     <exports symbol='xmlXPathFreeObject'/>
     <exports symbol='xmlXPathNodeSetCreate'/>
     <exports symbol='xmlXPathFreeNodeSetList'/>
     <exports symbol='xmlXPathFreeNodeSet'/>
     <exports symbol='xmlXPathObjectCopy'/>
     <exports symbol='xmlXPathCmpNodes'/>
     <exports symbol='xmlXPathCastNumberToBoolean'/>
     <exports symbol='xmlXPathCastStringToBoolean'/>
     <exports symbol='xmlXPathCastNodeSetToBoolean'/>
     <exports symbol='xmlXPathCastToBoolean'/>
     <exports symbol='xmlXPathCastBooleanToNumber'/>
     <exports symbol='xmlXPathCastStringToNumber'/>
     <exports symbol='xmlXPathCastNodeToNumber'/>
     <exports symbol='xmlXPathCastNodeSetToNumber'/>
     <exports symbol='xmlXPathCastToNumber'/>
     <exports symbol='xmlXPathCastBooleanToString'/>
     <exports symbol='xmlXPathCastNumberToString'/>
     <exports symbol='xmlXPathCastNodeToString'/>
     <exports symbol='xmlXPathCastNodeSetToString'/>
     <exports symbol='xmlXPathCastToString'/>
     <exports symbol='xmlXPathConvertBoolean'/>
     <exports symbol='xmlXPathConvertNumber'/>
     <exports symbol='xmlXPathConvertString'/>
     <exports symbol='xmlXPathInit'/>
     <exports symbol='xmlXPathNewContext'/>
     <exports symbol='xmlXPathFreeContext'/>
     <exports symbol='xmlXPathEval'/>
     <exports symbol='xmlXPathEvalExpression'/>
     <exports symbol='xmlXPathEvalPredicate'/>
     <exports symbol='xmlXPathCompile'/>
     <exports symbol='xmlXPathCompiledEval'/>
     <exports symbol='xmlXPathFreeCompExpr'/>
    </file>
    <file name='xpointer'>
     <exports symbol='xmlLocationSet'/>
     <exports symbol='xmlLocationSetPtr'/>
     <exports symbol='xmlXPtrLocationSetCreate'/>
     <exports symbol='xmlXPtrFreeLocationSet'/>
     <exports symbol='xmlXPtrLocationSetMerge'/>
     <exports symbol='xmlXPtrNewRange'/>
     <exports symbol='xmlXPtrNewRangePoints'/>
     <exports symbol='xmlXPtrNewRangeNodePoint'/>
     <exports symbol='xmlXPtrNewRangePointNode'/>
     <exports symbol='xmlXPtrNewRangeNodes'/>
     <exports symbol='xmlXPtrNewLocationSetNodes'/>
     <exports symbol='xmlXPtrNewLocationSetNodeSet'/>
     <exports symbol='xmlXPtrNewRangeNodeObject'/>
     <exports symbol='xmlXPtrNewCollapsedRange'/>
     <exports symbol='xmlXPtrLocationSetAdd'/>
     <exports symbol='xmlXPtrWrapLocationSet'/>
     <exports symbol='xmlXPtrLocationSetDel'/>
     <exports symbol='xmlXPtrLocationSetRemove'/>
     <exports symbol='xmlXPtrNewContext'/>
     <exports symbol='xmlXPtrEval'/>
     <exports symbol='xmlXPtrRangeToFunction'/>
     <exports symbol='xmlXPtrBuildNodeList'/>
     <exports symbol='xmlXPtrEvalRangePredicate'/>
    </file>
    <file name='threads'>
     <exports symbol='xmlMutex'/>
     <exports symbol='xmlMutexPtr'/>
     <exports symbol='xmlRMutex'/>
     <exports symbol='xmlRMutexPtr'/>
     <exports symbol='xmlNewMutex'/>
     <exports symbol='xmlMutexLock'/>
     <exports symbol='xmlMutexUnlock'/>
     <exports symbol='xmlFreeMutex'/>
     <exports symbol='xmlNewRMutex'/>
     <exports symbol='xmlRMutexLock'/>
     <exports symbol='xmlRMutexUnlock'/>
     <exports symbol='xmlFreeRMutex'/>
     <exports symbol='xmlInitThreads'/>
     <exports symbol='xmlLockLibrary'/>
     <exports symbol='xmlUnlockLibrary'/>
     <exports symbol='xmlGetThreadId'/>
     <exports symbol='xmlIsMainThread'/>
     <exports symbol='xmlCleanupThreads'/>
     <exports symbol='xmlGetGlobalState'/>
    </file>
    <file name='globals'>
     <exports symbol='xmlGlobalState'/>
     <exports symbol='xmlGlobalStatePtr'/>
     <exports symbol='xmlInitializeGlobalState'/>
     <exports symbol='xmlMalloc'/>
     <exports symbol='xmlRealloc'/>
     <exports symbol='xmlFree'/>
     <exports symbol='xmlMemStrdup'/>
     <exports symbol='docbDefaultSAXHandler'/>
     <exports symbol='htmlDefaultSAXHandler'/>
     <exports symbol='oldXMLWDcompatibility'/>
     <exports symbol='xmlBufferAllocScheme'/>
     <exports symbol='xmlDefaultBufferSize'/>
     <exports symbol='xmlDefaultSAXHandler'/>
     <exports symbol='xmlDefaultSAXLocator'/>
     <exports symbol='xmlDoValidityCheckingDefaultValue'/>
     <exports symbol='xmlGenericError'/>
     <exports symbol='xmlGenericErrorContext'/>
     <exports symbol='xmlGetWarningsDefaultValue'/>
     <exports symbol='xmlIndentTreeOutput'/>
     <exports symbol='xmlTreeIndentString'/>
     <exports symbol='xmlKeepBlanksDefaultValue'/>
     <exports symbol='xmlLineNumbersDefaultValue'/>
     <exports symbol='xmlLoadExtDtdDefaultValue'/>
     <exports symbol='xmlParserDebugEntities'/>
     <exports symbol='xmlParserVersion'/>
     <exports symbol='xmlPedanticParserDefaultValue'/>
     <exports symbol='xmlSaveNoEmptyTags'/>
     <exports symbol='xmlSubstituteEntitiesDefaultValue'/>
    </file>
    <file name='catalog'>
     <exports symbol='XML_CATALOGS_NAMESPACE'/>
     <exports symbol='XML_CATALOG_PI'/>
     <exports symbol='xmlCatalogPrefer'/>
     <exports symbol='xmlCatalogAllow'/>
     <exports symbol='xmlCatalog'/>
     <exports symbol='xmlCatalogPtr'/>
     <exports symbol='xmlNewCatalog'/>
     <exports symbol='xmlLoadACatalog'/>
     <exports symbol='xmlLoadSGMLSuperCatalog'/>
     <exports symbol='xmlConvertSGMLCatalog'/>
     <exports symbol='xmlACatalogAdd'/>
     <exports symbol='xmlACatalogRemove'/>
     <exports symbol='xmlACatalogResolve'/>
     <exports symbol='xmlACatalogResolveSystem'/>
     <exports symbol='xmlACatalogResolvePublic'/>
     <exports symbol='xmlACatalogResolveURI'/>
     <exports symbol='xmlACatalogDump'/>
     <exports symbol='xmlFreeCatalog'/>
     <exports symbol='xmlCatalogIsEmpty'/>
     <exports symbol='xmlInitializeCatalog'/>
     <exports symbol='xmlLoadCatalog'/>
     <exports symbol='xmlLoadCatalogs'/>
     <exports symbol='xmlCatalogCleanup'/>
     <exports symbol='xmlCatalogDump'/>
     <exports symbol='xmlCatalogResolve'/>
     <exports symbol='xmlCatalogResolveSystem'/>
     <exports symbol='xmlCatalogResolvePublic'/>
     <exports symbol='xmlCatalogResolveURI'/>
     <exports symbol='xmlCatalogAdd'/>
     <exports symbol='xmlCatalogRemove'/>
     <exports symbol='xmlParseCatalogFile'/>
     <exports symbol='xmlCatalogConvert'/>
     <exports symbol='xmlCatalogFreeLocal'/>
     <exports symbol='xmlCatalogAddLocal'/>
     <exports symbol='xmlCatalogLocalResolve'/>
     <exports symbol='xmlCatalogLocalResolveURI'/>
     <exports symbol='xmlCatalogSetDebug'/>
     <exports symbol='xmlCatalogSetDefaultPrefer'/>
     <exports symbol='xmlCatalogSetDefaults'/>
     <exports symbol='xmlCatalogGetDefaults'/>
     <exports symbol='xmlCatalogGetSystem'/>
     <exports symbol='xmlCatalogGetPublic'/>
    </file>
    <file name='parser'>
     <exports symbol='XML_DEFAULT_VERSION'/>
     <exports symbol='xmlParserInputDeallocate'/>
     <exports symbol='xmlParserInput'/>
     <exports symbol='xmlParserNodeInfo'/>
     <exports symbol='xmlParserNodeInfoPtr'/>
     <exports symbol='xmlParserNodeInfoSeq'/>
     <exports symbol='xmlParserNodeInfoSeqPtr'/>
     <exports symbol='xmlParserInputState'/>
     <exports symbol='XML_DETECT_IDS'/>
     <exports symbol='XML_COMPLETE_ATTRS'/>
     <exports symbol='xmlParserCtxt'/>
     <exports symbol='xmlSAXLocator'/>
     <exports symbol='resolveEntitySAXFunc'/>
     <exports symbol='internalSubsetSAXFunc'/>
     <exports symbol='externalSubsetSAXFunc'/>
     <exports symbol='getEntitySAXFunc'/>
     <exports symbol='getParameterEntitySAXFunc'/>
     <exports symbol='entityDeclSAXFunc'/>
     <exports symbol='notationDeclSAXFunc'/>
     <exports symbol='attributeDeclSAXFunc'/>
     <exports symbol='elementDeclSAXFunc'/>
     <exports symbol='unparsedEntityDeclSAXFunc'/>
     <exports symbol='setDocumentLocatorSAXFunc'/>
     <exports symbol='startDocumentSAXFunc'/>
     <exports symbol='endDocumentSAXFunc'/>
     <exports symbol='startElementSAXFunc'/>
     <exports symbol='endElementSAXFunc'/>
     <exports symbol='attributeSAXFunc'/>
     <exports symbol='referenceSAXFunc'/>
     <exports symbol='charactersSAXFunc'/>
     <exports symbol='ignorableWhitespaceSAXFunc'/>
     <exports symbol='processingInstructionSAXFunc'/>
     <exports symbol='commentSAXFunc'/>
     <exports symbol='cdataBlockSAXFunc'/>
     <exports symbol='warningSAXFunc'/>
     <exports symbol='errorSAXFunc'/>
     <exports symbol='fatalErrorSAXFunc'/>
     <exports symbol='isStandaloneSAXFunc'/>
     <exports symbol='hasInternalSubsetSAXFunc'/>
     <exports symbol='hasExternalSubsetSAXFunc'/>
     <exports symbol='xmlSAXHandler'/>
     <exports symbol='xmlExternalEntityLoader'/>
     <exports symbol='xmlSubstituteEntitiesDefaultValue'/>
     <exports symbol='xmlInitParser'/>
     <exports symbol='xmlCleanupParser'/>
     <exports symbol='xmlParserInputRead'/>
     <exports symbol='xmlParserInputGrow'/>
     <exports symbol='xmlStrdup'/>
     <exports symbol='xmlStrndup'/>
     <exports symbol='xmlCharStrndup'/>
     <exports symbol='xmlCharStrdup'/>
     <exports symbol='xmlStrsub'/>
     <exports symbol='xmlStrchr'/>
     <exports symbol='xmlStrstr'/>
     <exports symbol='xmlStrcasestr'/>
     <exports symbol='xmlStrcmp'/>
     <exports symbol='xmlStrncmp'/>
     <exports symbol='xmlStrcasecmp'/>
     <exports symbol='xmlStrncasecmp'/>
     <exports symbol='xmlStrEqual'/>
     <exports symbol='xmlStrlen'/>
     <exports symbol='xmlStrcat'/>
     <exports symbol='xmlStrncat'/>
     <exports symbol='xmlParseDoc'/>
     <exports symbol='xmlParseMemory'/>
     <exports symbol='xmlParseFile'/>
     <exports symbol='xmlSubstituteEntitiesDefault'/>
     <exports symbol='xmlKeepBlanksDefault'/>
     <exports symbol='xmlStopParser'/>
     <exports symbol='xmlPedanticParserDefault'/>
     <exports symbol='xmlLineNumbersDefault'/>
     <exports symbol='xmlRecoverDoc'/>
     <exports symbol='xmlRecoverMemory'/>
     <exports symbol='xmlRecoverFile'/>
     <exports symbol='xmlParseDocument'/>
     <exports symbol='xmlParseExtParsedEnt'/>
     <exports symbol='xmlSAXParseDoc'/>
     <exports symbol='xmlSAXUserParseFile'/>
     <exports symbol='xmlSAXUserParseMemory'/>
     <exports symbol='xmlSAXParseMemory'/>
     <exports symbol='xmlSAXParseFile'/>
     <exports symbol='xmlSAXParseFileWithData'/>
     <exports symbol='xmlSAXParseEntity'/>
     <exports symbol='xmlParseEntity'/>
     <exports symbol='xmlParseDTD'/>
     <exports symbol='xmlSAXParseDTD'/>
     <exports symbol='xmlIOParseDTD'/>
     <exports symbol='xmlParseBalancedChunkMemory'/>
     <exports symbol='xmlParseBalancedChunkMemoryRecover'/>
     <exports symbol='xmlParseExternalEntity'/>
     <exports symbol='xmlParseCtxtExternalEntity'/>
     <exports symbol='xmlInitParserCtxt'/>
     <exports symbol='xmlClearParserCtxt'/>
     <exports symbol='xmlFreeParserCtxt'/>
     <exports symbol='xmlSetupParserForBuffer'/>
     <exports symbol='xmlCreateDocParserCtxt'/>
     <exports symbol='xmlGetFeaturesList'/>
     <exports symbol='xmlGetFeature'/>
     <exports symbol='xmlSetFeature'/>
     <exports symbol='xmlCreatePushParserCtxt'/>
     <exports symbol='xmlParseChunk'/>
     <exports symbol='xmlCreateIOParserCtxt'/>
     <exports symbol='xmlNewIOInputStream'/>
     <exports symbol='xmlParserFindNodeInfo'/>
     <exports symbol='xmlInitNodeInfoSeq'/>
     <exports symbol='xmlClearNodeInfoSeq'/>
     <exports symbol='xmlParserFindNodeInfoIndex'/>
     <exports symbol='xmlParserAddNodeInfo'/>
     <exports symbol='xmlSetExternalEntityLoader'/>
     <exports symbol='xmlGetExternalEntityLoader'/>
     <exports symbol='xmlLoadExternalEntity'/>
    </file>
    <file name='xmlautomata'>
     <exports symbol='xmlAutomata'/>
     <exports symbol='xmlAutomataPtr'/>
     <exports symbol='xmlAutomataState'/>
     <exports symbol='xmlAutomataStatePtr'/>
     <exports symbol='xmlNewAutomata'/>
     <exports symbol='xmlFreeAutomata'/>
     <exports symbol='xmlAutomataGetInitState'/>
     <exports symbol='xmlAutomataSetFinalState'/>
     <exports symbol='xmlAutomataNewState'/>
     <exports symbol='xmlAutomataNewTransition'/>
     <exports symbol='xmlAutomataNewCountTrans'/>
     <exports symbol='xmlAutomataNewOnceTrans'/>
     <exports symbol='xmlAutomataNewAllTrans'/>
     <exports symbol='xmlAutomataNewEpsilon'/>
     <exports symbol='xmlAutomataNewCountedTrans'/>
     <exports symbol='xmlAutomataNewCounterTrans'/>
     <exports symbol='xmlAutomataNewCounter'/>
     <exports symbol='xmlAutomataCompile'/>
     <exports symbol='xmlAutomataIsDeterminist'/>
    </file>
    <file name='xmlerror'>
     <exports symbol='xmlParserErrors'/>
     <exports symbol='xmlGenericErrorFunc'/>
     <exports symbol='xmlSetGenericErrorFunc'/>
     <exports symbol='initGenericErrorDefaultFunc'/>
     <exports symbol='xmlParserError'/>
     <exports symbol='xmlParserWarning'/>
     <exports symbol='xmlParserValidityError'/>
     <exports symbol='xmlParserValidityWarning'/>
     <exports symbol='xmlParserPrintFileInfo'/>
     <exports symbol='xmlParserPrintFileContext'/>
    </file>
    <file name='xmlversion'>
     <exports symbol='xmlCheckVersion'/>
     <exports symbol='LIBXML_DOTTED_VERSION'/>
     <exports symbol='LIBXML_VERSION'/>
     <exports symbol='LIBXML_VERSION_STRING'/>
     <exports symbol='LIBXML_TEST_VERSION'/>
     <exports symbol='WITH_TRIO'/>
     <exports symbol='WITHOUT_TRIO'/>
     <exports symbol='LIBXML_THREAD_ENABLED'/>
     <exports symbol='LIBXML_FTP_ENABLED'/>
     <exports symbol='LIBXML_HTTP_ENABLED'/>
     <exports symbol='LIBXML_HTML_ENABLED'/>
     <exports symbol='LIBXML_C14N_ENABLED'/>
     <exports symbol='LIBXML_CATALOG_ENABLED'/>
     <exports symbol='LIBXML_DOCB_ENABLED'/>
     <exports symbol='LIBXML_XPATH_ENABLED'/>
     <exports symbol='LIBXML_XPTR_ENABLED'/>
     <exports symbol='LIBXML_XINCLUDE_ENABLED'/>
     <exports symbol='LIBXML_ICONV_ENABLED'/>
     <exports symbol='LIBXML_DEBUG_ENABLED'/>
     <exports symbol='DEBUG_MEMORY_LOCATION'/>
     <exports symbol='LIBXML_UNICODE_ENABLED'/>
     <exports symbol='LIBXML_REGEXP_ENABLED'/>
     <exports symbol='LIBXML_AUTOMATA_ENABLED'/>
     <exports symbol='LIBXML_SCHEMAS_ENABLED'/>
     <exports symbol='LIBXML_DLL_IMPORT'/>
     <exports symbol='ATTRIBUTE_UNUSED'/>
    </file>
    <file name='hash'>
     <exports symbol='xmlHashTable'/>
     <exports symbol='xmlHashTablePtr'/>
     <exports symbol='xmlHashDeallocator'/>
     <exports symbol='xmlHashCopier'/>
     <exports symbol='xmlHashScanner'/>
     <exports symbol='xmlHashScannerFull'/>
     <exports symbol='xmlHashCreate'/>
     <exports symbol='xmlHashFree'/>
     <exports symbol='xmlHashAddEntry'/>
     <exports symbol='xmlHashUpdateEntry'/>
     <exports symbol='xmlHashAddEntry2'/>
     <exports symbol='xmlHashUpdateEntry2'/>
     <exports symbol='xmlHashAddEntry3'/>
     <exports symbol='xmlHashUpdateEntry3'/>
     <exports symbol='xmlHashRemoveEntry'/>
     <exports symbol='xmlHashRemoveEntry2'/>
     <exports symbol='xmlHashRemoveEntry3'/>
     <exports symbol='xmlHashLookup'/>
     <exports symbol='xmlHashLookup2'/>
     <exports symbol='xmlHashLookup3'/>
     <exports symbol='xmlHashCopy'/>
     <exports symbol='xmlHashSize'/>
     <exports symbol='xmlHashScan'/>
     <exports symbol='xmlHashScan3'/>
     <exports symbol='xmlHashScanFull'/>
     <exports symbol='xmlHashScanFull3'/>
    </file>
    <file name='xmlIO'>
     <exports symbol='xmlInputMatchCallback'/>
     <exports symbol='xmlInputOpenCallback'/>
     <exports symbol='xmlInputReadCallback'/>
     <exports symbol='xmlInputCloseCallback'/>
     <exports symbol='xmlOutputMatchCallback'/>
     <exports symbol='xmlOutputOpenCallback'/>
     <exports symbol='xmlOutputWriteCallback'/>
     <exports symbol='xmlOutputCloseCallback'/>
     <exports symbol='xmlParserInputBuffer'/>
     <exports symbol='xmlOutputBuffer'/>
     <exports symbol='xmlCleanupInputCallbacks'/>
     <exports symbol='xmlCleanupOutputCallbacks'/>
     <exports symbol='xmlRegisterDefaultInputCallbacks'/>
     <exports symbol='xmlAllocParserInputBuffer'/>
     <exports symbol='xmlParserInputBufferCreateFname'/>
     <exports symbol='xmlParserInputBufferCreateFilename'/>
     <exports symbol='xmlParserInputBufferCreateFile'/>
     <exports symbol='xmlParserInputBufferCreateFd'/>
     <exports symbol='xmlParserInputBufferCreateMem'/>
     <exports symbol='xmlParserInputBufferCreateIO'/>
     <exports symbol='xmlParserInputBufferRead'/>
     <exports symbol='xmlParserInputBufferGrow'/>
     <exports symbol='xmlParserInputBufferPush'/>
     <exports symbol='xmlFreeParserInputBuffer'/>
     <exports symbol='xmlParserGetDirectory'/>
     <exports symbol='xmlRegisterInputCallbacks'/>
     <exports symbol='xmlRegisterDefaultOutputCallbacks'/>
     <exports symbol='xmlAllocOutputBuffer'/>
     <exports symbol='xmlOutputBufferCreateFilename'/>
     <exports symbol='xmlOutputBufferCreateFile'/>
     <exports symbol='xmlOutputBufferCreateFd'/>
     <exports symbol='xmlOutputBufferCreateIO'/>
     <exports symbol='xmlOutputBufferWrite'/>
     <exports symbol='xmlOutputBufferWriteString'/>
     <exports symbol='xmlOutputBufferFlush'/>
     <exports symbol='xmlOutputBufferClose'/>
     <exports symbol='xmlRegisterOutputCallbacks'/>
     <exports symbol='xmlIOHTTPOpenW'/>
     <exports symbol='xmlRegisterHTTPPostCallbacks'/>
     <exports symbol='xmlNoNetExternalEntityLoader'/>
     <exports symbol='xmlNormalizeWindowsPath'/>
     <exports symbol='xmlFileMatch'/>
     <exports symbol='xmlFileOpen'/>
     <exports symbol='xmlFileRead'/>
     <exports symbol='xmlFileClose'/>
     <exports symbol='xmlIOHTTPMatch'/>
     <exports symbol='xmlIOHTTPOpen'/>
     <exports symbol='xmlIOHTTPRead'/>
     <exports symbol='xmlIOHTTPClose'/>
     <exports symbol='xmlIOFTPMatch'/>
     <exports symbol='xmlIOFTPOpen'/>
     <exports symbol='xmlIOFTPRead'/>
     <exports symbol='xmlIOFTPClose'/>
    </file>
    <file name='debugXML'>
     <exports symbol='xmlDebugDumpString'/>
     <exports symbol='xmlDebugDumpAttr'/>
     <exports symbol='xmlDebugDumpAttrList'/>
     <exports symbol='xmlDebugDumpOneNode'/>
     <exports symbol='xmlDebugDumpNode'/>
     <exports symbol='xmlDebugDumpNodeList'/>
     <exports symbol='xmlDebugDumpDocumentHead'/>
     <exports symbol='xmlDebugDumpDocument'/>
     <exports symbol='xmlDebugDumpDTD'/>
     <exports symbol='xmlDebugDumpEntities'/>
     <exports symbol='xmlLsOneNode'/>
     <exports symbol='xmlLsCountNode'/>
     <exports symbol='xmlShellReadlineFunc'/>
     <exports symbol='xmlShellCtxt'/>
     <exports symbol='xmlShellCtxtPtr'/>
     <exports symbol='xmlShellCmd'/>
     <exports symbol='xmlShellPrintXPathError'/>
     <exports symbol='xmlShellPrintNode'/>
     <exports symbol='xmlShellPrintXPathResult'/>
     <exports symbol='xmlShellList'/>
     <exports symbol='xmlShellBase'/>
     <exports symbol='xmlShellDir'/>
     <exports symbol='xmlShellCat'/>
     <exports symbol='xmlShellLoad'/>
     <exports symbol='xmlShellWrite'/>
     <exports symbol='xmlShellSave'/>
     <exports symbol='xmlShellValidate'/>
     <exports symbol='xmlShellDu'/>
     <exports symbol='xmlShellPwd'/>
     <exports symbol='xmlShell'/>
    </file>
  </files>
  <symbols>
    <macro name='ATTRIBUTE_UNUSED' file='xmlversion'>
      <info>Macro used to signal to GCC unused function parameters</info>
    </macro>
    <macro name='BAD_CAST' file='tree'>
      <info>Macro to cast a string to an xmlChar * when one know its safe.</info>
    </macro>
    <macro name='BASE_BUFFER_SIZE' file='tree'>
      <info>default buffer size 4000.</info>
    </macro>
    <macro name='CAST_TO_BOOLEAN' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a boolean.</info>
    </macro>
    <macro name='CAST_TO_NUMBER' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a number.</info>
    </macro>
    <macro name='CAST_TO_STRING' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a string.</info>
    </macro>
    <macro name='CHECK_ARITY' file='xpathInternals'>
      <info>Macro to check that the number of args passed to an XPath function matches.</info>
      <arg name='x' info='the number of expected args '/>
    </macro>
    <macro name='CHECK_ERROR' file='xpathInternals'>
      <info>Macro to return from the function if an XPath error was detected.</info>
    </macro>
    <macro name='CHECK_ERROR0' file='xpathInternals'>
      <info>Macro to return 0 from the function if an XPath error was detected.</info>
    </macro>
    <macro name='CHECK_TYPE' file='xpathInternals'>
      <info>Macro to check that the value on top of the XPath stack is of a given type.</info>
      <arg name='typeval' info='the XPath type '/>
    </macro>
    <macro name='CHECK_TYPE0' file='xpathInternals'>
      <info>Macro to check that the value on top of the XPath stack is of a given type. Return(0) in case of failure</info>
      <arg name='typeval' info='the XPath type '/>
    </macro>
    <macro name='DEBUG_MEMORY' file='xmlmemory'>
      <info>DEBUG_MEMORY replaces the allocator with a collect and debug shell to the libc allocator. DEBUG_MEMORY should only be activated when debugging libxml i.e. if libxml has been configured with --with-debug-mem too.</info>
    </macro>
    <macro name='DEBUG_MEMORY_LOCATION' file='xmlversion'>
      <info>Whether the memory debugging is configured in</info>
    </macro>
    <macro name='HTML_COMMENT_NODE' file='HTMLtree'>
      <info>Macro. A comment in a HTML document is really implemented the same way as a comment in an XML document.</info>
    </macro>
    <macro name='HTML_ENTITY_REF_NODE' file='HTMLtree'>
      <info>Macro. An entity reference in a HTML document is really implemented the same way as an entity reference in an XML document.</info>
    </macro>
    <macro name='HTML_PI_NODE' file='HTMLtree'>
      <info>Macro. A processing instruction in a HTML document is really implemented the same way as a processing instruction in an XML document.</info>
    </macro>
    <macro name='HTML_PRESERVE_NODE' file='HTMLtree'>
      <info>Macro. A preserved node in a HTML document is really implemented the same way as a CDATA section in an XML document.</info>
    </macro>
    <macro name='HTML_TEXT_NODE' file='HTMLtree'>
      <info>Macro. A text node in a HTML document is really implemented the same way as a text node in an XML document.</info>
    </macro>
    <macro name='INPUT_CHUNK' file='parserInternals'>
      <info>The parser tries to always have that amount of input ready. One of the point is providing context when reporting errors.</info>
    </macro>
    <macro name='IS_BASECHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_BLANK' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_CHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_COMBINING' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_DIGIT' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_EXTENDER' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_IDEOGRAPHIC' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_LETTER' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='IS_PUBIDCHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec: </info>
      <arg name='c' info='an UNICODE value (int) '/>
    </macro>
    <macro name='LIBXML_AUTOMATA_ENABLED' file='xmlversion'>
      <info>Whether the automata interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_C14N_ENABLED' file='xmlversion'>
      <info>Whether the Canonicalization support is configured in</info>
    </macro>
    <macro name='LIBXML_CATALOG_ENABLED' file='xmlversion'>
      <info>Whether the Catalog support is configured in</info>
    </macro>
    <macro name='LIBXML_DEBUG_ENABLED' file='xmlversion'>
      <info>Whether Debugging module is configured in</info>
    </macro>
    <macro name='LIBXML_DLL_IMPORT' file='xmlversion'>
      <info>Used on Windows (MS C compiler only) to declare a variable as imported from the library. This macro should be empty when compiling libxml itself. It should expand to __declspec(dllimport) when the client code includes this header, and that only if the client links dynamically against libxml. For this to work, we need three macros. One tells us which compiler is being used and luckily the compiler defines such a thing: _MSC_VER. The second macro tells us if we are compiling libxml or the client code and we define the macro IN_LIBXML on the compiler&apos;s command line for this purpose. The third macro, LIBXML_STATIC, must be defined by any client code which links against libxml statically.</info>
    </macro>
    <macro name='LIBXML_DOCB_ENABLED' file='xmlversion'>
      <info>Whether the SGML Docbook support is configured in</info>
    </macro>
    <macro name='LIBXML_DOTTED_VERSION' file='xmlversion'>
      <info>the version string like &quot;1.2.3&quot;</info>
    </macro>
    <macro name='LIBXML_FTP_ENABLED' file='xmlversion'>
      <info>Whether the FTP support is configured in</info>
    </macro>
    <macro name='LIBXML_HTML_ENABLED' file='xmlversion'>
      <info>Whether the HTML support is configured in</info>
    </macro>
    <macro name='LIBXML_HTTP_ENABLED' file='xmlversion'>
      <info>Whether the HTTP support is configured in</info>
    </macro>
    <macro name='LIBXML_ICONV_ENABLED' file='xmlversion'>
      <info>Whether iconv support is available</info>
    </macro>
    <macro name='LIBXML_REGEXP_ENABLED' file='xmlversion'>
      <info>Whether the regular expressions interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_SCHEMAS_ENABLED' file='xmlversion'>
      <info>Whether the Schemas validation interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_TEST_VERSION' file='xmlversion'>
      <info>Macro to check that the libxml version in use is compatible with the version the software has been compiled against</info>
    </macro>
    <macro name='LIBXML_THREAD_ENABLED' file='xmlversion'>
      <info>Whether the thread support is configured in</info>
    </macro>
    <macro name='LIBXML_UNICODE_ENABLED' file='xmlversion'>
      <info>Whether the Unicode related interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_VERSION' file='xmlversion'>
      <info>the version number: 1.2.3 value is 1002003</info>
    </macro>
    <macro name='LIBXML_VERSION_STRING' file='xmlversion'>
      <info>the version number string, 1.2.3 value is &quot;1002003&quot;</info>
    </macro>
    <macro name='LIBXML_XINCLUDE_ENABLED' file='xmlversion'>
      <info>Whether XInclude is configured in</info>
    </macro>
    <macro name='LIBXML_XPATH_ENABLED' file='xmlversion'>
      <info>Whether XPath is configured in</info>
    </macro>
    <macro name='LIBXML_XPTR_ENABLED' file='xmlversion'>
      <info>Whether XPointer is configured in</info>
    </macro>
    <macro name='MOVETO_ENDTAG' file='parserInternals'>
      <info>Skips to the next &apos;&gt;&apos; char.</info>
      <arg name='p' info='and UTF8 string pointer '/>
    </macro>
    <macro name='MOVETO_STARTTAG' file='parserInternals'>
      <info>Skips to the next &apos;&lt;&apos; char.</info>
      <arg name='p' info='and UTF8 string pointer '/>
    </macro>
    <macro name='SKIP_EOL' file='parserInternals'>
      <info>Skips the end of line chars.</info>
      <arg name='p' info='and UTF8 string pointer '/>
    </macro>
    <function name='UTF8ToHtml' file='HTMLparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int' info='outlen after return is the number of octets consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars '/>
      <arg name='inlen' type='int *' info='in '/>
    </function>
    <function name='UTF8Toisolat1' file='encoding'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1 block of chars out.</info>
      <return type='int' info='outlen after return is the number of ocetes consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars '/>
      <arg name='inlen' type='int *' info='in '/>
    </function>
    <macro name='WITHOUT_TRIO' file='xmlversion'>
      <info>defined if the trio support should not be configured in</info>
    </macro>
    <macro name='WITH_TRIO' file='xmlversion'>
      <info>defined if the trio support need to be configured in</info>
    </macro>
    <const name='XML_ATTRIBUTE_CDATA' file='tree'/>
    <const name='XML_ATTRIBUTE_DECL' file='tree'/>
    <const name='XML_ATTRIBUTE_ENTITIES' file='tree'/>
    <const name='XML_ATTRIBUTE_ENTITY' file='tree'/>
    <const name='XML_ATTRIBUTE_ENUMERATION' file='tree'/>
    <const name='XML_ATTRIBUTE_FIXED' file='tree'/>
    <const name='XML_ATTRIBUTE_ID' file='tree'/>
    <const name='XML_ATTRIBUTE_IDREF' file='tree'/>
    <const name='XML_ATTRIBUTE_IDREFS' file='tree'/>
    <const name='XML_ATTRIBUTE_IMPLIED' file='tree'/>
    <const name='XML_ATTRIBUTE_NMTOKEN' file='tree'/>
    <const name='XML_ATTRIBUTE_NMTOKENS' file='tree'/>
    <const name='XML_ATTRIBUTE_NODE' file='tree'/>
    <const name='XML_ATTRIBUTE_NONE' file='tree'/>
    <const name='XML_ATTRIBUTE_NOTATION' file='tree'/>
    <const name='XML_ATTRIBUTE_REQUIRED' file='tree'/>
    <const name='XML_BUFFER_ALLOC_DOUBLEIT' file='tree'/>
    <const name='XML_BUFFER_ALLOC_EXACT' file='tree'/>
    <macro name='XML_CATALOGS_NAMESPACE' file='catalog'>
      <info>The namespace for the XML Catalogs elements.</info>
    </macro>
    <macro name='XML_CATALOG_PI' file='catalog'>
      <info>The specific XML Catalog Processing Instuction name.</info>
    </macro>
    <const name='XML_CATA_ALLOW_ALL' file='catalog'/>
    <const name='XML_CATA_ALLOW_DOCUMENT' file='catalog'/>
    <const name='XML_CATA_ALLOW_GLOBAL' file='catalog'/>
    <const name='XML_CATA_ALLOW_NONE' file='catalog'/>
    <const name='XML_CATA_PREFER_NONE' file='catalog'/>
    <const name='XML_CATA_PREFER_PUBLIC' file='catalog'/>
    <const name='XML_CATA_PREFER_SYSTEM' file='catalog'/>
    <const name='XML_CDATA_SECTION_NODE' file='tree'/>
    <const name='XML_CHAR_ENCODING_2022_JP' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_1' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_2' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_3' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_4' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_5' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_6' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_7' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_8' file='encoding'/>
    <const name='XML_CHAR_ENCODING_8859_9' file='encoding'/>
    <const name='XML_CHAR_ENCODING_ASCII' file='encoding'/>
    <const name='XML_CHAR_ENCODING_EBCDIC' file='encoding'/>
    <const name='XML_CHAR_ENCODING_ERROR' file='encoding'/>
    <const name='XML_CHAR_ENCODING_EUC_JP' file='encoding'/>
    <const name='XML_CHAR_ENCODING_NONE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_SHIFT_JIS' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS2' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4BE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4LE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4_2143' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UCS4_3412' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF16BE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF16LE' file='encoding'/>
    <const name='XML_CHAR_ENCODING_UTF8' file='encoding'/>
    <const name='XML_COMMENT_NODE' file='tree'/>
    <macro name='XML_COMPLETE_ATTRS' file='parser'>
      <info>Bit in the loadsubset context field to tell to do complete the elements attributes lists with the ones defaulted from the DTDs. Use it to initialize xmlLoadExtDtdDefaultValue.</info>
    </macro>
    <macro name='XML_DEFAULT_VERSION' file='parser'>
      <info>The default version of XML used: 1.0</info>
    </macro>
    <macro name='XML_DETECT_IDS' file='parser'>
      <info>Bit in the loadsubset context field to tell to do ID/REFs lookups. Use it to initialize xmlLoadExtDtdDefaultValue.</info>
    </macro>
    <const name='XML_DOCB_DOCUMENT_NODE' file='tree'/>
    <const name='XML_DOCUMENT_FRAG_NODE' file='tree'/>
    <const name='XML_DOCUMENT_NODE' file='tree'/>
    <const name='XML_DOCUMENT_TYPE_NODE' file='tree'/>
    <const name='XML_DTD_NODE' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_ELEMENT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_MULT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_ONCE' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_OPT' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_OR' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_PCDATA' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_PLUS' file='tree'/>
    <const name='XML_ELEMENT_CONTENT_SEQ' file='tree'/>
    <const name='XML_ELEMENT_DECL' file='tree'/>
    <const name='XML_ELEMENT_NODE' file='tree'/>
    <const name='XML_ELEMENT_TYPE_ANY' file='tree'/>
    <const name='XML_ELEMENT_TYPE_ELEMENT' file='tree'/>
    <const name='XML_ELEMENT_TYPE_EMPTY' file='tree'/>
    <const name='XML_ELEMENT_TYPE_MIXED' file='tree'/>
    <const name='XML_ELEMENT_TYPE_UNDEFINED' file='tree'/>
    <const name='XML_ENTITY_DECL' file='tree'/>
    <const name='XML_ENTITY_NODE' file='tree'/>
    <const name='XML_ENTITY_REF_NODE' file='tree'/>
    <const name='XML_ERR_ATTLIST_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ATTLIST_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_REDEFINED' file='xmlerror'/>
    <const name='XML_ERR_ATTRIBUTE_WITHOUT_VALUE' file='xmlerror'/>
    <const name='XML_ERR_CDATA_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_DTD' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_CHARREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_COMMENT_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_INVALID' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_CONDSEC_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_DOCTYPE_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_EMPTY' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_END' file='xmlerror'/>
    <const name='XML_ERR_DOCUMENT_START' file='xmlerror'/>
    <const name='XML_ERR_ELEMCONTENT_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ELEMCONTENT_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ENCODING_NAME' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_DTD' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_NO_NAME' file='xmlerror'/>
    <const name='XML_ERR_ENTITYREF_SEMICOL_MISSING' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_BOUNDARY' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_CHAR_ERROR' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_IS_EXTERNAL' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_IS_PARAMETER' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_LOOP' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_ENTITY_PE_INTERNAL' file='xmlerror'/>
    <const name='XML_ERR_EQUAL_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_EXTRA_CONTENT' file='xmlerror'/>
    <const name='XML_ERR_EXT_ENTITY_STANDALONE' file='xmlerror'/>
    <const name='XML_ERR_EXT_SUBSET_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_GT_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_HYPHEN_IN_COMMENT' file='xmlerror'/>
    <const name='XML_ERR_INTERNAL_ERROR' file='xmlerror'/>
    <const name='XML_ERR_INVALID_CHAR' file='xmlerror'/>
    <const name='XML_ERR_INVALID_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_DEC_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_INVALID_HEX_CHARREF' file='xmlerror'/>
    <const name='XML_ERR_INVALID_URI' file='xmlerror'/>
    <const name='XML_ERR_LITERAL_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_LITERAL_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_LTSLASH_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_LT_IN_ATTRIBUTE' file='xmlerror'/>
    <const name='XML_ERR_LT_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_MISPLACED_CDATA_END' file='xmlerror'/>
    <const name='XML_ERR_MIXED_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_MIXED_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_NAME_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_NMTOKEN_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_NOTATION_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_NOTATION_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_NOT_WELL_BALANCED' file='xmlerror'/>
    <const name='XML_ERR_NO_DTD' file='xmlerror'/>
    <const name='XML_ERR_NO_MEMORY' file='xmlerror'/>
    <const name='XML_ERR_NS_DECL_ERROR' file='xmlerror'/>
    <const name='XML_ERR_OK' file='xmlerror'/>
    <const name='XML_ERR_PCDATA_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_PEREF_AT_EOF' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_EPILOG' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_INT_SUBSET' file='xmlerror'/>
    <const name='XML_ERR_PEREF_IN_PROLOG' file='xmlerror'/>
    <const name='XML_ERR_PEREF_NO_NAME' file='xmlerror'/>
    <const name='XML_ERR_PEREF_SEMICOL_MISSING' file='xmlerror'/>
    <const name='XML_ERR_PI_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_PI_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_PUBID_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_RESERVED_XML_NAME' file='xmlerror'/>
    <const name='XML_ERR_SEPARATOR_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_SPACE_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_STANDALONE_VALUE' file='xmlerror'/>
    <const name='XML_ERR_STRING_NOT_CLOSED' file='xmlerror'/>
    <const name='XML_ERR_STRING_NOT_STARTED' file='xmlerror'/>
    <const name='XML_ERR_TAG_NAME_MISMATCH' file='xmlerror'/>
    <const name='XML_ERR_TAG_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_UNDECLARED_ENTITY' file='xmlerror'/>
    <const name='XML_ERR_UNKNOWN_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_UNPARSED_ENTITY' file='xmlerror'/>
    <const name='XML_ERR_UNSUPPORTED_ENCODING' file='xmlerror'/>
    <const name='XML_ERR_URI_FRAGMENT' file='xmlerror'/>
    <const name='XML_ERR_URI_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_VALUE_REQUIRED' file='xmlerror'/>
    <const name='XML_ERR_XMLDECL_NOT_FINISHED' file='xmlerror'/>
    <const name='XML_ERR_XMLDECL_NOT_STARTED' file='xmlerror'/>
    <const name='XML_EXTERNAL_GENERAL_PARSED_ENTITY' file='entities'/>
    <const name='XML_EXTERNAL_GENERAL_UNPARSED_ENTITY' file='entities'/>
    <const name='XML_EXTERNAL_PARAMETER_ENTITY' file='entities'/>
    <macro name='XML_GET_CONTENT' file='tree'>
      <info>Macro to extract the content pointer of a node.</info>
    </macro>
    <macro name='XML_GET_LINE' file='tree'>
      <info>Macro to extract the line number of an element node. This will work only if line numbering is activated by calling xmlLineNumbersDefault(1) before parsing.</info>
    </macro>
    <const name='XML_HTML_DOCUMENT_NODE' file='tree'/>
    <const name='XML_INTERNAL_GENERAL_ENTITY' file='entities'/>
    <const name='XML_INTERNAL_PARAMETER_ENTITY' file='entities'/>
    <const name='XML_INTERNAL_PREDEFINED_ENTITY' file='entities'/>
    <macro name='XML_LOCAL_NAMESPACE' file='tree'>
      <info>A namespace declaration node.</info>
    </macro>
    <macro name='XML_MAX_NAMELEN' file='parserInternals'>
      <info>Identifiers can be longer, but this will be more costly at runtime.</info>
    </macro>
    <const name='XML_NAMESPACE_DECL' file='tree'/>
    <const name='XML_NOTATION_NODE' file='tree'/>
    <const name='XML_PARSER_ATTRIBUTE_VALUE' file='parser'/>
    <const name='XML_PARSER_CDATA_SECTION' file='parser'/>
    <const name='XML_PARSER_COMMENT' file='parser'/>
    <const name='XML_PARSER_CONTENT' file='parser'/>
    <const name='XML_PARSER_DTD' file='parser'/>
    <const name='XML_PARSER_END_TAG' file='parser'/>
    <const name='XML_PARSER_ENTITY_DECL' file='parser'/>
    <const name='XML_PARSER_ENTITY_VALUE' file='parser'/>
    <const name='XML_PARSER_EOF' file='parser'/>
    <const name='XML_PARSER_EPILOG' file='parser'/>
    <const name='XML_PARSER_IGNORE' file='parser'/>
    <const name='XML_PARSER_MISC' file='parser'/>
    <const name='XML_PARSER_PI' file='parser'/>
    <const name='XML_PARSER_PROLOG' file='parser'/>
    <const name='XML_PARSER_PUBLIC_LITERAL' file='parser'/>
    <const name='XML_PARSER_START' file='parser'/>
    <const name='XML_PARSER_START_TAG' file='parser'/>
    <const name='XML_PARSER_SYSTEM_LITERAL' file='parser'/>
    <const name='XML_PI_NODE' file='tree'/>
    <macro name='XML_SCHEMAS_ANYATTR_LAX' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ANYATTR_SKIP' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ANYATTR_STRICT' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_ABSTRACT' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_DEFAULT' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_FIXED' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_GLOBAL' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_NILLABLE' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_REF' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_TOPLEVEL' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_FACET_COLLAPSE' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_FACET_PRESERVE' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_FACET_REPLACE' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_FACET_UNKNOWN' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_QUALIF_ATTR' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_QUALIF_ELEM' file='schemasInternals'>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_MIXED' file='schemasInternals'>
    </macro>
    <const name='XML_SCHEMA_CONTENT_ANY' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_BASIC' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_ELEMENTS' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_EMPTY' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_MIXED' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_SIMPLE' file='schemasInternals'/>
    <const name='XML_SCHEMA_CONTENT_UNKNOWN' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_ENUMERATION' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_FRACTIONDIGITS' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_LENGTH' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MAXEXCLUSIVE' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MAXINCLUSIVE' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MAXLENGTH' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MINEXCLUSIVE' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MININCLUSIVE' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_MINLENGTH' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_PATTERN' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_TOTALDIGITS' file='schemasInternals'/>
    <const name='XML_SCHEMA_FACET_WHITESPACE' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_ALL' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_ANY' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_ATTRIBUTE' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_ATTRIBUTEGROUP' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_BASIC' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_CHOICE' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_COMPLEX' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_COMPLEX_CONTENT' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_ELEMENT' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_EXTENSION' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_FACET' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_GROUP' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_LIST' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_NOTATION' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_RESTRICTION' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_SEQUENCE' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_SIMPLE' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_SIMPLE_CONTENT' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_UNION' file='schemasInternals'/>
    <const name='XML_SCHEMA_TYPE_UR' file='schemasInternals'/>
    <macro name='XML_SUBSTITUTE_BOTH' file='parserInternals'>
      <info>Both general and parameter entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_NONE' file='parserInternals'>
      <info>If no entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_PEREF' file='parserInternals'>
      <info>Whether parameter entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_REF' file='parserInternals'>
      <info>Whether general entities need to be substituted.</info>
    </macro>
    <const name='XML_TEXT_NODE' file='tree'/>
    <const name='XML_WAR_CATALOG_PI' file='xmlerror'/>
    <const name='XML_WAR_UNDECLARED_ENTITY' file='xmlerror'/>
    <const name='XML_XINCLUDE_END' file='tree'/>
    <const name='XML_XINCLUDE_START' file='tree'/>
    <macro name='XML_XML_NAMESPACE' file='tree'>
      <info>This is the namespace for the special xml: prefix predefined in the XML Namespace specification.</info>
    </macro>
    <const name='XPATH_BOOLEAN' file='xpath'/>
    <const name='XPATH_ENCODING_ERROR' file='xpath'/>
    <const name='XPATH_EXPRESSION_OK' file='xpath'/>
    <const name='XPATH_EXPR_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_ARITY' file='xpath'/>
    <const name='XPATH_INVALID_CHAR_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_CTXT_POSITION' file='xpath'/>
    <const name='XPATH_INVALID_CTXT_SIZE' file='xpath'/>
    <const name='XPATH_INVALID_OPERAND' file='xpath'/>
    <const name='XPATH_INVALID_PREDICATE_ERROR' file='xpath'/>
    <const name='XPATH_INVALID_TYPE' file='xpath'/>
    <const name='XPATH_LOCATIONSET' file='xpath'/>
    <const name='XPATH_MEMORY_ERROR' file='xpath'/>
    <const name='XPATH_NODESET' file='xpath'/>
    <const name='XPATH_NUMBER' file='xpath'/>
    <const name='XPATH_NUMBER_ERROR' file='xpath'/>
    <const name='XPATH_POINT' file='xpath'/>
    <const name='XPATH_RANGE' file='xpath'/>
    <const name='XPATH_START_LITERAL_ERROR' file='xpath'/>
    <const name='XPATH_STRING' file='xpath'/>
    <const name='XPATH_UNCLOSED_ERROR' file='xpath'/>
    <const name='XPATH_UNDEFINED' file='xpath'/>
    <const name='XPATH_UNDEF_PREFIX_ERROR' file='xpath'/>
    <const name='XPATH_UNDEF_VARIABLE_ERROR' file='xpath'/>
    <const name='XPATH_UNFINISHED_LITERAL_ERROR' file='xpath'/>
    <const name='XPATH_UNKNOWN_FUNC_ERROR' file='xpath'/>
    <const name='XPATH_USERS' file='xpath'/>
    <const name='XPATH_VARIABLE_REF_ERROR' file='xpath'/>
    <const name='XPATH_XSLT_TREE' file='xpath'/>
    <const name='XPTR_RESOURCE_ERROR' file='xpath'/>
    <const name='XPTR_SUB_RESOURCE_ERROR' file='xpath'/>
    <const name='XPTR_SYNTAX_ERROR' file='xpath'/>
    <macro name='XP_ERROR' file='xpathInternals'>
      <info>Macro to raise an XPath error and return.</info>
      <arg name='X' info='the error code '/>
    </macro>
    <macro name='XP_ERROR0' file='xpathInternals'>
      <info>Macro to raise an XPath error and return 0.</info>
      <arg name='X' info='the error code '/>
    </macro>
    <function name='attribute' file='SAX'>
      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='fullname' type='const xmlChar *' info='The attribute name, including namespace prefix '/>
      <arg name='value' type='const xmlChar *' info='The attribute value '/>
    </function>
    <function name='attributeDecl' file='SAX'>
      <info>An attribute definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='elem' type='const xmlChar *' info='the name of the element '/>
      <arg name='fullname' type='const xmlChar *' info='the attribute name '/>
      <arg name='type' type='int' info='the attribute type '/>
      <arg name='def' type='int' info='the type of default value '/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value '/>
      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set '/>
    </function>
    <functype name='attributeDeclSAXFunc' file='parser'>
      <info>An attribute definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='elem' type='const xmlChar *' info='the name of the element '/>
      <arg name='fullname' type='const xmlChar *' info='the attribute name '/>
      <arg name='type' type='int' info='the attribute type '/>
      <arg name='def' type='int' info='the type of default value '/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value '/>
      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set '/>
    </functype>
    <functype name='attributeSAXFunc' file='parser'>
      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The attribute name, including namespace prefix '/>
      <arg name='value' type='const xmlChar *' info='The attribute value '/>
    </functype>
    <function name='cdataBlock' file='SAX'>
      <info>called when a pcdata block has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='value' type='const xmlChar *' info='The pcdata content '/>
      <arg name='len' type='int' info='the block length '/>
    </function>
    <functype name='cdataBlockSAXFunc' file='parser'>
      <info>Called when a pcdata block has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='value' type='const xmlChar *' info='The pcdata content '/>
      <arg name='len' type='int' info='the block length '/>
    </functype>
    <function name='characters' file='SAX'>
      <info>receiving some chars from the parser.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar '/>
    </function>
    <functype name='charactersSAXFunc' file='parser'>
      <info>Receiving some chars from the parser.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar '/>
    </functype>
    <function name='checkNamespace' file='SAX'>
      <info>Check that the current element namespace is the same as the one read upon parsing.</info>
      <return type='int' info='1 if true 0 otherwise '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='nameSpace' type='xmlChar *' info='the namespace to check against '/>
    </function>
    <function name='comment' file='SAX'>
      <info>A comment has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='value' type='const xmlChar *' info='the comment content '/>
    </function>
    <functype name='commentSAXFunc' file='parser'>
      <info>A comment has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='value' type='const xmlChar *' info='the comment content '/>
    </functype>
    <function name='docbCreateFileParserCtxt' file='DOCBparser'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='the SGML document encoding, or NULL '/>
    </function>
    <function name='docbCreatePushParserCtxt' file='DOCBparser'>
      <info>Create a parser context for using the DocBook SGML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='docbParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='sax' type='docbSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars '/>
      <arg name='size' type='int' info='number of chars in the array '/>
      <arg name='filename' type='const char *' info='an optional file name or URI '/>
      <arg name='enc' type='xmlCharEncoding' info='an optional encoding '/>
    </function>
    <macro name='docbDefaultSAXHandler' file='globals'>
      <info>Default handler for SGML DocBook, builds the DOM tree</info>
    </macro>
    <function name='docbDefaultSAXHandlerInit' file='SAX'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
    </function>
    <typedef name='docbDocPtr' file='DOCBparser'/>
    <function name='docbEncodeEntities' file='DOCBparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus SGML entities block of chars out.</info>
      <return type='int' info='outlen after return is the number of octets consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars '/>
      <arg name='inlen' type='int *' info='in '/>
      <arg name='quoteChar' type='int' info='the quote character to escape (&apos; or &quot;) or zero. '/>
    </function>
    <function name='docbFreeParserCtxt' file='DOCBparser'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an SGML parser context '/>
    </function>
    <typedef name='docbNodePtr' file='DOCBparser'/>
    <function name='docbParseChunk' file='DOCBparser'>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise. '/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an XML parser context '/>
      <arg name='chunk' type='const char *' info='an char array '/>
      <arg name='size' type='int' info='the size in byte of the chunk '/>
      <arg name='terminate' type='int' info='last chunk indicator '/>
    </function>
    <function name='docbParseDoc' file='DOCBparser'>
      <info>parse an SGML in-memory document and build a tree.</info>
      <return type='docbDocPtr' info='the resulting document tree '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL '/>
    </function>
    <function name='docbParseDocument' file='DOCBparser'>
      <info>parse an SGML document (and build a tree if using the standard SAX interface).</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing. '/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an SGML parser context '/>
    </function>
    <function name='docbParseFile' file='DOCBparser'>
      <info>parse a Docbook SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbDocPtr' info='the resulting document tree '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='a free form C string describing document encoding, or NULL '/>
    </function>
    <typedef name='docbParserCtxt' file='DOCBparser'/>
    <typedef name='docbParserCtxtPtr' file='DOCBparser'/>
    <typedef name='docbParserInput' file='DOCBparser'/>
    <typedef name='docbParserInputPtr' file='DOCBparser'/>
    <typedef name='docbParserNodeInfo' file='DOCBparser'/>
    <typedef name='docbSAXHandler' file='DOCBparser'/>
    <typedef name='docbSAXHandlerPtr' file='DOCBparser'/>
    <function name='docbSAXParseDoc' file='DOCBparser'>
      <info>parse an SGML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr' info='the resulting document tree '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL '/>
      <arg name='sax' type='docbSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks. '/>
    </function>
    <function name='docbSAXParseFile' file='DOCBparser'>
      <info>parse an SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr' info='the resulting document tree '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL '/>
      <arg name='sax' type='docbSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks. '/>
    </function>
    <function name='elementDecl' file='SAX'>
      <info>An element definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='type' type='int' info='the element type '/>
      <arg name='content' type='xmlElementContentPtr' info='the element value tree '/>
    </function>
    <functype name='elementDeclSAXFunc' file='parser'>
      <info>An element definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='type' type='int' info='the element type '/>
      <arg name='content' type='xmlElementContentPtr' info='the element value tree '/>
    </functype>
    <function name='endDocument' file='SAX'>
      <info>called when the document end has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <functype name='endDocumentSAXFunc' file='parser'>
      <info>Called when the document end has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </functype>
    <function name='endElement' file='SAX'>
      <info>called when the end of an element has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The element name '/>
    </function>
    <functype name='endElementSAXFunc' file='parser'>
      <info>Called when the end of an element has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The element name '/>
    </functype>
    <function name='entityDecl' file='SAX'>
      <info>An entity definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='type' type='int' info='the entity type '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
      <arg name='content' type='xmlChar *' info='the entity value (without processing). '/>
    </function>
    <functype name='entityDeclSAXFunc' file='parser'>
      <info>An entity definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='type' type='int' info='the entity type '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
      <arg name='content' type='xmlChar *' info='the entity value (without processing). '/>
    </functype>
    <functype name='errorSAXFunc' file='parser'>
      <info>Display and format an error messages, callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </functype>
    <function name='externalSubset' file='SAX'>
      <info>Callback on external subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the root element name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL) '/>
    </function>
    <functype name='externalSubsetSAXFunc' file='parser'>
      <info>Callback on external subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the root element name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL) '/>
    </functype>
    <functype name='fatalErrorSAXFunc' file='parser'>
      <info>Display and format fatal error messages, callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </functype>
    <functype name='ftpDataCallback' file='nanoftp'>
      <info>A callback for the xmlNanoFTPGet command.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='the user provided context '/>
      <arg name='data' type='const char *' info='the data received '/>
      <arg name='len' type='int' info='its size in bytes '/>
    </functype>
    <functype name='ftpListCallback' file='nanoftp'>
      <info>A callback for the xmlNanoFTPList command. Note that only one of year and day:minute are specified.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the callback '/>
      <arg name='filename' type='const char *' info='the file name (including &quot;-&gt;&quot; when links are shown) '/>
      <arg name='attrib' type='const char *' info='the attribute string '/>
      <arg name='owner' type='const char *' info='the owner string '/>
      <arg name='group' type='const char *' info='the group string '/>
      <arg name='size' type='unsigned long' info='the file size '/>
      <arg name='links' type='int' info='the link count '/>
      <arg name='year' type='int' info='the year '/>
      <arg name='month' type='const char *' info='the month '/>
      <arg name='day' type='int' info='the day '/>
      <arg name='hour' type='int' info='the hour '/>
      <arg name='minute' type='int' info='the minute '/>
    </functype>
    <function name='getColumnNumber' file='SAX'>
      <info>Return the column number of the current parsing point.</info>
      <return type='int' info='an int '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <function name='getEntity' file='SAX'>
      <info>Get an entity by name</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </function>
    <functype name='getEntitySAXFunc' file='parser'>
      <info>Get an entity by name.</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </functype>
    <function name='getLineNumber' file='SAX'>
      <info>Return the line number of the current parsing point.</info>
      <return type='int' info='an int '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <function name='getNamespace' file='SAX'>
      <info>Get the current element namespace.</info>
      <return type='xmlNsPtr' info='the xmlNsPtr or NULL if none '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <function name='getParameterEntity' file='SAX'>
      <info>Get a parameter entity by name</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </function>
    <functype name='getParameterEntitySAXFunc' file='parser'>
      <info>Get a parameter entity by name.</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </functype>
    <function name='getPublicId' file='SAX'>
      <info>Return the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot;</info>
      <return type='const xmlChar *' info='a xmlChar * '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <function name='getSystemId' file='SAX'>
      <info>Return the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd</info>
      <return type='const xmlChar *' info='a xmlChar * '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <function name='globalNamespace' file='SAX'>
      <info>An old global namespace has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='href' type='const xmlChar *' info='the namespace associated URN '/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix '/>
    </function>
    <function name='hasExternalSubset' file='SAX'>
      <info>Does this document has an external subset</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <functype name='hasExternalSubsetSAXFunc' file='parser'>
      <info>Does this document has an external subset?</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </functype>
    <function name='hasInternalSubset' file='SAX'>
      <info>Does this document has an internal subset</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <functype name='hasInternalSubsetSAXFunc' file='parser'>
      <info>Does this document has an internal subset.</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </functype>
    <function name='htmlAutoCloseTag' file='HTMLparser'>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if the element or one of it&apos;s children would autoclose the given tag.</info>
      <return type='int' info='1 if autoclose, 0 otherwise '/>
      <arg name='doc' type='htmlDocPtr' info='the HTML document '/>
      <arg name='name' type='const xmlChar *' info='The tag name '/>
      <arg name='elem' type='htmlNodePtr' info='the HTML element '/>
    </function>
    <function name='htmlCreateFileParserCtxt' file='parserInternals'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL '/>
    </function>
    <function name='htmlCreatePushParserCtxt' file='HTMLparser'>
      <info>Create a parser context for using the HTML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='htmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars '/>
      <arg name='size' type='int' info='number of chars in the array '/>
      <arg name='filename' type='const char *' info='an optional file name or URI '/>
      <arg name='enc' type='xmlCharEncoding' info='an optional encoding '/>
    </function>
    <macro name='htmlDefaultSAXHandler' file='globals'>
      <info>Default handler for HTML, builds the DOM tree</info>
    </macro>
    <function name='htmlDefaultSAXHandlerInit' file='SAX'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
    </function>
    <function name='htmlDocContentDumpFormatOutput' file='HTMLtree'>
      <info>Dump an HTML document.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the encoding string '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='htmlDocContentDumpOutput' file='HTMLtree'>
      <info>Dump an HTML document. Formating return/spaces are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the encoding string '/>
    </function>
    <function name='htmlDocDump' file='HTMLtree'>
      <info>Dump an HTML document to an open FILE.</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='f' type='FILE *' info='the FILE* '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='htmlDocDumpMemory' file='HTMLtree'>
      <info>Dump an HTML document in memory and return the xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer '/>
      <arg name='size' type='int *' info='OUT: the memory length '/>
    </function>
    <typedef name='htmlDocPtr' file='HTMLparser'/>
    <struct name='htmlElemDesc' file='HTMLparser'/>
    <typedef name='htmlElemDescPtr' file='HTMLparser'/>
    <function name='htmlEncodeEntities' file='HTMLparser'>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int' info='outlen after return is the number of octets consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars '/>
      <arg name='inlen' type='int *' info='in '/>
      <arg name='quoteChar' type='int' info='the quote character to escape (&apos; or &quot;) or zero. '/>
    </function>
    <struct name='htmlEntityDesc' file='HTMLparser'/>
    <typedef name='htmlEntityDescPtr' file='HTMLparser'/>
    <function name='htmlEntityLookup' file='HTMLparser'>
      <info>Lookup the given entity in EntitiesTable </info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, NULL otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
    </function>
    <function name='htmlEntityValueLookup' file='HTMLparser'>
      <info>Lookup the given entity in EntitiesTable </info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, NULL otherwise. '/>
      <arg name='value' type='unsigned int' info='the entity&apos;s unicode value '/>
    </function>
    <function name='htmlFreeParserCtxt' file='HTMLparser'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context '/>
    </function>
    <function name='htmlGetMetaEncoding' file='HTMLtree'>
      <info>Encoding definition lookup in the Meta tags</info>
      <return type='const xmlChar *' info='the current encoding as flagged in the HTML source '/>
      <arg name='doc' type='htmlDocPtr' info='the document '/>
    </function>
    <function name='htmlHandleOmittedElem' file='HTMLparser'>
      <info>Set and return the previous value for handling HTML omitted tags.</info>
      <return type='int' info='the last value for 0 for no handling, 1 for auto insertion. '/>
      <arg name='val' type='int' info='int 0 or 1 '/>
    </function>
    <function name='htmlInitAutoClose' file='parserInternals'>
      <info>Initialize the htmlStartCloseIndex for fast lookup of closing tags names. This is not reentrant. Call xmlInitParser() once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
    </function>
    <function name='htmlIsAutoClosed' file='HTMLparser'>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if a tag is autoclosed by one of it&apos;s child</info>
      <return type='int' info='1 if autoclosed, 0 otherwise '/>
      <arg name='doc' type='htmlDocPtr' info='the HTML document '/>
      <arg name='elem' type='htmlNodePtr' info='the HTML element '/>
    </function>
    <function name='htmlIsBooleanAttr' file='HTMLtree'>
      <info>Determine if a given attribute is a boolean attribute.</info>
      <return type='int' info='false if the attribute is not boolean, true otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute to check '/>
    </function>
    <function name='htmlIsScriptAttribute' file='HTMLparser'>
      <info>Check if an attribute is of content type Script</info>
      <return type='int' info='1 is the attribute is a script 0 otherwise '/>
      <arg name='name' type='const xmlChar *' info='an attribute name '/>
    </function>
    <function name='htmlNewDoc' file='HTMLtree'>
      <info>Creates a new HTML document</info>
      <return type='htmlDocPtr' info='a new document '/>
      <arg name='URI' type='const xmlChar *' info='URI for the dtd, or NULL '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID of the DTD, or NULL '/>
    </function>
    <function name='htmlNewDocNoDtD' file='HTMLtree'>
      <info>Creates a new HTML document without a DTD node if URI and ExternalID are NULL</info>
      <return type='htmlDocPtr' info='a new document, do not initialize the DTD if not provided '/>
      <arg name='URI' type='const xmlChar *' info='URI for the dtd, or NULL '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID of the DTD, or NULL '/>
    </function>
    <function name='htmlNodeDump' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the HTML buffer output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
    </function>
    <function name='htmlNodeDumpFile' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='void'/>
      <arg name='out' type='FILE *' info='the FILE pointer '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
    </function>
    <function name='htmlNodeDumpFileFormat' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too. </info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='out' type='FILE *' info='the FILE pointer '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
      <arg name='encoding' type='const char *' info='the document encoding '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='htmlNodeDumpFormatOutput' file='HTMLtree'>
      <info>Dump an HTML node, recursive behaviour,children are printed too.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
      <arg name='encoding' type='const char *' info='the encoding string '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <typedef name='htmlNodePtr' file='HTMLparser'/>
    <function name='htmlParseCharRef' file='HTMLparser'>
      <info>parse Reference declarations </info>
      <return type='int' info='the value parsed (as an int) '/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context '/>
    </function>
    <function name='htmlParseChunk' file='HTMLparser'>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise. '/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='chunk' type='const char *' info='an char array '/>
      <arg name='size' type='int' info='the size in byte of the chunk '/>
      <arg name='terminate' type='int' info='last chunk indicator '/>
    </function>
    <function name='htmlParseDoc' file='HTMLparser'>
      <info>parse an HTML in-memory document and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL '/>
    </function>
    <function name='htmlParseDocument' file='HTMLparser'>
      <info>parse an HTML document (and build a tree if using the standard SAX interface).</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing. '/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context '/>
    </function>
    <function name='htmlParseElement' file='HTMLparser'>
      <info>parse an HTML element, this is highly recursive </info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context '/>
    </function>
    <function name='htmlParseEntityRef' file='HTMLparser'>
      <info>parse an HTML ENTITY references </info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, or NULL otherwise, if non-NULL *str will have to be freed by the caller. '/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context '/>
      <arg name='str' type='xmlChar **' info='location to store the entity name '/>
    </function>
    <function name='htmlParseFile' file='HTMLparser'>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlDocPtr' info='the resulting document tree '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL '/>
    </function>
    <typedef name='htmlParserCtxt' file='HTMLparser'/>
    <typedef name='htmlParserCtxtPtr' file='HTMLparser'/>
    <typedef name='htmlParserInput' file='HTMLparser'/>
    <typedef name='htmlParserInputPtr' file='HTMLparser'/>
    <typedef name='htmlParserNodeInfo' file='HTMLparser'/>
    <typedef name='htmlSAXHandler' file='HTMLparser'/>
    <typedef name='htmlSAXHandlerPtr' file='HTMLparser'/>
    <function name='htmlSAXParseDoc' file='HTMLparser'>
      <info>Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks to handle parse events. If sax is NULL, fallback to the default DOM behavior and return a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree unless SAX is NULL or the document is not well formed. '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL '/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks. '/>
    </function>
    <function name='htmlSAXParseFile' file='HTMLparser'>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='htmlDocPtr' info='the resulting document tree unless SAX is NULL or the document is not well formed. '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL '/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks. '/>
    </function>
    <function name='htmlSaveFile' file='HTMLtree'>
      <info>Dump an HTML document to a file. If filename is &quot;-&quot; the stdout file is used.</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename (or URL) '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='htmlSaveFileEnc' file='HTMLtree'>
      <info>Dump an HTML document to a file using a given encoding and formatting returns/spaces are added.</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the document encoding '/>
    </function>
    <function name='htmlSaveFileFormat' file='HTMLtree'>
      <info>Dump an HTML document to a file using a given encoding.</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the document encoding '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='htmlSetMetaEncoding' file='HTMLtree'>
      <info>Sets the current encoding in the Meta tags NOTE: this will not change the document content encoding, just the META flag associated.</info>
      <return type='int' info='0 in case of success and -1 in case of error '/>
      <arg name='doc' type='htmlDocPtr' info='the document '/>
      <arg name='encoding' type='const xmlChar *' info='the encoding string '/>
    </function>
    <function name='htmlTagLookup' file='HTMLparser'>
      <info>Lookup the HTML tag in the ElementTable</info>
      <return type='const htmlElemDesc *' info='the related htmlElemDescPtr or NULL if not found. '/>
      <arg name='tag' type='const xmlChar *' info='The tag name in lowercase '/>
    </function>
    <function name='ignorableWhitespace' file='SAX'>
      <info>receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar '/>
    </function>
    <functype name='ignorableWhitespaceSAXFunc' file='parser'>
      <info>Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar '/>
    </functype>
    <function name='initGenericErrorDefaultFunc' file='xmlerror'>
      <info>Set or reset (if NULL) the default handler for generic errors</info>
      <return type='void'/>
      <arg name='handler' type='xmlGenericErrorFunc *' info='the handler '/>
    </function>
    <function name='initdocbDefaultSAXHandler' file='SAX'>
      <info>Initialize the default DocBook SAX handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler '/>
    </function>
    <function name='inithtmlDefaultSAXHandler' file='SAX'>
      <info>Initialize the default HTML SAX handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler '/>
    </function>
    <function name='initxmlDefaultSAXHandler' file='SAX'>
      <info>Initialize the default XML SAX handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler '/>
      <arg name='warning' type='int' info='flag if non-zero sets the handler warning procedure '/>
    </function>
    <function name='inputPop' file='parserInternals'>
      <info>Pops the top parser input from the input stack</info>
      <return type='xmlParserInputPtr' info='the input just removed '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='inputPush' file='parserInternals'>
      <info>Pushes a new parser input on top of the input stack</info>
      <return type='int' info='0 in case of error, the index in the stack otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='value' type='xmlParserInputPtr' info='the parser input '/>
    </function>
    <function name='internalSubset' file='SAX'>
      <info>Callback on internal subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the root element name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL) '/>
    </function>
    <functype name='internalSubsetSAXFunc' file='parser'>
      <info>Callback on internal subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the root element name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL) '/>
    </functype>
    <function name='isStandalone' file='SAX'>
      <info>Is this document tagged standalone ?</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <functype name='isStandaloneSAXFunc' file='parser'>
      <info>Is this document tagged standalone?</info>
      <return type='int' info='1 if true '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </functype>
    <function name='isolat1ToUTF8' file='encoding'>
      <info>Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8 block of chars out.</info>
      <return type='int' info='outlen after return is the number of ocetes consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of ISO Latin 1 chars '/>
      <arg name='inlen' type='int *' info='in '/>
    </function>
    <function name='namePop' file='parserInternals'>
      <info>Pops the top element name from the name stack</info>
      <return type='xmlChar *' info='the name just removed '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='namePush' file='parserInternals'>
      <info>Pushes a new element name on top of the name stack</info>
      <return type='int' info='0 in case of error, the index in the stack otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='value' type='xmlChar *' info='the element name '/>
    </function>
    <function name='namespaceDecl' file='SAX'>
      <info>A namespace has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='href' type='const xmlChar *' info='the namespace associated URN '/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix '/>
    </function>
    <function name='nodePop' file='parserInternals'>
      <info>Pops the top element node from the node stack</info>
      <return type='xmlNodePtr' info='the node just removed '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='nodePush' file='parserInternals'>
      <info>Pushes a new element node on top of the node stack</info>
      <return type='int' info='0 in case of error, the index in the stack otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='value' type='xmlNodePtr' info='the element node '/>
    </function>
    <function name='notationDecl' file='SAX'>
      <info>What to do when a notation declaration has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The name of the notation '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
    </function>
    <functype name='notationDeclSAXFunc' file='parser'>
      <info>What to do when a notation declaration has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The name of the notation '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
    </functype>
    <macro name='oldXMLWDcompatibility' file='globals'>
      <info>Global setting, DEPRECATED.</info>
    </macro>
    <function name='processingInstruction' file='SAX'>
      <info>A processing instruction has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='target' type='const xmlChar *' info='the target name '/>
      <arg name='data' type='const xmlChar *' info='the PI data&apos;s '/>
    </function>
    <functype name='processingInstructionSAXFunc' file='parser'>
      <info>A processing instruction has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='target' type='const xmlChar *' info='the target name '/>
      <arg name='data' type='const xmlChar *' info='the PI data&apos;s '/>
    </functype>
    <function name='reference' file='SAX'>
      <info>called when an entity reference is detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </function>
    <functype name='referenceSAXFunc' file='parser'>
      <info>Called when an entity reference is detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The entity name '/>
    </functype>
    <function name='resolveEntity' file='SAX'>
      <info>The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
    </function>
    <functype name='resolveEntitySAXFunc' file='parser'>
      <info>Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour. '/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
    </functype>
    <function name='setDocumentLocator' file='SAX'>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator '/>
    </function>
    <functype name='setDocumentLocatorSAXFunc' file='parser'>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator '/>
    </functype>
    <function name='setNamespace' file='SAX'>
      <info>Set the current element namespace.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='the namespace prefix '/>
    </function>
    <function name='startDocument' file='SAX'>
      <info>called when the document start being processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </function>
    <functype name='startDocumentSAXFunc' file='parser'>
      <info>Called when the document start being processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
    </functype>
    <function name='startElement' file='SAX'>
      <info>called when an opening tag has been processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='fullname' type='const xmlChar *' info='The element name, including namespace prefix '/>
      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated '/>
    </function>
    <functype name='startElementSAXFunc' file='parser'>
      <info>Called when an opening tag has been processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The element name, including namespace prefix '/>
      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated '/>
    </functype>
    <function name='unparsedEntityDecl' file='SAX'>
      <info>What to do when an unparsed entity declaration is parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The name of the entity '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
      <arg name='notationName' type='const xmlChar *' info='the name of the notation '/>
    </function>
    <functype name='unparsedEntityDeclSAXFunc' file='parser'>
      <info>What to do when an unparsed entity declaration is parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context) '/>
      <arg name='name' type='const xmlChar *' info='The name of the entity '/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity '/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity '/>
      <arg name='notationName' type='const xmlChar *' info='the name of the notation '/>
    </functype>
    <function name='valuePop' file='xpathInternals'>
      <info>Pops the top XPath object from the value stack</info>
      <return type='xmlXPathObjectPtr' info='the XPath object just removed '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath evaluation context '/>
    </function>
    <function name='valuePush' file='xpathInternals'>
      <info>Pushes a new XPath object on top of the value stack</info>
      <return type='int' info='the number of items on the value stack '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath evaluation context '/>
      <arg name='value' type='xmlXPathObjectPtr' info='the XPath object '/>
    </function>
    <functype name='warningSAXFunc' file='parser'>
      <info>Display and format a warning messages, callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </functype>
    <function name='xmlACatalogAdd' file='catalog'>
      <info>Add an entry in the catalog, it may overwrite existing but different entries.</info>
      <return type='int' info='0 if successful, -1 otherwise '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='type' type='const xmlChar *' info='the type of record to add to the catalog '/>
      <arg name='orig' type='const xmlChar *' info='the system, public or prefix to match '/>
      <arg name='replace' type='const xmlChar *' info='the replacement value for the match '/>
    </function>
    <function name='xmlACatalogDump' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='out' type='FILE *' info='the file. '/>
    </function>
    <function name='xmlACatalogRemove' file='catalog'>
      <info>Remove an entry from the catalog</info>
      <return type='int' info='the number of entries removed if successful, -1 otherwise '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='value' type='const xmlChar *' info='the value to remove '/>
    </function>
    <function name='xmlACatalogResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string '/>
    </function>
    <function name='xmlACatalogResolvePublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID in that catalog</info>
      <return type='xmlChar *' info='the system ID if found or NULL otherwise, the value returned must be freed by the caller. '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
    </function>
    <function name='xmlACatalogResolveSystem' file='catalog'>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *' info='the system ID if found or NULL otherwise, the value returned must be freed by the caller. '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='sysID' type='const xmlChar *' info='the public ID string '/>
    </function>
    <function name='xmlACatalogResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog '/>
      <arg name='URI' type='const xmlChar *' info='the URI '/>
    </function>
    <function name='xmlAddAttributeDecl' file='valid'>
      <info>Register a new attribute declaration Note that tree becomes the ownership of the DTD</info>
      <return type='xmlAttributePtr' info='NULL if not new, otherwise the attribute decl '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD '/>
      <arg name='elem' type='const xmlChar *' info='the element name '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace prefix '/>
      <arg name='type' type='xmlAttributeType' info='the attribute type '/>
      <arg name='def' type='xmlAttributeDefault' info='the attribute default type '/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value '/>
      <arg name='tree' type='xmlEnumerationPtr' info='if it&apos;s an enumeration, the associated list '/>
    </function>
    <function name='xmlAddChild' file='tree'>
      <info>Add a new node to parent, at the end of the child (or property) list merging adjacent TEXT nodes (in which case cur is freed) If the new node was already inserted in a document it is first unlinked from its existing context. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the child or NULL in case of error. '/>
      <arg name='parent' type='xmlNodePtr' info='the parent node '/>
      <arg name='cur' type='xmlNodePtr' info='the child node '/>
    </function>
    <function name='xmlAddChildList' file='tree'>
      <info>Add a list of node at the end of the child list of the parent merging adjacent TEXT nodes (cur may be freed)</info>
      <return type='xmlNodePtr' info='the last child or NULL in case of error. '/>
      <arg name='parent' type='xmlNodePtr' info='the parent node '/>
      <arg name='cur' type='xmlNodePtr' info='the first node in the list '/>
    </function>
    <function name='xmlAddDocEntity' file='entities'>
      <info>Register a new entity for this document.</info>
      <return type='xmlEntityPtr' info='a pointer to the entity or NULL in case of error '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='type' type='int' info='the entity type XML_xxx_yyy_ENTITY '/>
      <arg name='ExternalID' type='const xmlChar *' info='the entity external ID if available '/>
      <arg name='SystemID' type='const xmlChar *' info='the entity system ID if available '/>
      <arg name='content' type='const xmlChar *' info='the entity content '/>
    </function>
    <function name='xmlAddDtdEntity' file='entities'>
      <info>Register a new entity for this document DTD external subset.</info>
      <return type='xmlEntityPtr' info='a pointer to the entity or NULL in case of error '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='type' type='int' info='the entity type XML_xxx_yyy_ENTITY '/>
      <arg name='ExternalID' type='const xmlChar *' info='the entity external ID if available '/>
      <arg name='SystemID' type='const xmlChar *' info='the entity system ID if available '/>
      <arg name='content' type='const xmlChar *' info='the entity content '/>
    </function>
    <function name='xmlAddElementDecl' file='valid'>
      <info>Register a new element declaration</info>
      <return type='xmlElementPtr' info='NULL if not, otherwise the entity '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='type' type='xmlElementTypeVal' info='the element type '/>
      <arg name='content' type='xmlElementContentPtr' info='the element content tree or NULL '/>
    </function>
    <function name='xmlAddEncodingAlias' file='encoding'>
      <info>Registers and alias alias for an encoding named name. Existing alias will be overwritten.</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='name' type='const char *' info='the encoding name as parsed, in UTF-8 format (ASCII actually) '/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually) '/>
    </function>
    <function name='xmlAddID' file='valid'>
      <info>Register a new id declaration</info>
      <return type='xmlIDPtr' info='NULL if not, otherwise the new xmlIDPtr '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document '/>
      <arg name='value' type='const xmlChar *' info='the value name '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute holding the ID '/>
    </function>
    <function name='xmlAddNextSibling' file='tree'>
      <info>Add a new node elem as the next sibling of cur If the new node was already inserted in a document it is first unlinked from its existing context. As a result of text merging elem may be freed. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the new node or NULL in case of error. '/>
      <arg name='cur' type='xmlNodePtr' info='the child node '/>
      <arg name='elem' type='xmlNodePtr' info='the new node '/>
    </function>
    <function name='xmlAddNotationDecl' file='valid'>
      <info>Register a new notation declaration</info>
      <return type='xmlNotationPtr' info='NULL if not, otherwise the entity '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
      <arg name='PublicID' type='const xmlChar *' info='the public identifier or NULL '/>
      <arg name='SystemID' type='const xmlChar *' info='the system identifier or NULL '/>
    </function>
    <function name='xmlAddPrevSibling' file='tree'>
      <info>Add a new node elem as the previous sibling of cur merging adjacent TEXT nodes (elem may be freed) If the new node was already inserted in a document it is first unlinked from its existing context. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the new node or NULL in case of error. '/>
      <arg name='cur' type='xmlNodePtr' info='the child node '/>
      <arg name='elem' type='xmlNodePtr' info='the new node '/>
    </function>
    <function name='xmlAddRef' file='valid'>
      <info>Register a new ref declaration</info>
      <return type='xmlRefPtr' info='NULL if not, otherwise the new xmlRefPtr '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document '/>
      <arg name='value' type='const xmlChar *' info='the value name '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute holding the Ref '/>
    </function>
    <function name='xmlAddSibling' file='tree'>
      <info>Add a new element elem to the list of siblings of cur merging adjacent TEXT nodes (elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr' info='the new element or NULL in case of error. '/>
      <arg name='cur' type='xmlNodePtr' info='the child node '/>
      <arg name='elem' type='xmlNodePtr' info='the new node '/>
    </function>
    <function name='xmlAllocOutputBuffer' file='xmlIO'>
      <info>Create a buffered parser output</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL '/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL '/>
    </function>
    <function name='xmlAllocParserInputBuffer' file='xmlIO'>
      <info>Create a buffered parser input for progressive parsing</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <struct name='xmlAttr' file='tree' info='An attribute on an XML node.'/>
    <typedef name='xmlAttrPtr' file='tree'/>
    <struct name='xmlAttribute' file='tree' info='An Attribute declaration in a DTD.'/>
    <enum name='xmlAttributeDefault' file='tree'/>
    <typedef name='xmlAttributePtr' file='tree'/>
    <typedef name='xmlAttributeTablePtr' file='valid'/>
    <enum name='xmlAttributeType' file='tree'/>
    <struct name='xmlAutomata' file='xmlautomata'/>
    <function name='xmlAutomataCompile' file='xmlautomata'>
      <info>Compile the automata into a Reg Exp ready for being executed. The automata should be free after this point.</info>
      <return type='xmlRegexpPtr' info='the compiled regexp or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
    </function>
    <function name='xmlAutomataGetInitState' file='xmlautomata'>
      <return type='xmlAutomataStatePtr' info='the initial state of the automata '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
    </function>
    <function name='xmlAutomataIsDeterminist' file='xmlautomata'>
      <info>Checks if an automata is determinist.</info>
      <return type='int' info='1 if true, 0 if not, and -1 in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
    </function>
    <function name='xmlAutomataNewAllTrans' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds a an ALL transition from the from state to the target state. That transition is an epsilon transition allowed only when all transitions from the from node have been activated.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='lax' type='int'/>
    </function>
    <function name='xmlAutomataNewCountTrans' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds a transition from the from state to the target state activated by a succession of input of value token and whose number is between min and max</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition '/>
      <arg name='min' type='int' info='the minimum successive occurences of token '/>
      <arg name='max' type='int'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlAutomataNewCountedTrans' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds an epsilon transition from the from state to the target state which will increment the counter provided</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='counter' type='int' info='the counter associated to that transition '/>
    </function>
    <function name='xmlAutomataNewCounter' file='xmlautomata'>
      <info>Create a new counter</info>
      <return type='int' info='the counter number or -1 in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='min' type='int' info='the minimal value on the counter '/>
      <arg name='max' type='int' info='the maximal value on the counter '/>
    </function>
    <function name='xmlAutomataNewCounterTrans' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds an epsilon transition from the from state to the target state which will be allowed only if the counter is within the right range.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='counter' type='int' info='the counter associated to that transition '/>
    </function>
    <function name='xmlAutomataNewEpsilon' file='xmlautomata'>
      <return type='xmlAutomataStatePtr'/>
      <arg name='am' type='xmlAutomataPtr'/>
      <arg name='from' type='xmlAutomataStatePtr'/>
      <arg name='to' type='xmlAutomataStatePtr'/>
    </function>
    <function name='xmlAutomataNewOnceTrans' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds a transition from the from state to the target state activated by a succession of input of value token and whose number is between min and max, moreover that transistion can only be crossed once.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition '/>
      <arg name='min' type='int' info='the minimum successive occurences of token '/>
      <arg name='max' type='int'/>
      <arg name='data' type='void *'/>
    </function>
    <function name='xmlAutomataNewState' file='xmlautomata'>
      <info>Create a new disconnected state in the automata</info>
      <return type='xmlAutomataStatePtr' info='the new state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
    </function>
    <function name='xmlAutomataNewTransition' file='xmlautomata'>
      <info>If to is NULL, this create first a new target state in the automata and then adds a an epsilon transition from the from state to the target state</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition '/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL '/>
      <arg name='token' type='const xmlChar *'/>
      <arg name='data' type='void *'/>
    </function>
    <typedef name='xmlAutomataPtr' file='xmlautomata' info='A libxml automata description, It can be compiled into a regexp'/>
    <function name='xmlAutomataSetFinalState' file='xmlautomata'>
      <info>Makes that state a final state</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
      <arg name='state' type='xmlAutomataStatePtr' info='a state in this automata '/>
    </function>
    <struct name='xmlAutomataState' file='xmlautomata'/>
    <typedef name='xmlAutomataStatePtr' file='xmlautomata' info='A state int the automata description,'/>
    <struct name='xmlBuffer' file='tree' info='A buffer structure.'/>
    <function name='xmlBufferAdd' file='tree'>
      <info>Add a string range to an XML buffer. if len == -1, the length of str is recomputed.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar to add '/>
    </function>
    <function name='xmlBufferAddHead' file='tree'>
      <info>Add a string range to the beginning of an XML buffer. if len == -1, the length of str is recomputed.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar string '/>
      <arg name='len' type='int' info='the number of xmlChar to add '/>
    </function>
    <macro name='xmlBufferAllocScheme' file='globals'>
      <info>Global setting, default allocation policy for buffers, default is XML_BUFFER_ALLOC_EXACT</info>
    </macro>
    <enum name='xmlBufferAllocationScheme' file='tree'/>
    <function name='xmlBufferCCat' file='tree'>
      <info>Append a zero terminated C string to an XML buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump '/>
      <arg name='str' type='const char *' info='the C char string '/>
    </function>
    <function name='xmlBufferCat' file='tree'>
      <info>Append a zero terminated string to an XML buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar string '/>
    </function>
    <function name='xmlBufferContent' file='tree'>
      <info>Function to extract the content of a buffer</info>
      <return type='const xmlChar *' info='the internal content '/>
      <arg name='buf' type='const xmlBufferPtr' info='the buffer '/>
    </function>
    <function name='xmlBufferCreate' file='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr' info='the new structure. '/>
    </function>
    <function name='xmlBufferCreateSize' file='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr' info='the new structure. '/>
      <arg name='size' type='size_t' info='initial size of buffer '/>
    </function>
    <function name='xmlBufferDump' file='tree'>
      <info>Dumps an XML buffer to a FILE *.</info>
      <return type='int' info='the number of xmlChar written '/>
      <arg name='file' type='FILE *' info='the file output '/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump '/>
    </function>
    <function name='xmlBufferEmpty' file='tree'>
      <info>empty a buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer '/>
    </function>
    <function name='xmlBufferFree' file='tree'>
      <info>Frees an XML buffer. It frees both the content and the structure which encapsulate it.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to free '/>
    </function>
    <function name='xmlBufferGrow' file='tree'>
      <info>Grow the available space of an XML buffer.</info>
      <return type='int' info='the new available space or -1 in case of error '/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer '/>
      <arg name='len' type='unsigned int' info='the minimum free size to allocate '/>
    </function>
    <function name='xmlBufferLength' file='tree'>
      <info>Function to get the length of a buffer</info>
      <return type='int' info='the length of data in the internal content '/>
      <arg name='buf' type='const xmlBufferPtr' info='the buffer '/>
    </function>
    <typedef name='xmlBufferPtr' file='tree'/>
    <function name='xmlBufferResize' file='tree'>
      <info>Resize a buffer to accommodate minimum size of size.</info>
      <return type='int' info='0 in case of problems, 1 otherwise '/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to resize '/>
      <arg name='size' type='unsigned int' info='the desired size '/>
    </function>
    <function name='xmlBufferSetAllocationScheme' file='tree'>
      <info>Sets the allocation scheme for this buffer</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to tune '/>
      <arg name='scheme' type='xmlBufferAllocationScheme' info='allocation scheme to use '/>
    </function>
    <function name='xmlBufferShrink' file='tree'>
      <info>Remove the beginning of an XML buffer.</info>
      <return type='int' info='the number of xmlChar removed, or -1 in case of failure. '/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump '/>
      <arg name='len' type='unsigned int' info='the number of xmlChar to remove '/>
    </function>
    <function name='xmlBufferWriteCHAR' file='tree'>
      <info>routine which manages and grows an output buffer. This one adds xmlChars at the end of the buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer '/>
      <arg name='string' type='const xmlChar *' info='the string to add '/>
    </function>
    <function name='xmlBufferWriteChar' file='tree'>
      <info>routine which manage and grows an output buffer. This one add C chars at the end of the array.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='string' type='const char *' info='the string to add '/>
    </function>
    <function name='xmlBufferWriteQuotedString' file='tree'>
      <info>routine which manage and grows an output buffer. This one writes a quoted or double quoted xmlChar string, checking first if it holds quote or double-quotes internally</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='string' type='const xmlChar *' info='the string to add '/>
    </function>
    <function name='xmlBufferWriteXmlCHAR' file='tree'>
      <info>For VMS only. routine which manages and grows an output buffer. This one adds xmlChars at the end of the buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer '/>
      <arg name='string' type='const xmlChar *' info='the string to add '/>
    </function>
    <function name='xmlBuildURI' file='uri'>
      <info>Computes he final URI of the reference done by checking that the given URI is valid, and building the final URI using the base URI. This is processed according to section 5.2 of the RFC 2396 </info>
      <return type='xmlChar *' info='a new URI string (to be freed by the caller) or NULL in case of error. '/>
      <arg name='URI' type='const xmlChar *' info='the URI instance found in the document '/>
      <arg name='base' type='const xmlChar *' info='the base value '/>
    </function>
    <function name='xmlC14NDocDumpMemory' file='c14n'>
      <info>Dumps the canonized image of given XML document into memory. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='the number of bytes written on success or a negative value on fail '/>
      <arg name='doc' type='xmlDocPtr' info='		the XML document for canonization '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='		the nodes set to be included in the canonized image or NULL if all document nodes should be included '/>
      <arg name='exclusive' type='int' info='		the exclusive flag (0 - non-exclusive canonicalization; otherwise - exclusive canonicalization) '/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) '/>
      <arg name='with_comments' type='int' info='	include comments in the result (!=0) or not (==0) '/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='	the memory pointer for allocated canonical XML text; the caller of this functions is responsible for calling xmlFree() to free allocated memory '/>
    </function>
    <function name='xmlC14NDocSave' file='c14n'>
      <info>Dumps the canonized image of given XML document into the file. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='the number of bytes written success or a negative value on fail '/>
      <arg name='doc' type='xmlDocPtr' info='		the XML document for canonization '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='		the nodes set to be included in the canonized image or NULL if all document nodes should be included '/>
      <arg name='exclusive' type='int' info='		the exclusive flag (0 - non-exclusive canonicalization; otherwise - exclusive canonicalization) '/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) '/>
      <arg name='with_comments' type='int' info='	include comments in the result (!=0) or not (==0) '/>
      <arg name='filename' type='const char*' info='		the filename to store canonical XML image '/>
      <arg name='compression' type='int' info='	the compression level (zlib requred): -1 - libxml default, 0 - uncompressed, &gt;0 - compression level '/>
    </function>
    <function name='xmlC14NDocSaveTo' file='c14n'>
      <info>Dumps the canonized image of given XML document into the provided buffer. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='non-negative value on success or a negative value on fail '/>
      <arg name='doc' type='xmlDocPtr' info='		the XML document for canonization '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='		the nodes set to be included in the canonized image or NULL if all document nodes should be included '/>
      <arg name='exclusive' type='int' info='		the exclusive flag (0 - non-exclusive canonicalization; otherwise - exclusive canonicalization) '/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) '/>
      <arg name='with_comments' type='int' info='	include comments in the result (!=0) or not (==0) '/>
      <arg name='buf' type='xmlOutputBufferPtr' info='		the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output '/>
    </function>
    <function name='xmlC14NExecute' file='c14n'>
      <info>Dumps the canonized image of given XML document into the provided buffer. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='non-negative value on success or a negative value on fail '/>
      <arg name='doc' type='xmlDocPtr' info='		the XML document for canonization '/>
      <arg name='is_visible_callback' type='xmlC14NIsVisibleCallback' info='the function to use to determine is node visible or not '/>
      <arg name='user_data' type='void*' info='is_visible_callback function (in most cases, it is nodes set) '/>
      <arg name='exclusive' type='int' info='		the exclusive flag (0 - non-exclusive canonicalization; otherwise - exclusive canonicalization) '/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) '/>
      <arg name='with_comments' type='int' info='	include comments in the result (!=0) or not (==0) '/>
      <arg name='buf' type='xmlOutputBufferPtr' info='		the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output '/>
    </function>
    <functype name='xmlC14NIsVisibleCallback' file='c14n'>
      <return type='int'/>
      <arg name='user_data' type='void*'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='parent' type='xmlNodePtr'/>
    </functype>
    <struct name='xmlCatalog' file='catalog'/>
    <function name='xmlCatalogAdd' file='catalog'>
      <info>Add an entry in the catalog, it may overwrite existing but different entries. If called before any other catalog routine, allows to override the default shared catalog put in place by xmlInitializeCatalog();</info>
      <return type='int' info='0 if successful, -1 otherwise '/>
      <arg name='type' type='const xmlChar *' info='the type of record to add to the catalog '/>
      <arg name='orig' type='const xmlChar *' info='the system, public or prefix to match '/>
      <arg name='replace' type='const xmlChar *' info='the replacement value for the match '/>
    </function>
    <function name='xmlCatalogAddLocal' file='catalog'>
      <info>Add the new entry to the catalog list</info>
      <return type='void *'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs '/>
      <arg name='URL' type='const xmlChar *' info='the URL to a new local catalog '/>
    </function>
    <enum name='xmlCatalogAllow' file='catalog'/>
    <function name='xmlCatalogCleanup' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
    </function>
    <function name='xmlCatalogConvert' file='catalog'>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int' info='the number of entries converted if successful, -1 otherwise '/>
    </function>
    <function name='xmlCatalogDump' file='catalog'>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
      <arg name='out' type='FILE *' info='the file. '/>
    </function>
    <function name='xmlCatalogFreeLocal' file='catalog'>
      <info>Free up the memory associated to the catalog list</info>
      <return type='void'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs '/>
    </function>
    <function name='xmlCatalogGetDefaults' file='catalog'>
      <info>Used to get the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='xmlCatalogAllow' info='the current xmlCatalogAllow value '/>
    </function>
    <function name='xmlCatalogGetPublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID DEPRECATED, use xmlCatalogResolvePublic()</info>
      <return type='const xmlChar *' info='the system ID if found or NULL otherwise. '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
    </function>
    <function name='xmlCatalogGetSystem' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID DEPRECATED, use xmlCatalogResolveSystem()</info>
      <return type='const xmlChar *' info='the system ID if found or NULL otherwise. '/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string '/>
    </function>
    <function name='xmlCatalogIsEmpty' file='catalog'>
      <info>Check is a catalog is empty</info>
      <return type='int' info='1 if the catalog is empty, 0 if not, amd -1 in case of error. '/>
      <arg name='catal' type='xmlCatalogPtr' info='should this create an SGML catalog '/>
    </function>
    <function name='xmlCatalogLocalResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier using a document&apos;s private catalog list</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string '/>
    </function>
    <function name='xmlCatalogLocalResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI using a document&apos;s private catalog list</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs '/>
      <arg name='URI' type='const xmlChar *' info='the URI '/>
    </function>
    <enum name='xmlCatalogPrefer' file='catalog'/>
    <typedef name='xmlCatalogPtr' file='catalog'/>
    <function name='xmlCatalogRemove' file='catalog'>
      <info>Remove an entry from the catalog</info>
      <return type='int' info='the number of entries removed if successful, -1 otherwise '/>
      <arg name='value' type='const xmlChar *' info='the value to remove '/>
    </function>
    <function name='xmlCatalogResolve' file='catalog'>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string '/>
    </function>
    <function name='xmlCatalogResolvePublic' file='catalog'>
      <info>Try to lookup the system ID associated to a public ID</info>
      <return type='xmlChar *' info='the system ID if found or NULL otherwise, the value returned must be freed by the caller. '/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string '/>
    </function>
    <function name='xmlCatalogResolveSystem' file='catalog'>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *' info='the system ID if found or NULL otherwise, the value returned must be freed by the caller. '/>
      <arg name='sysID' type='const xmlChar *' info='the public ID string '/>
    </function>
    <function name='xmlCatalogResolveURI' file='catalog'>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller. '/>
      <arg name='URI' type='const xmlChar *' info='the URI '/>
    </function>
    <function name='xmlCatalogSetDebug' file='catalog'>
      <info>Used to set the debug level for catalog operation, 0 disable debugging, 1 enable it</info>
      <return type='int' info='the previous value of the catalog debugging level '/>
      <arg name='level' type='int' info='the debug level of catalogs required '/>
    </function>
    <function name='xmlCatalogSetDefaultPrefer' file='catalog'>
      <info>Allows to set the preference between public and system for deletion in XML Catalog resolution. C.f. section 4.1.1 of the spec Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM</info>
      <return type='xmlCatalogPrefer' info='the previous value of the default preference for delegation '/>
      <arg name='prefer' type='xmlCatalogPrefer' info='the default preference for delegation '/>
    </function>
    <function name='xmlCatalogSetDefaults' file='catalog'>
      <info>Used to set the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='void'/>
      <arg name='allow' type='xmlCatalogAllow' info='what catalogs should be accepted '/>
    </function>
    <typedef name='xmlChar' file='tree' info='This is a basic byte in an UTF-8 encoded string. It&apos;s unsigned allowing to pinpoint case where char * are assigned to xmlChar * (possibly making serialization back impossible).'/>
    <function name='xmlCharEncCloseFunc' file='encoding'>
      <info>Generic front-end for encoding handler close function</info>
      <return type='int' info='0 if success, or -1 in case of error '/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='	char enconding transformation data structure '/>
    </function>
    <function name='xmlCharEncFirstLine' file='encoding'>
      <info>Front-end for the encoding handler input function, but handle only the very first line, i.e. limit itself to 45 chars.</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or '/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='	char enconding transformation data structure '/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output. '/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input '/>
    </function>
    <function name='xmlCharEncInFunc' file='encoding'>
      <info>Generic front-end for the encoding handler input function</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or '/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='	char encoding transformation data structure '/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output. '/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input '/>
    </function>
    <function name='xmlCharEncOutFunc' file='encoding'>
      <info>Generic front-end for the encoding handler output function a first call with in == NULL has to be made firs to initiate the output in case of non-stateless encoding needing to initiate their state or the output (like the BOM in UTF16). In case of UTF8 sequence conversion errors for the given encoder, the content will be automatically remapped to a CharRef sequence.</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or '/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='	char enconding transformation data structure '/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output. '/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input '/>
    </function>
    <enum name='xmlCharEncoding' file='encoding'/>
    <struct name='xmlCharEncodingHandler' file='encoding'/>
    <typedef name='xmlCharEncodingHandlerPtr' file='encoding'/>
    <functype name='xmlCharEncodingInputFunc' file='encoding'>
      <info>Take a block of chars in the original encoding and try to convert it to an UTF-8 block of chars out.</info>
      <return type='int' info='outlen after return is the number of octets consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the UTF-8 result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of chars in the original encoding '/>
      <arg name='inlen' type='int *' info='in '/>
    </functype>
    <functype name='xmlCharEncodingOutputFunc' file='encoding'>
      <info>Take a block of UTF-8 chars in and try to convert it to an other encoding. Note: a first call designed to produce heading info is called with in = NULL. If stateful this should also initialize the encoder state.</info>
      <return type='int' info='outlen after return is the number of ocetes consumed. '/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result '/>
      <arg name='outlen' type='int *' info='out '/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars '/>
      <arg name='inlen' type='int *' info='in '/>
    </functype>
    <function name='xmlCharStrdup' file='parser'>
      <info>a strdup for char&apos;s to xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL '/>
      <arg name='cur' type='const char *' info='the input char * '/>
    </function>
    <function name='xmlCharStrndup' file='parser'>
      <info>a strndup for char&apos;s to xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL '/>
      <arg name='cur' type='const char *' info='the input char * '/>
      <arg name='len' type='int' info='cur '/>
    </function>
    <function name='xmlCheckLanguageID' file='parserInternals'>
      <info>Checks that the value conforms to the LanguageID production: </info>
      <return type='int' info='1 if correct 0 otherwise '/>
      <arg name='lang' type='const xmlChar *' info='pointer to the string value '/>
    </function>
    <function name='xmlCheckUTF8' file='encoding'>
      <info>Checks utf for being valid utf-8. utf is assumed to be null-terminated. This function is not super-strict, as it will allow longer utf-8 sequences than necessary. Note that Java is capable of producing these sequences if provoked. Also note, this routine checks for the 4-byte maximum size, but does not check for 0x10ffff maximum value.</info>
      <return type='int' info='utf is valid. '/>
      <arg name='utf' type='const unsigned char *' info='Pointer to putative utf-8 encoded string. '/>
    </function>
    <function name='xmlCheckVersion' file='xmlversion'>
      <info>check the compiled lib version against the include one. This can warn or immediately kill the application</info>
      <return type='void'/>
      <arg name='version' type='int' info='the include version number '/>
    </function>
    <macro name='xmlChildrenNode' file='tree'>
      <info>Macro for compatibility naming layer with libxml1.</info>
    </macro>
    <function name='xmlCleanupCharEncodingHandlers' file='encoding'>
      <info>Cleanup the memory allocated for the char encoding support, it unregisters all the encoding handlers and the aliases.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupEncodingAliases' file='encoding'>
      <info>Unregisters all aliases</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupInputCallbacks' file='xmlIO'>
      <info>clears the entire input callback table. this includes the compiled-in I/O.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupOutputCallbacks' file='xmlIO'>
      <info>clears the entire output callback table. this includes the compiled-in I/O callbacks.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupParser' file='parser'>
      <info>Cleanup function for the XML parser. It tries to reclaim all parsing related global memory allocated for the parser processing. It doesn&apos;t deallocate any document related memory. Calling this function should not prevent reusing the parser.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupPredefinedEntities' file='entities'>
      <info>Cleanup up the predefined entities table.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupThreads' file='threads'>
      <info>xmlCleanupThreads() is used to to cleanup all the thread related data of the libxml2 library once processing has ended.</info>
      <return type='void'/>
    </function>
    <function name='xmlClearNodeInfoSeq' file='parser'>
      <info>-- Clear (release memory and reinitialize) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr' info='a node info sequence pointer '/>
    </function>
    <function name='xmlClearParserCtxt' file='parser'>
      <info>Clear (release owned resources) and reinitialize a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlConvertSGMLCatalog' file='catalog'>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int' info='the number of entries converted if successful, -1 otherwise '/>
      <arg name='catal' type='xmlCatalogPtr' info='the catalog '/>
    </function>
    <function name='xmlCopyAttributeTable' file='valid'>
      <info>Build a copy of an attribute table.</info>
      <return type='xmlAttributeTablePtr' info='the new xmlAttributeTablePtr or NULL in case of error. '/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table '/>
    </function>
    <function name='xmlCopyChar' file='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int' info='the number of xmlChar written '/>
      <arg name='len' type='int' info='Ignored, compatibility '/>
      <arg name='out' type='xmlChar *' info='pointer to an array of xmlChar '/>
      <arg name='val' type='int' info='the char value '/>
    </function>
    <function name='xmlCopyCharMultiByte' file='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int' info='the number of xmlChar written '/>
      <arg name='out' type='xmlChar *' info='pointer to an array of xmlChar '/>
      <arg name='val' type='int' info='the char value '/>
    </function>
    <function name='xmlCopyDoc' file='tree'>
      <info>Do a copy of the document info. If recursive, the content tree will be copied too as well as DTD, namespaces and entities.</info>
      <return type='xmlDocPtr' info='a new xmlDocPtr, or NULL in case of error. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='recursive' type='int' info='if 1 do a recursive copy. '/>
    </function>
    <function name='xmlCopyDtd' file='tree'>
      <info>Do a copy of the dtd.</info>
      <return type='xmlDtdPtr' info='a new xmlDtdPtr, or NULL in case of error. '/>
      <arg name='dtd' type='xmlDtdPtr' info='the dtd '/>
    </function>
    <function name='xmlCopyElementContent' file='valid'>
      <info>Build a copy of an element content description.</info>
      <return type='xmlElementContentPtr' info='the new xmlElementContentPtr or NULL in case of error. '/>
      <arg name='content' type='xmlElementContentPtr' info='An element content pointer. '/>
    </function>
    <function name='xmlCopyElementTable' file='valid'>
      <info>Build a copy of an element table.</info>
      <return type='xmlElementTablePtr' info='the new xmlElementTablePtr or NULL in case of error. '/>
      <arg name='table' type='xmlElementTablePtr' info='An element table '/>
    </function>
    <function name='xmlCopyEntitiesTable' file='entities'>
      <info>Build a copy of an entity table.</info>
      <return type='xmlEntitiesTablePtr' info='the new xmlEntitiesTablePtr or NULL in case of error. '/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table '/>
    </function>
    <function name='xmlCopyEnumeration' file='valid'>
      <info>Copy an enumeration attribute node (recursive).</info>
      <return type='xmlEnumerationPtr' info='the xmlEnumerationPtr just created or NULL in case of error. '/>
      <arg name='cur' type='xmlEnumerationPtr' info='the tree to copy. '/>
    </function>
    <function name='xmlCopyNamespace' file='tree'>
      <info>Do a copy of the namespace.</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error. '/>
      <arg name='cur' type='xmlNsPtr' info='the namespace '/>
    </function>
    <function name='xmlCopyNamespaceList' file='tree'>
      <info>Do a copy of an namespace list.</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error. '/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace '/>
    </function>
    <function name='xmlCopyNode' file='tree'>
      <info>Do a copy of the node.</info>
      <return type='xmlNodePtr' info='a new xmlNodePtr, or NULL in case of error. '/>
      <arg name='node' type='const xmlNodePtr' info='the node '/>
      <arg name='recursive' type='int' info='if 1 do a recursive copy. '/>
    </function>
    <function name='xmlCopyNodeList' file='tree'>
      <info>Do a recursive copy of the node list.</info>
      <return type='xmlNodePtr' info='a new xmlNodePtr, or NULL in case of error. '/>
      <arg name='node' type='const xmlNodePtr' info='the first node in the list. '/>
    </function>
    <function name='xmlCopyNotationTable' file='valid'>
      <info>Build a copy of a notation table.</info>
      <return type='xmlNotationTablePtr' info='the new xmlNotationTablePtr or NULL in case of error. '/>
      <arg name='table' type='xmlNotationTablePtr' info='A notation table '/>
    </function>
    <function name='xmlCopyProp' file='tree'>
      <info>Do a copy of the attribute.</info>
      <return type='xmlAttrPtr' info='a new xmlAttrPtr, or NULL in case of error. '/>
      <arg name='target' type='xmlNodePtr' info='the element where the attribute will be grafted '/>
      <arg name='cur' type='xmlAttrPtr' info='the attribute '/>
    </function>
    <function name='xmlCopyPropList' file='tree'>
      <info>Do a copy of an attribute list.</info>
      <return type='xmlAttrPtr' info='a new xmlAttrPtr, or NULL in case of error. '/>
      <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted '/>
      <arg name='cur' type='xmlAttrPtr' info='the first attribute '/>
    </function>
    <function name='xmlCreateDocParserCtxt' file='parser'>
      <info>Creates a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
    </function>
    <function name='xmlCreateEntitiesTable' file='entities'>
      <info>create and initialize an empty entities hash table.</info>
      <return type='xmlEntitiesTablePtr' info='the xmlEntitiesTablePtr just created or NULL in case of error. '/>
    </function>
    <function name='xmlCreateEntityParserCtxt' file='parserInternals'>
      <info>Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='URL' type='const xmlChar *' info='the entity URL '/>
      <arg name='ID' type='const xmlChar *' info='the entity PUBLIC ID '/>
      <arg name='base' type='const xmlChar *' info='a possible base for the target URI '/>
    </function>
    <function name='xmlCreateEnumeration' file='valid'>
      <info>create and initialize an enumeration attribute node.</info>
      <return type='xmlEnumerationPtr' info='the xmlEnumerationPtr just created or NULL in case of error. '/>
      <arg name='name' type='xmlChar *' info='the enumeration name or NULL '/>
    </function>
    <function name='xmlCreateFileParserCtxt' file='parserInternals'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlCreateIOParserCtxt' file='parser'>
      <info>Create a parser context for using the XML parser with an existing I/O stream</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function '/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function '/>
      <arg name='ioctx' type='void *' info='an I/O handler '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlCreateIntSubset' file='tree'>
      <info>Create the internal subset of a document</info>
      <return type='xmlDtdPtr' info='a pointer to the new DTD structure '/>
      <arg name='doc' type='xmlDocPtr' info='the document pointer '/>
      <arg name='name' type='const xmlChar *' info='the DTD name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external (PUBLIC) ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the system ID '/>
    </function>
    <function name='xmlCreateMemoryParserCtxt' file='parserInternals'>
      <info>Create a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='buffer' type='const char *' info='a pointer to a char array '/>
      <arg name='size' type='int' info='the size of the array '/>
    </function>
    <function name='xmlCreatePushParserCtxt' file='parser'>
      <info>Create a parser context for using the XML parser in push mode To allow content encoding detection, size should be &gt;= 4 The value of filename is used for fetching external entities and error/warning reports.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars '/>
      <arg name='size' type='int' info='number of chars in the array '/>
      <arg name='filename' type='const char *' info='an optional file name or URI '/>
    </function>
    <function name='xmlCreateURI' file='uri'>
      <info>Simply creates an empty xmlURI</info>
      <return type='xmlURIPtr' info='the new structure or NULL in case of error '/>
    </function>
    <function name='xmlCurrentChar' file='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer. Implement the end of line normalization: 2.11 End-of-Line Handling Wherever an external parsed entity or the literal entity value of an internal parsed entity contains either the literal two-character sequence &quot;xDxA&quot; or a standalone literal xD, an XML processor must pass to the application the single character xA. This behavior can conveniently be produced by normalizing all line breaks to xA on input, before parsing.)</info>
      <return type='int' info='the current char value and its length '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context '/>
      <arg name='len' type='int *' info='pointer to the length of the char read '/>
    </function>
    <function name='xmlDebugDumpAttr' file='debugXML'>
      <info>Dumps debug information for the attribute</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlDebugDumpAttrList' file='debugXML'>
      <info>Dumps debug information for the attribute list</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute list '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlDebugDumpDTD' file='debugXML'>
      <info>Dumps debug information for the DTD</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='dtd' type='xmlDtdPtr' info='the DTD '/>
    </function>
    <function name='xmlDebugDumpDocument' file='debugXML'>
      <info>Dumps debug information for the document, it&apos;s recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlDebugDumpDocumentHead' file='debugXML'>
      <info>Dumps debug information cncerning the document, not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlDebugDumpEntities' file='debugXML'>
      <info>Dumps debug information for all the entities in use by the document</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlDebugDumpNode' file='debugXML'>
      <info>Dumps debug information for the element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlDebugDumpNodeList' file='debugXML'>
      <info>Dumps debug information for the list of element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='node' type='xmlNodePtr' info='the node list '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlDebugDumpOneNode' file='debugXML'>
      <info>Dumps debug information for the element node, it is not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlDebugDumpString' file='debugXML'>
      <info>Dumps informations about the string, shorten it if necessary</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='str' type='const xmlChar *' info='the string '/>
    </function>
    <function name='xmlDecodeEntities' file='parserInternals'>
      <info>This function is deprecated, we now always process entities content through xmlStringDecodeEntities </info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it ! '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
      <arg name='len' type='int' info='the len to decode (in bytes !), -1 for no size limit '/>
      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF '/>
      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
    </function>
    <macro name='xmlDefaultBufferSize' file='globals'>
      <info>Global setting, default buffer size. Default value is BASE_BUFFER_SIZE</info>
    </macro>
    <macro name='xmlDefaultSAXHandler' file='globals'>
      <info>Default handler for XML, builds the DOM tree</info>
    </macro>
    <function name='xmlDefaultSAXHandlerInit' file='SAX'>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
    </function>
    <macro name='xmlDefaultSAXLocator' file='globals'>
      <info>The default SAX Locator { getPublicId, getSystemId, getLineNumber, getColumnNumber}</info>
    </macro>
    <function name='xmlDelEncodingAlias' file='encoding'>
      <info>Unregisters an encoding alias alias</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually) '/>
    </function>
    <function name='xmlDetectCharEncoding' file='encoding'>
      <info>Guess the encoding of the entity using the first bytes of the entity content accordingly of the non-normative appendix F of the XML-1.0 recommendation.</info>
      <return type='xmlCharEncoding' info='one of the XML_CHAR_ENCODING_... values. '/>
      <arg name='in' type='const unsigned char *' info='a pointer to the first bytes of the XML entity, must be at least 4 bytes long. '/>
      <arg name='len' type='int' info='pointer to the length of the buffer '/>
    </function>
    <macro name='xmlDoValidityCheckingDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser should work in validating mode. Disabled by default.</info>
    </macro>
    <struct name='xmlDoc' file='tree' info='An XML document.'/>
    <function name='xmlDocCopyNode' file='tree'>
      <info>Do a copy of the node to a given document.</info>
      <return type='xmlNodePtr' info='a new xmlNodePtr, or NULL in case of error. '/>
      <arg name='node' type='const xmlNodePtr' info='the node '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='recursive' type='int' info='if 1 do a recursive copy. '/>
    </function>
    <function name='xmlDocDump' file='tree'>
      <info>Dump an XML document to an open FILE.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='f' type='FILE *' info='the FILE* '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlDocDumpFormatMemory' file='tree'>
      <info>Dump an XML document in memory and return the xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory with xmlFree(). Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer '/>
      <arg name='size' type='int *' info='OUT: the memory length '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='xmlDocDumpFormatMemoryEnc' file='tree'>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller. Note it is up to the caller of this function to free the allocated memory with xmlFree(). Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='out_doc' type='xmlDocPtr' info='Document to generate XML text from '/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text '/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text '/>
      <arg name='txt_encoding' type='const char *' info='Character encoding to use when generating XML text '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='xmlDocDumpMemory' file='tree'>
      <info>Dump an XML document in memory and return the xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory with xmlFree().</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer '/>
      <arg name='size' type='int *' info='OUT: the memory length '/>
    </function>
    <function name='xmlDocDumpMemoryEnc' file='tree'>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller. Note it is up to the caller of this function to free the allocated memory with xmlFree().</info>
      <return type='void'/>
      <arg name='out_doc' type='xmlDocPtr' info='Document to generate XML text from '/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text '/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text '/>
      <arg name='txt_encoding' type='const char *' info='Character encoding to use when generating XML text '/>
    </function>
    <function name='xmlDocFormatDump' file='tree'>
      <info>Dump an XML document to an open FILE.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='f' type='FILE *' info='the FILE* '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='xmlDocGetRootElement' file='tree'>
      <info>Get the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr' info='the xmlNodePtr for the root or NULL '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <typedef name='xmlDocPtr' file='tree'/>
    <function name='xmlDocSetRootElement' file='tree'>
      <info>Set the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr' info='the old root element if any was found '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='root' type='xmlNodePtr' info='the new document root element '/>
    </function>
    <struct name='xmlDtd' file='tree' info='An XML DTD, as defined by &lt;!DOCTYPE ... There is actually one for the internal subset and for the external subset.'/>
    <typedef name='xmlDtdPtr' file='tree'/>
    <function name='xmlDumpAttributeDecl' file='valid'>
      <info>This will dump the content of the attribute declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='attr' type='xmlAttributePtr' info='An attribute declaration '/>
    </function>
    <function name='xmlDumpAttributeTable' file='valid'>
      <info>This will dump the content of the attribute table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table '/>
    </function>
    <function name='xmlDumpElementDecl' file='valid'>
      <info>This will dump the content of the element declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='elem' type='xmlElementPtr' info='An element table '/>
    </function>
    <function name='xmlDumpElementTable' file='valid'>
      <info>This will dump the content of the element table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='table' type='xmlElementTablePtr' info='An element table '/>
    </function>
    <function name='xmlDumpEntitiesTable' file='entities'>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='An XML buffer. '/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table '/>
    </function>
    <function name='xmlDumpEntityDecl' file='entities'>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='An XML buffer. '/>
      <arg name='ent' type='xmlEntityPtr' info='An entity table '/>
    </function>
    <function name='xmlDumpNotationDecl' file='valid'>
      <info>This will dump the content the notation declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='nota' type='xmlNotationPtr' info='A notation declaration '/>
    </function>
    <function name='xmlDumpNotationTable' file='valid'>
      <info>This will dump the content of the notation table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='table' type='xmlNotationTablePtr' info='A notation table '/>
    </function>
    <function name='xmlElemDump' file='tree'>
      <info>Dump an XML/HTML node, recursive behaviour, children are printed too.</info>
      <return type='void'/>
      <arg name='f' type='FILE *' info='the FILE * for the output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
    </function>
    <struct name='xmlElement' file='tree' info='An XML Element declaration from a DTD.'/>
    <struct name='xmlElementContent' file='tree' info='An XML Element content as stored after parsing an element definition in a DTD.'/>
    <enum name='xmlElementContentOccur' file='tree'/>
    <typedef name='xmlElementContentPtr' file='tree'/>
    <enum name='xmlElementContentType' file='tree'/>
    <typedef name='xmlElementPtr' file='tree'/>
    <typedef name='xmlElementTablePtr' file='valid'/>
    <enum name='xmlElementType' file='tree'/>
    <enum name='xmlElementTypeVal' file='tree'/>
    <function name='xmlEncodeEntities' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. </info>
      <return type='const xmlChar *' info='A newly allocated string with the substitution done. '/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the string '/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML. '/>
    </function>
    <function name='xmlEncodeEntitiesReentrant' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. Contrary to xmlEncodeEntities, this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. '/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the string '/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML. '/>
    </function>
    <function name='xmlEncodeSpecialChars' file='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. '/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the string '/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML. '/>
    </function>
    <typedef name='xmlEntitiesTablePtr' file='entities'/>
    <struct name='xmlEntity' file='tree'/>
    <typedef name='xmlEntityPtr' file='tree'/>
    <functype name='xmlEntityReferenceFunc' file='parserInternals'>
      <info>Callback function used when one needs to be able to track back the provenance of a chunk of nodes inherited from an entity replacement.</info>
      <return type='void'/>
      <arg name='ent' type='xmlEntityPtr' info='the entity '/>
      <arg name='firstNode' type='xmlNodePtr' info='the fist node in the chunk '/>
      <arg name='lastNode' type='xmlNodePtr' info='the last nod in the chunk '/>
    </functype>
    <enum name='xmlEntityType' file='entities'/>
    <struct name='xmlEnumeration' file='tree' info='List structure used when there is an enumeration in DTDs.'/>
    <typedef name='xmlEnumerationPtr' file='tree'/>
    <functype name='xmlExternalEntityLoader' file='parser'>
      <info>External entity loaders types.</info>
      <return type='xmlParserInputPtr' info='the entity input parser. '/>
      <arg name='URL' type='const char *' info='The System ID of the resource requested '/>
      <arg name='ID' type='const char *' info='The Public ID of the resource requested '/>
      <arg name='context' type='xmlParserCtxtPtr' info='the XML parser context '/>
    </functype>
    <function name='xmlFileClose' file='xmlIO'>
      <info>Close an I/O channel</info>
      <return type='int'/>
      <arg name='context' type='void *' info='the I/O context '/>
    </function>
    <function name='xmlFileMatch' file='xmlIO'>
      <info>input from FILE *</info>
      <return type='int' info='1 if matches, 0 otherwise '/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlFileOpen' file='xmlIO'>
      <info>input from FILE *, supports compressed input if filename is &quot; &quot; then the standard input is used</info>
      <return type='void *'/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlFileRead' file='xmlIO'>
      <info>Read len bytes to buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written '/>
      <arg name='context' type='void *' info='the I/O context '/>
      <arg name='buffer' type='char *' info='where to drop data '/>
      <arg name='len' type='int' info='number of bytes to write '/>
    </function>
    <function name='xmlFindCharEncodingHandler' file='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the handler or NULL if not found '/>
      <arg name='name' type='const char *' info='a string describing the char encoding. '/>
    </function>
    <macro name='xmlFree' file='globals'>
      <info>The variable holding the libxml free() implementation</info>
    </macro>
    <function name='xmlFreeAttributeTable' file='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table '/>
    </function>
    <function name='xmlFreeAutomata' file='xmlautomata'>
      <info>Free an automata</info>
      <return type='void'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata '/>
    </function>
    <function name='xmlFreeCatalog' file='catalog'>
      <info>Free the memory allocated to a Catalog</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog entry '/>
    </function>
    <function name='xmlFreeDoc' file='tree'>
      <info>Free up all the structures used by a document, tree included.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='pointer to the document '/>
    </function>
    <function name='xmlFreeDtd' file='tree'>
      <info>Free a DTD structure.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDtdPtr' info='the DTD structure to free up '/>
    </function>
    <function name='xmlFreeElementContent' file='valid'>
      <info>Free an element content structure. This is a recursive call !</info>
      <return type='void'/>
      <arg name='cur' type='xmlElementContentPtr' info='the element content tree to free '/>
    </function>
    <function name='xmlFreeElementTable' file='valid'>
      <info>Deallocate the memory used by an element hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlElementTablePtr' info='An element table '/>
    </function>
    <function name='xmlFreeEntitiesTable' file='entities'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table '/>
    </function>
    <function name='xmlFreeEnumeration' file='valid'>
      <info>free an enumeration attribute node (recursive).</info>
      <return type='void'/>
      <arg name='cur' type='xmlEnumerationPtr' info='the tree to free. '/>
    </function>
    <functype name='xmlFreeFunc' file='xmlmemory'>
      <info>Signature for a free() implementation.</info>
      <return type='void'/>
      <arg name='mem' type='void *' info='an already allocated block of memory '/>
    </functype>
    <function name='xmlFreeIDTable' file='valid'>
      <info>Deallocate the memory used by an ID hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlIDTablePtr' info='An id table '/>
    </function>
    <function name='xmlFreeInputStream' file='parserInternals'>
      <info>Free up an input stream.</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr '/>
    </function>
    <function name='xmlFreeMutex' file='threads'>
      <info>xmlFreeMutex() is used to reclaim resources associated with a libxml2 token struct.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex '/>
    </function>
    <function name='xmlFreeNode' file='tree'>
      <info>Free a node, this is a recursive behaviour, all the children are freed too. This doesn&apos;t unlink the child from the list, use xmlUnlinkNode() first.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node '/>
    </function>
    <function name='xmlFreeNodeList' file='tree'>
      <info>Free a node and all its siblings, this is a recursive behaviour, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the first node in the list '/>
    </function>
    <function name='xmlFreeNotationTable' file='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlNotationTablePtr' info='An notation table '/>
    </function>
    <function name='xmlFreeNs' file='tree'>
      <info>Free up the structures associated to a namespace</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr' info='the namespace pointer '/>
    </function>
    <function name='xmlFreeNsList' file='tree'>
      <info>Free up all the structures associated to the chained namespaces.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace pointer '/>
    </function>
    <function name='xmlFreeParserCtxt' file='parser'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlFreeParserInputBuffer' file='xmlIO'>
      <info>Free up the memory used by a buffered parser input</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input '/>
    </function>
    <function name='xmlFreeProp' file='tree'>
      <info>Free one attribute, all the content is freed too</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr' info='an attribute '/>
    </function>
    <function name='xmlFreePropList' file='tree'>
      <info>Free a property and all its siblings, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr' info='the first property in the list '/>
    </function>
    <function name='xmlFreeRMutex' file='threads'>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr'/>
    </function>
    <function name='xmlFreeRefTable' file='valid'>
      <info>Deallocate the memory used by an Ref hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlRefTablePtr' info='An ref table '/>
    </function>
    <function name='xmlFreeURI' file='uri'>
      <info>Free up the xmlURI struct</info>
      <return type='void'/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI '/>
    </function>
    <macro name='xmlGenericError' file='globals'>
      <info>Global setting: function used for generic error callbacks</info>
    </macro>
    <macro name='xmlGenericErrorContext' file='globals'>
      <info>Global setting passed to generic error callbacks</info>
    </macro>
    <functype name='xmlGenericErrorFunc' file='xmlerror'>
      <info>Signature of the function to use when there is an error and no parsing or validity context available .</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='a parsing context '/>
      <arg name='msg' type='const char *' info='the message '/>
      <arg name='' type='...'/>
    </functype>
    <function name='xmlGetBufferAllocationScheme' file='tree'>
      <info>Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, improves performance</info>
      <return type='xmlBufferAllocationScheme' info='the current allocation scheme '/>
    </function>
    <function name='xmlGetCharEncodingHandler' file='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the handler or NULL if not found '/>
      <arg name='enc' type='xmlCharEncoding' info='an xmlCharEncoding value. '/>
    </function>
    <function name='xmlGetCharEncodingName' file='encoding'>
      <info>The &quot;canonical&quot; name for XML encoding. C.f. http://www.w3.org/TR/REC-xmlcharencoding Section 4.3.3 Character Encoding in Entities</info>
      <return type='const char *' info='the canonical name for the given encoding '/>
      <arg name='enc' type='xmlCharEncoding' info='the encoding '/>
    </function>
    <function name='xmlGetCompressMode' file='tree'>
      <info>get the default compression mode used, ZLIB based.</info>
      <return type='int' info='0 (uncompressed) to 9 (max compression) '/>
    </function>
    <function name='xmlGetDocCompressMode' file='tree'>
      <info>get the compression ratio for a document, ZLIB based</info>
      <return type='int' info='0 (uncompressed) to 9 (max compression) '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlGetDocEntity' file='entities'>
      <info>Do an entity lookup in the document entity hash table and returns the corresponding entity, otherwise a lookup is done in the predefined entities too.</info>
      <return type='xmlEntityPtr' info='A pointer to the entity structure or NULL if not found. '/>
      <arg name='doc' type='xmlDocPtr' info='the document referencing the entity '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
    </function>
    <function name='xmlGetDtdAttrDesc' file='valid'>
      <info>Search the DTD for the description of this attribute on this element.</info>
      <return type='xmlAttributePtr' info='the xmlAttributePtr if found or NULL '/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search '/>
      <arg name='elem' type='const xmlChar *' info='the element name '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
    </function>
    <function name='xmlGetDtdElementDesc' file='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr' info='the xmlElementPtr if found or NULL '/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
    </function>
    <function name='xmlGetDtdEntity' file='entities'>
      <info>Do an entity lookup in the DTD entity hash table and returns the corresponding entity, if found. Note: the first argument is the document node, not the DTD node.</info>
      <return type='xmlEntityPtr' info='A pointer to the entity structure or NULL if not found. '/>
      <arg name='doc' type='xmlDocPtr' info='the document referencing the entity '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
    </function>
    <function name='xmlGetDtdNotationDesc' file='valid'>
      <info>Search the DTD for the description of this notation</info>
      <return type='xmlNotationPtr' info='the xmlNotationPtr if found or NULL '/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search '/>
      <arg name='name' type='const xmlChar *' info='the notation name '/>
    </function>
    <function name='xmlGetDtdQAttrDesc' file='valid'>
      <info>Search the DTD for the description of this qualified attribute on this element.</info>
      <return type='xmlAttributePtr' info='the xmlAttributePtr if found or NULL '/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search '/>
      <arg name='elem' type='const xmlChar *' info='the element name '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='prefix' type='const xmlChar *' info='the attribute namespace prefix '/>
    </function>
    <function name='xmlGetDtdQElementDesc' file='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr' info='the xmlElementPtr if found or NULL '/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix '/>
    </function>
    <function name='xmlGetEncodingAlias' file='encoding'>
      <info>Lookup an encoding name for the given alias.</info>
      <return type='const char *' info='NULL if not found the original name otherwise '/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually) '/>
    </function>
    <function name='xmlGetExternalEntityLoader' file='parser'>
      <info>Get the default external entity resolver function for the application</info>
      <return type='xmlExternalEntityLoader' info='the xmlExternalEntityLoader function pointer '/>
    </function>
    <function name='xmlGetFeature' file='parser'>
      <info>Read the current value of one feature of this parser instance</info>
      <return type='int' info='-1 in case or error, 0 otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context '/>
      <arg name='name' type='const char *' info='the feature name '/>
      <arg name='result' type='void *' info='location to store the result '/>
    </function>
    <function name='xmlGetFeaturesList' file='parser'>
      <info>Copy at most *len feature names into the result array</info>
      <return type='int' info='-1 in case or error, or the total number of features, len is updated with the number of strings copied, strings must not be deallocated '/>
      <arg name='len' type='int *' info='the length of the features name array (input/output) '/>
      <arg name='result' type='const char **' info='an array of string to be filled with the features name. '/>
    </function>
    <function name='xmlGetGlobalState' file='threads'>
      <info>xmlGetGlobalState() is called to retrieve the global state for a thread.</info>
      <return type='xmlGlobalStatePtr' info='the thread global state or NULL in case of error '/>
    </function>
    <function name='xmlGetID' file='valid'>
      <info>Search the attribute declaring the given ID</info>
      <return type='xmlAttrPtr' info='NULL if not found, otherwise the xmlAttrPtr defining the ID '/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document '/>
      <arg name='ID' type='const xmlChar *' info='the ID value '/>
    </function>
    <function name='xmlGetIntSubset' file='tree'>
      <info>Get the internal subset of a document</info>
      <return type='xmlDtdPtr' info='a pointer to the DTD structure or NULL if not found '/>
      <arg name='doc' type='xmlDocPtr' info='the document pointer '/>
    </function>
    <function name='xmlGetLastChild' file='tree'>
      <info>Search the last child of a node.</info>
      <return type='xmlNodePtr' info='the last child or NULL if none. '/>
      <arg name='parent' type='xmlNodePtr' info='the parent node '/>
    </function>
    <function name='xmlGetLineNo' file='tree'>
      <info>Get line number of node. this requires activation of this option before invoking the parser by calling xmlLineNumbersDefault(1)</info>
      <return type='long' info='the line number if successful, -1 otherwise '/>
      <arg name='node' type='xmlNodePtr' info='valid node '/>
    </function>
    <function name='xmlGetNodePath' file='tree'>
      <info>Build a structure based Path for the given node</info>
      <return type='xmlChar *' info='the new path or NULL in case of error. The caller must free the returned string '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlGetNsList' file='tree'>
      <info>Search all the namespace applying to a given element.</info>
      <return type='xmlNsPtr *' info='an NULL terminated array of all the xmlNsPtr found that need to be freed by the caller or NULL if no namespace if defined '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='node' type='xmlNodePtr' info='the current node '/>
    </function>
    <function name='xmlGetNsProp' file='tree'>
      <info>Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory with xmlFree(). '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace '/>
    </function>
    <function name='xmlGetParameterEntity' file='entities'>
      <info>Do an entity lookup in the internal and external subsets and returns the corresponding parameter entity, if found.</info>
      <return type='xmlEntityPtr' info='A pointer to the entity structure or NULL if not found. '/>
      <arg name='doc' type='xmlDocPtr' info='the document referencing the entity '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
    </function>
    <function name='xmlGetPredefinedEntity' file='entities'>
      <info>Check whether this name is an predefined entity.</info>
      <return type='xmlEntityPtr' info='NULL if not, otherwise the entity '/>
      <arg name='name' type='const xmlChar *' info='the entity name '/>
    </function>
    <function name='xmlGetProp' file='tree'>
      <info>Search and get the value of an attribute associated to a node This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory with xmlFree(). '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
    </function>
    <function name='xmlGetRefs' file='valid'>
      <info>Find the set of references for the supplied ID.</info>
      <return type='xmlListPtr' info='NULL if not found, otherwise node set for the ID. '/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document '/>
      <arg name='ID' type='const xmlChar *' info='the ID value '/>
    </function>
    <function name='xmlGetThreadId' file='threads'>
      <info>xmlGetThreadId() find the current thread ID number</info>
      <return type='int' info='the current thread ID number '/>
    </function>
    <macro name='xmlGetWarningsDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser should provide warnings. Activated by default.</info>
    </macro>
    <struct name='xmlGlobalState' file='globals'/>
    <typedef name='xmlGlobalStatePtr' file='globals'/>
    <function name='xmlHandleEntity' file='parserInternals'>
      <info>Default handling of defined entities, when should we define a new input stream ? When do we just handle that as a set of chars ? </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='entity' type='xmlEntityPtr' info='an XML entity pointer. '/>
    </function>
    <function name='xmlHasNsProp' file='tree'>
      <info>Search for an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlAttrPtr' info='the attribute or the attribute declaration or NULL if neither was found. '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace '/>
    </function>
    <function name='xmlHasProp' file='tree'>
      <info>Search an attribute associated to a node This function also looks in DTD attribute declaration for FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlAttrPtr' info='the attribute or the attribute declaration or NULL if neither was found. '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
    </function>
    <function name='xmlHashAddEntry' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the name. Duplicate names generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
    </function>
    <function name='xmlHashAddEntry2' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the (name, name2) tuple. Duplicate tuples generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
    </function>
    <function name='xmlHashAddEntry3' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the tuple (name, name2, name3). Duplicate entries generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
    </function>
    <functype name='xmlHashCopier' file='hash'>
      <info>Callback to copy data from a hash.</info>
      <return type='void *'/>
      <arg name='payload' type='void *' info='the data in the hash '/>
      <arg name='name' type='xmlChar *' info='the name associated '/>
    </functype>
    <function name='xmlHashCopy' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='xmlHashTablePtr' info='the new table or NULL in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='f' type='xmlHashCopier' info='the copier function for items in the hash '/>
    </function>
    <function name='xmlHashCreate' file='hash'>
      <info>Create a new xmlHashTablePtr.</info>
      <return type='xmlHashTablePtr' info='the newly created object, or NULL if an error occured. '/>
      <arg name='size' type='int' info='the size of the hash table '/>
    </function>
    <functype name='xmlHashDeallocator' file='hash'>
      <info>Callback to free data from a hash.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash '/>
      <arg name='name' type='xmlChar *' info='the name associated '/>
    </functype>
    <function name='xmlHashFree' file='hash'>
      <info>Free the hash table and its contents. The userdata is deallocated with f if provided.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for items in the hash '/>
    </function>
    <function name='xmlHashLookup' file='hash'>
      <info>Find the userdata specified by the name.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
    </function>
    <function name='xmlHashLookup2' file='hash'>
      <info>Find the userdata specified by the (name, name2) tuple.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
    </function>
    <function name='xmlHashLookup3' file='hash'>
      <info>Find the userdata specified by the (name, name2, name3) tuple.</info>
      <return type='void *'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata '/>
    </function>
    <function name='xmlHashRemoveEntry' file='hash'>
      <info>Find the userdata specified by the name and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any) '/>
    </function>
    <function name='xmlHashRemoveEntry2' file='hash'>
      <info>Find the userdata specified by the (name, name2) tuple and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any) '/>
    </function>
    <function name='xmlHashRemoveEntry3' file='hash'>
      <info>Find the userdata specified by the (name, name2, name3) tuple and remove it from the hash table. Existing userdata for this tuple will be removed and freed with f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any) '/>
    </function>
    <function name='xmlHashScan' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='f' type='xmlHashScanner' info='the scanner function for items in the hash '/>
      <arg name='data' type='void *' info='extra data passed to f '/>
    </function>
    <function name='xmlHashScan3' file='hash'>
      <info>Scan the hash table and applied f to each value matching (name, name2, name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata or NULL '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata or NULL '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata or NULL '/>
      <arg name='f' type='xmlHashScanner' info='the scanner function for items in the hash '/>
      <arg name='data' type='void *' info='extra data passed to f '/>
    </function>
    <function name='xmlHashScanFull' file='hash'>
      <info>Scan the hash table and applied f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='f' type='xmlHashScannerFull' info='the scanner function for items in the hash '/>
      <arg name='data' type='void *' info='extra data passed to f '/>
    </function>
    <function name='xmlHashScanFull3' file='hash'>
      <info>Scan the hash table and applied f to each value matching (name, name2, name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata or NULL '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata or NULL '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata or NULL '/>
      <arg name='f' type='xmlHashScannerFull' info='the scanner function for items in the hash '/>
      <arg name='data' type='void *' info='extra data passed to f '/>
    </function>
    <functype name='xmlHashScanner' file='hash'>
      <info>Callback when scanning data in a hash with the simple scanner.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash '/>
      <arg name='data' type='void *' info='extra scannner data '/>
      <arg name='name' type='xmlChar *' info='the name associated '/>
    </functype>
    <functype name='xmlHashScannerFull' file='hash'>
      <info>Callback when scanning data in a hash with the full scanner.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash '/>
      <arg name='data' type='void *' info='extra scannner data '/>
      <arg name='name' type='const xmlChar *' info='the name associated '/>
      <arg name='name2' type='const xmlChar *' info='the second name associated '/>
      <arg name='name3' type='const xmlChar *' info='the third name associated '/>
    </functype>
    <function name='xmlHashSize' file='hash'>
      <info>Query the number of elements installed in the hash table.</info>
      <return type='int' info='the number of elements in the hash table or -1 in case of error '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
    </function>
    <struct name='xmlHashTable' file='hash'/>
    <typedef name='xmlHashTablePtr' file='hash'/>
    <function name='xmlHashUpdateEntry' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the name. Existing entry for this name will be removed and freed with f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any) '/>
    </function>
    <function name='xmlHashUpdateEntry2' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the (name, name2) tuple. Existing entry for this tuple will be removed and freed with f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any) '/>
    </function>
    <function name='xmlHashUpdateEntry3' file='hash'>
      <info>Add the userdata to the hash table. This can later be retrieved by using the tuple (name, name2, name3). Existing entry for this tuple will be removed and freed with f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error. '/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table '/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata '/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata '/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata '/>
      <arg name='userdata' type='void *' info='a pointer to the userdata '/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any) '/>
    </function>
    <struct name='xmlID' file='tree' info='An XML ID instance.'/>
    <typedef name='xmlIDPtr' file='tree'/>
    <typedef name='xmlIDTablePtr' file='valid'/>
    <function name='xmlIOFTPClose' file='xmlIO'>
      <info>Close an FTP I/O channel</info>
      <return type='int'/>
      <arg name='context' type='void *' info='the I/O context '/>
    </function>
    <function name='xmlIOFTPMatch' file='xmlIO'>
      <info>check if the URI matches an FTP one</info>
      <return type='int' info='1 if matches, 0 otherwise '/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlIOFTPOpen' file='xmlIO'>
      <info>open an FTP I/O channel</info>
      <return type='void *'/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlIOFTPRead' file='xmlIO'>
      <info>Read len bytes to buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written '/>
      <arg name='context' type='void *' info='the I/O context '/>
      <arg name='buffer' type='char *' info='where to drop data '/>
      <arg name='len' type='int' info='number of bytes to write '/>
    </function>
    <function name='xmlIOHTTPClose' file='xmlIO'>
      <info>Close an HTTP I/O channel</info>
      <return type='int'/>
      <arg name='context' type='void *' info='the I/O context '/>
    </function>
    <function name='xmlIOHTTPMatch' file='xmlIO'>
      <info>check if the URI matches an HTTP one</info>
      <return type='int' info='1 if matches, 0 otherwise '/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlIOHTTPOpen' file='xmlIO'>
      <info>open an HTTP I/O channel</info>
      <return type='void *'/>
      <arg name='filename' type='const char *' info='the URI for matching '/>
    </function>
    <function name='xmlIOHTTPOpenW' file='xmlIO'>
      <info>Open a temporary buffer to collect the document for a subsequent HTTP POST request. Non-static as is called from the output buffer creation routine.</info>
      <return type='void *'/>
      <arg name='post_uri' type='const char *' info='The destination URI for the document '/>
      <arg name='compression' type='int' info='The compression desired for the document. '/>
    </function>
    <function name='xmlIOHTTPRead' file='xmlIO'>
      <info>Read len bytes to buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written '/>
      <arg name='context' type='void *' info='the I/O context '/>
      <arg name='buffer' type='char *' info='where to drop data '/>
      <arg name='len' type='int' info='number of bytes to write '/>
    </function>
    <function name='xmlIOParseDTD' file='parser'>
      <info>Load and parse a DTD</info>
      <return type='xmlDtdPtr' info='input will be freed at parsing end. '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block or NULL '/>
      <arg name='input' type='xmlParserInputBufferPtr' info='an Input Buffer '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <macro name='xmlIndentTreeOutput' file='globals'>
      <info>Global setting, asking the serializer to indent the output tree by default Enabled by default</info>
    </macro>
    <function name='xmlInitCharEncodingHandlers' file='encoding'>
      <info>Initialize the char encoding support, it registers the default encoding supported. NOTE: while public, this function usually doesn&apos;t need to be called in normal processing.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitMemory' file='xmlmemory'>
      <info>Initialize the memory layer.</info>
      <return type='int' info='0 on success '/>
    </function>
    <function name='xmlInitNodeInfoSeq' file='parser'>
      <info>-- Initialize (set to initial state) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr' info='a node info sequence pointer '/>
    </function>
    <function name='xmlInitParser' file='parser'>
      <info>Initialization function for the XML parser. This is not reentrant. Call once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitParserCtxt' file='parser'>
      <info>Initialize a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlInitThreads' file='threads'>
      <info>xmlInitThreads() is used to to initialize all the thread related data of the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitializeCatalog' file='catalog'>
      <info>Do the catalog initialization. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
    </function>
    <function name='xmlInitializeGlobalState' file='globals'>
      <info>xmlInitializeGlobalState() initialize a global state with all the default values of the library.</info>
      <return type='void'/>
      <arg name='gs' type='xmlGlobalStatePtr' info='a pointer to a newly allocated global state '/>
    </function>
    <function name='xmlInitializePredefinedEntities' file='entities'>
      <info>Set up the predefined entities.</info>
      <return type='void'/>
    </function>
    <functype name='xmlInputCloseCallback' file='xmlIO'>
      <info>Callback used in the I/O Input API to close the resource</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='context' type='void *' info='an Input context '/>
    </functype>
    <functype name='xmlInputMatchCallback' file='xmlIO'>
      <info>Callback used in the I/O Input API to detect if the current handler can provide input fonctionnalities for this resource.</info>
      <return type='int' info='1 if yes and 0 if another Input module should be used '/>
      <arg name='filename' type='char const *' info='the filename or URI '/>
    </functype>
    <functype name='xmlInputOpenCallback' file='xmlIO'>
      <info>Callback used in the I/O Input API to open the resource</info>
      <return type='void *'/>
      <arg name='filename' type='char const *' info='the filename or URI '/>
    </functype>
    <functype name='xmlInputReadCallback' file='xmlIO'>
      <info>Callback used in the I/O Input API to read the resource</info>
      <return type='int' info='the number of bytes read or -1 in case of error '/>
      <arg name='context' type='void *' info='an Input context '/>
      <arg name='buffer' type='char *' info='the buffer to store data read '/>
      <arg name='len' type='int' info='the length of the buffer in bytes '/>
    </functype>
    <function name='xmlIsBaseChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [85] BaseChar ::= ... long list see REC ... </info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsBlank' file='parserInternals'>
      <info>Check whether the character is allowed by the production [3] S ::= (x20 | x9 | xD | xA)+ Also available as a macro IS_BLANK()</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsBlankNode' file='tree'>
      <info>Checks whether this node is an empty or whitespace only (and possibly ignorable) text-node.</info>
      <return type='int' info='1 yes, 0 no '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
    </function>
    <function name='xmlIsChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [2] Char ::= x9 | xA | xD | [x20-xD7FF] | [xE000-xFFFD] | [x10000-x10FFFF] any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. Also available as a macro IS_CHAR()</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsCombining' file='parserInternals'>
      <info>Check whether the character is allowed by the production [87] CombiningChar ::= ... long list see REC ...</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsDigit' file='parserInternals'>
      <info>Check whether the character is allowed by the production [88] Digit ::= ... long list see REC ...</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsExtender' file='parserInternals'>
      <info>Check whether the character is allowed by the production [89] Extender ::= x00B7 | x02D0 | x02D1 | x0387 | x0640 | x0E46 | x0EC6 | x3005 | [x3031-x3035] | [x309D-x309E] | [x30FC-x30FE]</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsID' file='valid'>
      <info>Determine whether an attribute is of type ID. In case we have DTD(s) then this is simple, otherwise we use an heuristic: name ID (upper or lowercase).</info>
      <return type='int' info='0 or 1 depending on the lookup result '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='elem' type='xmlNodePtr' info='the element carrying the attribute '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute '/>
    </function>
    <function name='xmlIsIdeographic' file='parserInternals'>
      <info>Check whether the character is allowed by the production [86] Ideographic ::= [x4E00-x9FA5] | x3007 | [x3021-x3029]</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsLetter' file='parserInternals'>
      <info>Check whether the character is allowed by the production [84] Letter ::= BaseChar | Ideographic</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsMainThread' file='threads'>
      <info>xmlIsMainThread() check whether the current thread is the main thread.</info>
      <return type='int' info='1 if the current thread is the main thread, 0 otherwise '/>
    </function>
    <function name='xmlIsMixedElement' file='valid'>
      <info>Search in the DtDs whether an element accept Mixed content (or ANY) basically if it is supposed to accept text childs</info>
      <return type='int' info='0 if no, 1 if yes, and -1 if no element description is available '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
    </function>
    <function name='xmlIsPubidChar' file='parserInternals'>
      <info>Check whether the character is allowed by the production [13] PubidChar ::= x20 | xD | xA | [a-zA-Z0-9] | [-&apos;()+,./:=?;!*#@$_%]</info>
      <return type='int' info='0 if not, non-zero otherwise '/>
      <arg name='c' type='int' info='an unicode character (int) '/>
    </function>
    <function name='xmlIsRef' file='valid'>
      <info>Determine whether an attribute is of type Ref. In case we have DTD(s) then this is simple, otherwise we use an heuristic: name Ref (upper or lowercase).</info>
      <return type='int' info='0 or 1 depending on the lookup result '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='elem' type='xmlNodePtr' info='the element carrying the attribute '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute '/>
    </function>
    <function name='xmlKeepBlanksDefault' file='parser'>
      <info>Set and return the previous value for default blanks text nodes support. The 1.x version of the parser used an heuristic to try to detect ignorable white spaces. As a result the SAX callback was generating ignorableWhitespace() callbacks instead of characters() one, and when using the DOM output text nodes containing those blanks were not generated. The 2.x and later version will switch to the XML standard way and ignorableWhitespace() are only generated when running the parser in validating mode and when the current element doesn&apos;t allow CDATA or mixed content. This function is provided as a way to force the standard behavior on 1.X libs and to switch back to the old mode for compatibility when running 1.X client code on 2.X . Upgrade of 1.X code should be done by using xmlIsBlankNode() commodity function to detect the &quot;empty&quot; nodes generated. This value also affect autogeneration of indentation when saving code if blanks sections are kept, indentation is not generated.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution. '/>
      <arg name='val' type='int' info='int 0 or 1 '/>
    </function>
    <macro name='xmlKeepBlanksDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser should keep all blanks nodes found in the content Activated by default, this is actually needed to have the parser conformant to the XML Recommendation, however the option is kept for some applications since this was libxml1 default behaviour.</info>
    </macro>
    <function name='xmlLineNumbersDefault' file='parser'>
      <info>Set and return the previous value for enabling line numbers in elements contents. This may break on old application and is turned off by default.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution. '/>
      <arg name='val' type='int' info='int 0 or 1 '/>
    </function>
    <macro name='xmlLineNumbersDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser should store the line number in the content field of elements in the DOM tree. Disabled by default since this may not be safe for old classes of applicaton.</info>
    </macro>
    <struct name='xmlLink' file='list'/>
    <function name='xmlLinkGetData' file='list'>
      <info>See Returns.</info>
      <return type='void *'/>
      <arg name='lk' type='xmlLinkPtr' info='a link '/>
    </function>
    <typedef name='xmlLinkPtr' file='list'/>
    <struct name='xmlList' file='list'/>
    <function name='xmlListAppend' file='list'>
      <info>Insert data in the ordered list at the end for this value</info>
      <return type='int' info='0 in case of success, 1 in case of failure '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='the data '/>
    </function>
    <function name='xmlListClear' file='list'>
      <info>Remove the all data in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListCopy' file='list'>
      <info>Move all the element from the old list in the new list</info>
      <return type='int' info='0 in case of success 1 in case of error '/>
      <arg name='cur' type='xmlListPtr' info='the new list '/>
      <arg name='old' type='const xmlListPtr' info='the old list '/>
    </function>
    <function name='xmlListCreate' file='list'>
      <info>Create a new list</info>
      <return type='xmlListPtr' info='the new list or NULL in case of error '/>
      <arg name='deallocator' type='xmlListDeallocator' info='an optional deallocator function '/>
      <arg name='compare' type='xmlListDataCompare' info='an optional comparison function '/>
    </function>
    <functype name='xmlListDataCompare' file='list'>
      <info>Callback function used to compare 2 data.</info>
      <return type='int' info='0 is equality, -1 or 1 otherwise depending on the ordering. '/>
      <arg name='data0' type='const void *' info='the first data '/>
      <arg name='data1' type='const void *' info='the second data '/>
    </functype>
    <functype name='xmlListDeallocator' file='list'>
      <info>Callback function used to free data from a list.</info>
      <return type='void'/>
      <arg name='lk' type='xmlLinkPtr' info='the data to deallocate '/>
    </functype>
    <function name='xmlListDelete' file='list'>
      <info>Deletes the list and its associated data</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListDup' file='list'>
      <info>Duplicate the list</info>
      <return type='xmlListPtr' info='a new copy of the list or NULL in case of error '/>
      <arg name='old' type='const xmlListPtr' info='the list '/>
    </function>
    <function name='xmlListEmpty' file='list'>
      <info>Is the list empty ?</info>
      <return type='int' info='1 if the list is empty, 0 otherwise '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListEnd' file='list'>
      <info>Get the last element in the list</info>
      <return type='xmlLinkPtr' info='the last element in the list, or NULL '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListFront' file='list'>
      <info>Get the first element in the list</info>
      <return type='xmlLinkPtr' info='the first element in the list, or NULL '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListInsert' file='list'>
      <info>Insert data in the ordered list at the beginning for this value</info>
      <return type='int' info='0 in case of success, 1 in case of failure '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='the data '/>
    </function>
    <function name='xmlListMerge' file='list'>
      <info>include all the elements of the second list in the first one and clear the second list</info>
      <return type='void'/>
      <arg name='l1' type='xmlListPtr' info='the original list '/>
      <arg name='l2' type='xmlListPtr' info='the new list '/>
    </function>
    <function name='xmlListPopBack' file='list'>
      <info>Removes the last element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListPopFront' file='list'>
      <info>Removes the first element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <typedef name='xmlListPtr' file='list'/>
    <function name='xmlListPushBack' file='list'>
      <info>add the new data at the end of the list</info>
      <return type='int' info='1 if successful, 0 otherwise '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='new data '/>
    </function>
    <function name='xmlListPushFront' file='list'>
      <info>add the new data at the beginning of the list</info>
      <return type='int' info='1 if successful, 0 otherwise '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='new data '/>
    </function>
    <function name='xmlListRemoveAll' file='list'>
      <info>Remove the all instance associated to data in the list</info>
      <return type='int' info='the number of deallocation, or 0 if not found '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='list data '/>
    </function>
    <function name='xmlListRemoveFirst' file='list'>
      <info>Remove the first instance associated to data in the list</info>
      <return type='int' info='1 if a deallocation occured, or 0 if not found '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='list data '/>
    </function>
    <function name='xmlListRemoveLast' file='list'>
      <info>Remove the last instance associated to data in the list</info>
      <return type='int' info='1 if a deallocation occured, or 0 if not found '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='list data '/>
    </function>
    <function name='xmlListReverse' file='list'>
      <info>Reverse the order of the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListReverseSearch' file='list'>
      <info>Search the list in reverse order for an existing value of data</info>
      <return type='void *'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='a search value '/>
    </function>
    <function name='xmlListReverseWalk' file='list'>
      <info>Walk all the element of the list in reverse order and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='walker' type='xmlListWalker' info='a processing function '/>
      <arg name='user' type='const void *' info='a user parameter passed to the walker function '/>
    </function>
    <function name='xmlListSearch' file='list'>
      <info>Search the list for an existing value of data</info>
      <return type='void *'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='data' type='void *' info='a search value '/>
    </function>
    <function name='xmlListSize' file='list'>
      <info>Get the number of elements in the list</info>
      <return type='int' info='the number of elements in the list '/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListSort' file='list'>
      <info>Sort all the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
    </function>
    <function name='xmlListWalk' file='list'>
      <info>Walk all the element of the first from first to last and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list '/>
      <arg name='walker' type='xmlListWalker' info='a processing function '/>
      <arg name='user' type='const void *' info='a user parameter passed to the walker function '/>
    </function>
    <functype name='xmlListWalker' file='list'>
      <info>Callback function used when walking a list with xmlListWalk().</info>
      <return type='int' info='0 to stop walking the list, 1 otherwise. '/>
      <arg name='data' type='const void *' info='the data found in the list '/>
      <arg name='user' type='const void *' info='extra user provided data to the walker '/>
    </functype>
    <function name='xmlLoadACatalog' file='catalog'>
      <info>Load the catalog and build the associated data structures. This can be either an XML Catalog or an SGML Catalog It will recurse in SGML CATALOG entries. On the other hand XML Catalogs are not handled recursively.</info>
      <return type='xmlCatalogPtr' info='the catalog parsed or NULL in case of error '/>
      <arg name='filename' type='const char *' info='a file path '/>
    </function>
    <function name='xmlLoadCatalog' file='catalog'>
      <info>Load the catalog and makes its definitions effective for the default external entity loader. It will recurse in SGML CATALOG entries. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='int' info='0 in case of success -1 in case of error '/>
      <arg name='filename' type='const char *' info='a file path '/>
    </function>
    <function name='xmlLoadCatalogs' file='catalog'>
      <info>Load the catalogs and makes their definitions effective for the default external entity loader. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
      <arg name='paths' type='const char *' info='a list of file path separated by &apos;:&apos; or spaces '/>
    </function>
    <macro name='xmlLoadExtDtdDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser should load DTD while not validating. Disabled by default.</info>
    </macro>
    <function name='xmlLoadExternalEntity' file='parser'>
      <info>Load an external entity, note that the use of this function for unparsed entities may generate problems TODO: a more generic External entity API must be designed</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr or NULL '/>
      <arg name='URL' type='const char *' info='the URL for the entity to load '/>
      <arg name='ID' type='const char *' info='the Public ID for the entity to load '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the context in which the entity is called or NULL '/>
    </function>
    <function name='xmlLoadSGMLSuperCatalog' file='catalog'>
      <info>Load an SGML super catalog. It won&apos;t expand CATALOG or DELEGATE references. This is only needed for manipulating SGML Super Catalogs like adding and removing CATALOG or DELEGATE entries.</info>
      <return type='xmlCatalogPtr' info='the catalog parsed or NULL in case of error '/>
      <arg name='filename' type='const char *' info='a file path '/>
    </function>
    <struct name='xmlLocationSet' file='xpointer'/>
    <typedef name='xmlLocationSetPtr' file='xpointer'/>
    <function name='xmlLockLibrary' file='threads'>
      <info>xmlLockLibrary() is used to take out a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlLsCountNode' file='debugXML'>
      <info>Count the children of node.</info>
      <return type='int' info='node. '/>
      <arg name='node' type='xmlNodePtr' info='the node to count '/>
    </function>
    <function name='xmlLsOneNode' file='debugXML'>
      <info>Dump to output the type and name of node.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='node' type='xmlNodePtr' info='the node to dump '/>
    </function>
    <macro name='xmlMalloc' file='globals'>
      <info>Wrapper for the malloc() function used in the XML library.</info>
      <arg name='size' info='number of bytes to allocate '/>
    </macro>
    <functype name='xmlMallocFunc' file='xmlmemory'>
      <info>Signature for a malloc() implementation.</info>
      <return type='void *'/>
      <arg name='size' type='size_t' info='the size requested in bytes '/>
    </functype>
    <function name='xmlMallocLoc' file='xmlmemory'>
      <info>a malloc() equivalent, with logging of the allocation info.</info>
      <return type='void *'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate. '/>
      <arg name='file' type='const char *' info='the file name or NULL '/>
      <arg name='line' type='int' info='the line number '/>
    </function>
    <function name='xmlMemDisplay' file='xmlmemory'>
      <info>show in-extenso the memory blocks allocated</info>
      <return type='void'/>
      <arg name='fp' type='FILE *' info='a FILE descriptor used as the output file, if NULL, the result is written to the file .memorylist '/>
    </function>
    <function name='xmlMemGet' file='xmlmemory'>
      <info>Return the memory access functions set currently in use</info>
      <return type='int' info='0 on success '/>
      <arg name='freeFunc' type='xmlFreeFunc *' info='the free() function in use '/>
      <arg name='mallocFunc' type='xmlMallocFunc *' info='the malloc() function in use '/>
      <arg name='reallocFunc' type='xmlReallocFunc *' info='the realloc() function in use '/>
      <arg name='strdupFunc' type='xmlStrdupFunc *' info='the strdup() function in use '/>
    </function>
    <function name='xmlMemSetup' file='xmlmemory'>
      <info>Override the default memory access functions with a new set This has to be called before any other libxml routines ! </info>
      <return type='int' info='0 on success '/>
      <arg name='freeFunc' type='xmlFreeFunc' info='the free() function to use '/>
      <arg name='mallocFunc' type='xmlMallocFunc' info='the malloc() function to use '/>
      <arg name='reallocFunc' type='xmlReallocFunc' info='the realloc() function to use '/>
      <arg name='strdupFunc' type='xmlStrdupFunc' info='the strdup() function to use '/>
    </function>
    <function name='xmlMemShow' file='xmlmemory'>
      <info>show a show display of the memory allocated, and dump the nr last allocated areas which were not freed</info>
      <return type='void'/>
      <arg name='fp' type='FILE *' info='a FILE descriptor used as the output file '/>
      <arg name='nr' type='int' info='number of entries to dump '/>
    </function>
    <macro name='xmlMemStrdup' file='globals'>
      <info>Wrapper for the strdup() function, xmlStrdup() is usually preferred.</info>
      <arg name='str' info='pointer to the existing string '/>
    </macro>
    <function name='xmlMemStrdupLoc' file='xmlmemory'>
      <info>a strdup() equivalent, with logging of the allocation info.</info>
      <return type='char *' info='a pointer to the new string or NULL if allocation error occurred. '/>
      <arg name='str' type='const char *' info='the initial string pointer '/>
      <arg name='file' type='const char *' info='the file name or NULL '/>
      <arg name='line' type='int' info='the line number '/>
    </function>
    <function name='xmlMemUsed' file='xmlmemory'>
      <info>returns the amount of memory currently allocated</info>
      <return type='int' info='an int representing the amount of memory allocated. '/>
    </function>
    <function name='xmlMemoryDump' file='xmlmemory'>
      <info>Dump in-extenso the memory blocks allocated to the file .memorylist</info>
      <return type='void'/>
    </function>
    <struct name='xmlMutex' file='threads'/>
    <function name='xmlMutexLock' file='threads'>
      <info>xmlMutexLock() is used to lock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex '/>
    </function>
    <typedef name='xmlMutexPtr' file='threads' info='xmlNewMutex() is used to allocate a libxml2 token struct for use in synchronizing access to data.'/>
    <function name='xmlMutexUnlock' file='threads'>
      <info>xmlMutexUnlock() is used to unlock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex '/>
    </function>
    <function name='xmlNamespaceParseNCName' file='parserInternals'>
      <info>parse an XML namespace name. </info>
      <return type='xmlChar *' info='the namespace name or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlNamespaceParseNSDef' file='parserInternals'>
      <info>parse a namespace prefix declaration </info>
      <return type='xmlChar *' info='the namespace name '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlNamespaceParseQName' file='parserInternals'>
      <info>TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input. </info>
      <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar ** '/>
    </function>
    <function name='xmlNanoFTPCheckResponse' file='nanoftp'>
      <info>Check if there is a response from the FTP server after a command.</info>
      <return type='int' info='the code number, or 0 '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPCleanup' file='nanoftp'>
      <info>Cleanup the FTP protocol layer. This cleanup proxy informations.</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoFTPClose' file='nanoftp'>
      <info>Close the connection and both control and transport</info>
      <return type='int' info='-1 incase of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPCloseConnection' file='nanoftp'>
      <info>Close the data connection from the server</info>
      <return type='int' info='-1 incase of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPConnect' file='nanoftp'>
      <info>Tries to open a control connection</info>
      <return type='int' info='-1 in case of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPConnectTo' file='nanoftp'>
      <info>Tries to open a control connection to the given server/port</info>
      <return type='void *'/>
      <arg name='server' type='const char *' info='an FTP server name '/>
      <arg name='port' type='int' info='the port (use 21 if 0) '/>
    </function>
    <function name='xmlNanoFTPCwd' file='nanoftp'>
      <info>Tries to change the remote directory</info>
      <return type='int' info='-1 incase of error, 1 if CWD worked, 0 if it failed '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
      <arg name='directory' type='char *' info='a directory on the server '/>
    </function>
    <function name='xmlNanoFTPFreeCtxt' file='nanoftp'>
      <info>Frees the context after closing the connection.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPGet' file='nanoftp'>
      <info>Fetch the given file from the server. All data are passed back in the callbacks. The last callback has a size of 0 block.</info>
      <return type='int' info='-1 incase of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
      <arg name='callback' type='ftpDataCallback' info='the user callback '/>
      <arg name='userData' type='void *' info='the user callback data '/>
      <arg name='filename' type='const char *' info='the file to retrieve '/>
    </function>
    <function name='xmlNanoFTPGetConnection' file='nanoftp'>
      <info>Try to open a data connection to the server. Currently only passive mode is supported.</info>
      <return type='int' info='-1 incase of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPGetResponse' file='nanoftp'>
      <info>Get the response from the FTP server after a command.</info>
      <return type='int' info='the code number '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPGetSocket' file='nanoftp'>
      <info>Initiate fetch of the given file from the server.</info>
      <return type='int' info='the socket for the data connection, or &lt;0 in case of error '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
      <arg name='filename' type='const char *' info='the file to retrieve (or NULL if path is in context). '/>
    </function>
    <function name='xmlNanoFTPInit' file='nanoftp'>
      <info>Initialize the FTP protocol layer. Currently it just checks for proxy informations, and get the hostname</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoFTPList' file='nanoftp'>
      <info>Do a listing on the server. All files info are passed back in the callbacks.</info>
      <return type='int' info='-1 incase of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
      <arg name='callback' type='ftpListCallback' info='the user callback '/>
      <arg name='userData' type='void *' info='the user callback data '/>
      <arg name='filename' type='char *' info='optional files to list '/>
    </function>
    <function name='xmlNanoFTPNewCtxt' file='nanoftp'>
      <info>Allocate and initialize a new FTP context.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='The URL used to initialize the context '/>
    </function>
    <function name='xmlNanoFTPOpen' file='nanoftp'>
      <info>Start to fetch the given ftp:// resource</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='the URL to the resource '/>
    </function>
    <function name='xmlNanoFTPProxy' file='nanoftp'>
      <info>Setup the FTP proxy informations. This can also be done by using ftp_proxy ftp_proxy_user and ftp_proxy_password environment variables.</info>
      <return type='void'/>
      <arg name='host' type='const char *' info='the proxy host name '/>
      <arg name='port' type='int' info='the proxy port '/>
      <arg name='user' type='const char *' info='the proxy user name '/>
      <arg name='passwd' type='const char *' info='the proxy password '/>
      <arg name='type' type='int' info='b '/>
    </function>
    <function name='xmlNanoFTPQuit' file='nanoftp'>
      <info>Send a QUIT command to the server</info>
      <return type='int' info='-1 in case of error, 0 otherwise '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
    </function>
    <function name='xmlNanoFTPRead' file='nanoftp'>
      <info>This function tries to read len bytes from the existing FTP connection and saves them in dest. This is a blocking call.</info>
      <return type='int' info='the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error. '/>
      <arg name='ctx' type='void *' info='the FTP context '/>
      <arg name='dest' type='void *' info='a buffer '/>
      <arg name='len' type='int' info='the buffer length '/>
    </function>
    <function name='xmlNanoFTPScanProxy' file='nanoftp'>
      <info>(Re)Initialize the FTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like ftp://myproxy/ or ftp://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context '/>
    </function>
    <function name='xmlNanoFTPUpdateURL' file='nanoftp'>
      <info>Update an FTP context by parsing the URL and finding new path it indicates. If there is an error in the protocol, hostname, port or other information, the error is raised. It indicates a new connection has to be established.</info>
      <return type='int' info='0 if Ok, -1 in case of error (other host). '/>
      <arg name='ctx' type='void *' info='an FTP context '/>
      <arg name='URL' type='const char *' info='The URL used to update the context '/>
    </function>
    <function name='xmlNanoHTTPAuthHeader' file='nanohttp'>
      <info>Get the authentication header of an HTTP context</info>
      <return type='const char *' info='the stashed value of the WWW-Authenticate or Proxy-Authenticate header. '/>
      <arg name='ctx' type='void *' info='the HTTP context '/>
    </function>
    <function name='xmlNanoHTTPCleanup' file='nanohttp'>
      <info>Cleanup the HTTP protocol layer.</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoHTTPClose' file='nanohttp'>
      <info>This function closes an HTTP context, it ends up the connection and free all data related to it.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the HTTP context '/>
    </function>
    <function name='xmlNanoHTTPFetch' file='nanohttp'>
      <info>This function try to fetch the indicated resource via HTTP GET and save it&apos;s content in the file.</info>
      <return type='int' info='-1 in case of failure, 0 incase of success. The contentType, if provided must be freed by the caller '/>
      <arg name='URL' type='const char *' info='The URL to load '/>
      <arg name='filename' type='const char *' info='the filename where the content should be saved '/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location '/>
    </function>
    <function name='xmlNanoHTTPInit' file='nanohttp'>
      <info>Initialize the HTTP protocol layer. Currently it just checks for proxy informations</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoHTTPMethod' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP using the given method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='The URL to load '/>
      <arg name='method' type='const char *' info='the HTTP method to use '/>
      <arg name='input' type='const char *' info='the input string if any '/>
      <arg name='contentType' type='char **' info='the Content-Type information IN and OUT '/>
      <arg name='headers' type='const char *' info='the extra headers '/>
      <arg name='ilen' type='int' info='input length '/>
    </function>
    <function name='xmlNanoHTTPMethodRedir' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP using the given method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='The URL to load '/>
      <arg name='method' type='const char *' info='the HTTP method to use '/>
      <arg name='input' type='const char *' info='the input string if any '/>
      <arg name='contentType' type='char **' info='the Content-Type information IN and OUT '/>
      <arg name='redir' type='char **' info='the redirected URL OUT '/>
      <arg name='headers' type='const char *' info='the extra headers '/>
      <arg name='ilen' type='int' info='input length '/>
    </function>
    <function name='xmlNanoHTTPOpen' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='The URL to load '/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location '/>
    </function>
    <function name='xmlNanoHTTPOpenRedir' file='nanohttp'>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *'/>
      <arg name='URL' type='const char *' info='The URL to load '/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location '/>
      <arg name='redir' type='char **' info='if available the redirected URL will be returned '/>
    </function>
    <function name='xmlNanoHTTPRead' file='nanohttp'>
      <info>This function tries to read len bytes from the existing HTTP connection and saves them in dest. This is a blocking call.</info>
      <return type='int' info='the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error. '/>
      <arg name='ctx' type='void *' info='the HTTP context '/>
      <arg name='dest' type='void *' info='a buffer '/>
      <arg name='len' type='int' info='the buffer length '/>
    </function>
    <function name='xmlNanoHTTPReturnCode' file='nanohttp'>
      <info>Get the latest HTTP return code received</info>
      <return type='int' info='the HTTP return code for the request. '/>
      <arg name='ctx' type='void *' info='the HTTP context '/>
    </function>
    <function name='xmlNanoHTTPSave' file='nanohttp'>
      <info>This function saves the output of the HTTP transaction to a file It closes and free the context at the end</info>
      <return type='int' info='-1 in case of failure, 0 incase of success. '/>
      <arg name='ctxt' type='void *' info='the HTTP context '/>
      <arg name='filename' type='const char *' info='the filename where the content should be saved '/>
    </function>
    <function name='xmlNanoHTTPScanProxy' file='nanohttp'>
      <info>(Re)Initialize the HTTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like http://myproxy/ or http://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context '/>
    </function>
    <function name='xmlNewAutomata' file='xmlautomata'>
      <info>Create a new automata</info>
      <return type='xmlAutomataPtr' info='the new object or NULL in case of failure '/>
    </function>
    <function name='xmlNewCDataBlock' file='tree'>
      <info>Creation of a new node containing a CDATA block.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='content' type='const xmlChar *' info='the CDATA block content content '/>
      <arg name='len' type='int' info='the length of the block '/>
    </function>
    <function name='xmlNewCatalog' file='catalog'>
      <info>create a new Catalog.</info>
      <return type='xmlCatalogPtr' info='the xmlCatalogPtr or NULL in case of error '/>
      <arg name='sgml' type='int' info='should this create an SGML catalog '/>
    </function>
    <function name='xmlNewCharEncodingHandler' file='encoding'>
      <info>Create and registers an xmlCharEncodingHandler.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr created (or NULL in case of error). '/>
      <arg name='name' type='const char *' info='the encoding name, in UTF-8 format (ASCII actually) '/>
      <arg name='input' type='xmlCharEncodingInputFunc' info='the xmlCharEncodingInputFunc to read that encoding '/>
      <arg name='output' type='xmlCharEncodingOutputFunc' info='the xmlCharEncodingOutputFunc to write that encoding '/>
    </function>
    <function name='xmlNewCharRef' file='tree'>
      <info>Creation of a new character reference node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the char ref string, starting with # or &quot;&amp;# ... ;&quot; '/>
    </function>
    <function name='xmlNewChild' file='tree'>
      <info>Creation of a new child element, added at the end of parent children list. ns and content parameters are optional (NULL). If content is non NULL, a child list containing the TEXTs and ENTITY_REFs node will be created. NOTE: content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewTextChild() if entities support is not needed.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='parent' type='xmlNodePtr' info='the parent node '/>
      <arg name='ns' type='xmlNsPtr' info='a namespace if any '/>
      <arg name='name' type='const xmlChar *' info='the name of the child '/>
      <arg name='content' type='const xmlChar *' info='the XML content of the child if any. '/>
    </function>
    <function name='xmlNewComment' file='tree'>
      <info>Creation of a new node containing a comment.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='content' type='const xmlChar *' info='the comment content '/>
    </function>
    <function name='xmlNewDoc' file='tree'>
      <info>Creates a new XML document</info>
      <return type='xmlDocPtr' info='a new document '/>
      <arg name='version' type='const xmlChar *' info='xmlChar string giving the version of XML &quot;1.0&quot; '/>
    </function>
    <function name='xmlNewDocComment' file='tree'>
      <info>Creation of a new node containing a comment within a document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='content' type='const xmlChar *' info='the comment content '/>
    </function>
    <function name='xmlNewDocFragment' file='tree'>
      <info>Creation of a new Fragment node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document owning the fragment '/>
    </function>
    <function name='xmlNewDocNode' file='tree'>
      <info>Creation of a new node element within a document. ns and content are optional (NULL). NOTE: content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don&apos;t need entities support.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any '/>
      <arg name='name' type='const xmlChar *' info='the node name '/>
      <arg name='content' type='const xmlChar *' info='the XML text content if any '/>
    </function>
    <function name='xmlNewDocNodeEatName' file='tree'>
      <info>Creation of a new node element within a document. ns and content are optional (NULL). NOTE: content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don&apos;t need entities support.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any '/>
      <arg name='name' type='xmlChar *' info='the node name '/>
      <arg name='content' type='const xmlChar *' info='the XML text content if any '/>
    </function>
    <function name='xmlNewDocProp' file='tree'>
      <info>Create a new property carried by a document.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute '/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute '/>
    </function>
    <function name='xmlNewDocRawNode' file='tree'>
      <info>Creation of a new node element within a document. ns and content are optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any '/>
      <arg name='name' type='const xmlChar *' info='the node name '/>
      <arg name='content' type='const xmlChar *' info='the text content if any '/>
    </function>
    <function name='xmlNewDocText' file='tree'>
      <info>Creation of a new text node within a document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='content' type='const xmlChar *' info='the text content '/>
    </function>
    <function name='xmlNewDocTextLen' file='tree'>
      <info>Creation of a new text node with an extra content length parameter. The text node pertain to a given document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='content' type='const xmlChar *' info='the text content '/>
      <arg name='len' type='int' info='the text len. '/>
    </function>
    <function name='xmlNewDtd' file='tree'>
      <info>Creation of a new DTD for the external subset. To create an internal subset, use xmlCreateIntSubset().</info>
      <return type='xmlDtdPtr' info='a pointer to the new DTD structure '/>
      <arg name='doc' type='xmlDocPtr' info='the document pointer '/>
      <arg name='name' type='const xmlChar *' info='the DTD name '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID '/>
      <arg name='SystemID' type='const xmlChar *' info='the system ID '/>
    </function>
    <function name='xmlNewElementContent' file='valid'>
      <info>Allocate an element content structure.</info>
      <return type='xmlElementContentPtr' info='NULL if not, otherwise the new element content structure '/>
      <arg name='name' type='xmlChar *' info='the subelement name or NULL '/>
      <arg name='type' type='xmlElementContentType' info='the type of element content decl '/>
    </function>
    <function name='xmlNewEntityInputStream' file='parserInternals'>
      <info>Create a new input stream based on an xmlEntityPtr</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='entity' type='xmlEntityPtr' info='an Entity pointer '/>
    </function>
    <function name='xmlNewGlobalNs' file='tree'>
      <info>Creation of a Namespace, the old way using PI and without scoping DEPRECATED !!! It now create a namespace on the root element of the document if found.</info>
      <return type='xmlNsPtr' info='NULL this functionality had been removed '/>
      <arg name='doc' type='xmlDocPtr' info='the document carrying the namespace '/>
      <arg name='href' type='const xmlChar *' info='the URI associated '/>
      <arg name='prefix' type='const xmlChar *' info='the prefix for the namespace '/>
    </function>
    <function name='xmlNewIOInputStream' file='parser'>
      <info>Create a new input stream structure encapsulating the input into a stream suitable for the parser.</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='input' type='xmlParserInputBufferPtr' info='an I/O Input '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlNewInputFromFile' file='parserInternals'>
      <info>Create a new input stream based on a file.</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL in case of error '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='filename' type='const char *' info='the filename to use as entity '/>
    </function>
    <function name='xmlNewInputStream' file='parserInternals'>
      <info>Create a new input stream structure</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlNewMutex' file='threads'>
      <return type='xmlMutexPtr'/>
    </function>
    <function name='xmlNewNode' file='tree'>
      <info>Creation of a new node element. ns is optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any '/>
      <arg name='name' type='const xmlChar *' info='the node name '/>
    </function>
    <function name='xmlNewNodeEatName' file='tree'>
      <info>Creation of a new node element. ns is optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any '/>
      <arg name='name' type='xmlChar *' info='the node name '/>
    </function>
    <function name='xmlNewNs' file='tree'>
      <info>Creation of a new Namespace. This function will refuse to create a namespace with a similar prefix than an existing one present on this node. We use href==NULL in the case of an element creation where the namespace was not defined.</info>
      <return type='xmlNsPtr' info='a new namespace pointer or NULL '/>
      <arg name='node' type='xmlNodePtr' info='the element carrying the namespace '/>
      <arg name='href' type='const xmlChar *' info='the URI associated '/>
      <arg name='prefix' type='const xmlChar *' info='the prefix for the namespace '/>
    </function>
    <function name='xmlNewNsProp' file='tree'>
      <info>Create a new property tagged with a namespace and carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute '/>
      <arg name='node' type='xmlNodePtr' info='the holding node '/>
      <arg name='ns' type='xmlNsPtr' info='the namespace '/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute '/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute '/>
    </function>
    <function name='xmlNewNsPropEatName' file='tree'>
      <info>Create a new property tagged with a namespace and carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute '/>
      <arg name='node' type='xmlNodePtr' info='the holding node '/>
      <arg name='ns' type='xmlNsPtr' info='the namespace '/>
      <arg name='name' type='xmlChar *' info='the name of the attribute '/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute '/>
    </function>
    <function name='xmlNewPI' file='tree'>
      <info>Creation of a processing instruction element.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='name' type='const xmlChar *' info='the processing instruction name '/>
      <arg name='content' type='const xmlChar *' info='the PI content '/>
    </function>
    <function name='xmlNewParserCtxt' file='parserInternals'>
      <info>Allocate and initialize a new parser context.</info>
      <return type='xmlParserCtxtPtr' info='the xmlParserCtxtPtr or NULL '/>
    </function>
    <function name='xmlNewProp' file='tree'>
      <info>Create a new property carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute '/>
      <arg name='node' type='xmlNodePtr' info='the holding node '/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute '/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute '/>
    </function>
    <function name='xmlNewRMutex' file='threads'>
      <return type='xmlRMutexPtr'/>
    </function>
    <function name='xmlNewReference' file='tree'>
      <info>Creation of a new reference node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='name' type='const xmlChar *' info='the reference name, or the reference string with &amp; and ; '/>
    </function>
    <function name='xmlNewStringInputStream' file='parserInternals'>
      <info>Create a new input stream based on a memory buffer.</info>
      <return type='xmlParserInputPtr' info='the new input stream '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='buffer' type='const xmlChar *' info='an memory buffer '/>
    </function>
    <function name='xmlNewText' file='tree'>
      <info>Creation of a new text node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='content' type='const xmlChar *' info='the text content '/>
    </function>
    <function name='xmlNewTextChild' file='tree'>
      <info>Creation of a new child element, added at the end of parent children list. ns and content parameters are optional (NULL). If content is non NULL, a child TEXT node will be created containing the string content.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='parent' type='xmlNodePtr' info='the parent node '/>
      <arg name='ns' type='xmlNsPtr' info='a namespace if any '/>
      <arg name='name' type='const xmlChar *' info='the name of the child '/>
      <arg name='content' type='const xmlChar *' info='the text content of the child if any. '/>
    </function>
    <function name='xmlNewTextLen' file='tree'>
      <info>Creation of a new text node with an extra parameter for the content&apos;s length</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. '/>
      <arg name='content' type='const xmlChar *' info='the text content '/>
      <arg name='len' type='int' info='the text len. '/>
    </function>
    <function name='xmlNextChar' file='parserInternals'>
      <info>Skip to the next char input char.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context '/>
    </function>
    <function name='xmlNoNetExternalEntityLoader' file='xmlIO'>
      <info>A specific entity loader disabling network accesses, though still allowing local catalog accesses for resolution.</info>
      <return type='xmlParserInputPtr' info='a new allocated xmlParserInputPtr, or NULL. '/>
      <arg name='URL' type='const char *' info='the URL for the entity to load '/>
      <arg name='ID' type='const char *' info='the System ID for the entity to load '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the context in which the entity is called or NULL '/>
    </function>
    <struct name='xmlNode' file='tree' info='A node in an XML tree.'/>
    <function name='xmlNodeAddContent' file='tree'>
      <info>Append the extra substring to the node content.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified '/>
      <arg name='content' type='const xmlChar *' info='extra content '/>
    </function>
    <function name='xmlNodeAddContentLen' file='tree'>
      <info>Append the extra substring to the node content.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified '/>
      <arg name='content' type='const xmlChar *' info='extra content '/>
      <arg name='len' type='int' info='content '/>
    </function>
    <function name='xmlNodeDump' file='tree'>
      <info>Dump an XML node, recursive behaviour,children are printed too. Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
      <arg name='level' type='int' info='the imbrication level for indenting '/>
      <arg name='format' type='int' info='is formatting allowed '/>
    </function>
    <function name='xmlNodeDumpOutput' file='tree'>
      <info>Dump an XML node, recursive behaviour, children are printed too. Note that format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the XML buffer output '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='cur' type='xmlNodePtr' info='the current node '/>
      <arg name='level' type='int' info='the imbrication level for indenting '/>
      <arg name='format' type='int' info='is formatting allowed '/>
      <arg name='encoding' type='const char *' info='an optional encoding string '/>
    </function>
    <function name='xmlNodeGetBase' file='tree'>
      <info>Searches for the BASE URL. The code should work on both XML and HTML document even if base mechanisms are completely different. It returns the base as defined in RFC 2396 sections 5.1.1. Base URI within Document Content and 5.1.2. Base URI from the Encapsulating Entity However it does not return the document base (5.1.3), use xmlDocumentGetBase() for this</info>
      <return type='xmlChar *' info='a pointer to the base URL, or NULL if not found It&apos;s up to the caller to free the memory with xmlFree(). '/>
      <arg name='doc' type='xmlDocPtr' info='the document the node pertains to '/>
      <arg name='cur' type='xmlNodePtr' info='the node being checked '/>
    </function>
    <function name='xmlNodeGetContent' file='tree'>
      <info>Read the value of a node, this can be either the text carried directly by this node if it&apos;s a TEXT node or the aggregate string of the values carried by this node child&apos;s (TEXT and ENTITY_REF). Entity references are substituted.</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL if no content is available. It&apos;s up to the caller to free the memory with xmlFree(). '/>
      <arg name='cur' type='xmlNodePtr' info='the node being read '/>
    </function>
    <function name='xmlNodeGetLang' file='tree'>
      <info>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</info>
      <return type='xmlChar *' info='a pointer to the lang value, or NULL if not found It&apos;s up to the caller to free the memory with xmlFree(). '/>
      <arg name='cur' type='xmlNodePtr' info='the node being checked '/>
    </function>
    <function name='xmlNodeGetSpacePreserve' file='tree'>
      <info>Searches the space preserving behaviour of a node, i.e. the values of the xml:space attribute or the one carried by the nearest ancestor.</info>
      <return type='int' info='-1 if xml:space is not inherited, 0 if &quot;default&quot;, 1 if &quot;preserve&quot; '/>
      <arg name='cur' type='xmlNodePtr' info='the node being checked '/>
    </function>
    <function name='xmlNodeIsText' file='tree'>
      <info>Is this node a Text node ?</info>
      <return type='int' info='1 yes, 0 no '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
    </function>
    <function name='xmlNodeListGetRawString' file='tree'>
      <info>Returns the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs, contrary to xmlNodeListGetString() this function doesn&apos;t do any character encoding handling.</info>
      <return type='xmlChar *' info='a pointer to the string copy, the caller must free it with xmlFree(). '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='list' type='xmlNodePtr' info='a Node list '/>
      <arg name='inLine' type='int' info='should we replace entity contents or show their external form '/>
    </function>
    <function name='xmlNodeListGetString' file='tree'>
      <info>Returns the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs</info>
      <return type='xmlChar *' info='a pointer to the string copy, the caller must free it with xmlFree(). '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='list' type='xmlNodePtr' info='a Node list '/>
      <arg name='inLine' type='int' info='should we replace entity contents or show their external form '/>
    </function>
    <typedef name='xmlNodePtr' file='tree'/>
    <struct name='xmlNodeSet' file='xpath'/>
    <function name='xmlNodeSetBase' file='tree'>
      <info>Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed '/>
      <arg name='uri' type='xmlChar *' info='the new base URI '/>
    </function>
    <function name='xmlNodeSetContent' file='tree'>
      <info>Replace the content of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified '/>
      <arg name='content' type='const xmlChar *' info='the new value of the content '/>
    </function>
    <function name='xmlNodeSetContentLen' file='tree'>
      <info>Replace the content of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified '/>
      <arg name='content' type='const xmlChar *' info='the new value of the content '/>
      <arg name='len' type='int' info='content '/>
    </function>
    <function name='xmlNodeSetLang' file='tree'>
      <info>Set the language of a node, i.e. the values of the xml:lang attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed '/>
      <arg name='lang' type='const xmlChar *' info='the language description '/>
    </function>
    <function name='xmlNodeSetName' file='tree'>
      <info>Set (or reset) the name of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed '/>
      <arg name='name' type='const xmlChar *' info='the new tag name '/>
    </function>
    <typedef name='xmlNodeSetPtr' file='xpath'/>
    <function name='xmlNodeSetSpacePreserve' file='tree'>
      <info>Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed '/>
      <arg name='val' type='int' info='the xml:space value (&quot;0&quot;: default, 1: &quot;preserve&quot;) '/>
    </function>
    <function name='xmlNormalizeURIPath' file='uri'>
      <info>Applies the 5 normalization steps to a path string--that is, RFC 2396 Section 5.2, steps 6.c through 6.g. </info>
      <return type='int' info='0 or an error code '/>
      <arg name='path' type='char *' info='pointer to the path string '/>
    </function>
    <function name='xmlNormalizeWindowsPath' file='xmlIO'>
      <info>Normalize a Windows path to make an URL from it</info>
      <return type='xmlChar *' info='a new URI which must be freed by the caller or NULL in case of error '/>
      <arg name='path' type='const xmlChar *' info='a windows path like &quot;C:/foo/bar&quot; '/>
    </function>
    <struct name='xmlNotation' file='tree' info='A DTD Notation definition.'/>
    <typedef name='xmlNotationPtr' file='tree'/>
    <typedef name='xmlNotationTablePtr' file='valid'/>
    <struct name='xmlNs' file='tree' info='An XML namespace. Note that prefix == NULL is valid, it defines the default namespace within the subtree (until overridden). '/>
    <typedef name='xmlNsPtr' file='tree'/>
    <typedef name='xmlNsType' file='tree'/>
    <struct name='xmlOutputBuffer' file='xmlIO'/>
    <function name='xmlOutputBufferClose' file='xmlIO'>
      <info>flushes and close the output I/O channel and free up all the associated resources</info>
      <return type='int' info='the number of byte written or -1 in case of error. '/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered output '/>
    </function>
    <function name='xmlOutputBufferCreateFd' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to a file descriptor</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL '/>
      <arg name='fd' type='int' info='a file descriptor number '/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL '/>
    </function>
    <function name='xmlOutputBufferCreateFile' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to a FILE * buffered C I/O</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL '/>
      <arg name='file' type='FILE *' info='a FILE* '/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL '/>
    </function>
    <function name='xmlOutputBufferCreateFilename' file='xmlIO'>
      <info>Create a buffered output for the progressive saving of a file If filename is &quot;-&apos; then we use stdout as the output. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. TODO: currently if compression is set, the library only support writing to a local file.</info>
      <return type='xmlOutputBufferPtr' info='the new output or NULL '/>
      <arg name='URI' type='const char *' info='a C string containing the URI or filename '/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL '/>
      <arg name='compression' type='int' info='the compression ration (0 none, 9 max). '/>
    </function>
    <function name='xmlOutputBufferCreateIO' file='xmlIO'>
      <info>Create a buffered output for the progressive saving to an I/O handler</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL '/>
      <arg name='iowrite' type='xmlOutputWriteCallback' info='an I/O write function '/>
      <arg name='ioclose' type='xmlOutputCloseCallback' info='an I/O close function '/>
      <arg name='ioctx' type='void *' info='an I/O handler '/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the charset encoding if known '/>
    </function>
    <function name='xmlOutputBufferFlush' file='xmlIO'>
      <info>flushes the output I/O channel</info>
      <return type='int' info='the number of byte written or -1 in case of error. '/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered output '/>
    </function>
    <typedef name='xmlOutputBufferPtr' file='tree'/>
    <function name='xmlOutputBufferWrite' file='xmlIO'>
      <info>Write the content of the array in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int' info='the number of chars immediately written, or -1 in case of error. '/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered parser output '/>
      <arg name='len' type='int' info='the size in bytes of the array. '/>
      <arg name='buf' type='const char *' info='an char array '/>
    </function>
    <function name='xmlOutputBufferWriteString' file='xmlIO'>
      <info>Write the content of the string in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int' info='the number of chars immediately written, or -1 in case of error. '/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered parser output '/>
      <arg name='str' type='const char *' info='a zero terminated C string '/>
    </function>
    <functype name='xmlOutputCloseCallback' file='xmlIO'>
      <info>Callback used in the I/O Output API to close the resource</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='context' type='void *' info='an Output context '/>
    </functype>
    <functype name='xmlOutputMatchCallback' file='xmlIO'>
      <info>Callback used in the I/O Output API to detect if the current handler can provide output fonctionnalities for this resource.</info>
      <return type='int' info='1 if yes and 0 if another Output module should be used '/>
      <arg name='filename' type='char const *' info='the filename or URI '/>
    </functype>
    <functype name='xmlOutputOpenCallback' file='xmlIO'>
      <info>Callback used in the I/O Output API to open the resource</info>
      <return type='void *'/>
      <arg name='filename' type='char const *' info='the filename or URI '/>
    </functype>
    <functype name='xmlOutputWriteCallback' file='xmlIO'>
      <info>Callback used in the I/O Output API to write to the resource</info>
      <return type='int' info='the number of bytes written or -1 in case of error '/>
      <arg name='context' type='void *' info='an Output context '/>
      <arg name='buffer' type='const char *' info='the buffer of data to write '/>
      <arg name='len' type='int' info='the length of the buffer in bytes '/>
    </functype>
    <function name='xmlParseAttValue' file='parserInternals'>
      <info>parse a value for an attribute Note: the parser won&apos;t do substitution of entities here, this will be handled later in xmlStringGetNodeList </info>
      <return type='xmlChar *' info='the AttValue parsed or NULL. The value has to be freed by the caller. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseAttribute' file='parserInternals'>
      <info>parse an attribute </info>
      <return type='xmlChar *' info='the attribute name, and the value in *value. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='value' type='xmlChar **' info='a xmlChar ** used to store the value of the attribute '/>
    </function>
    <function name='xmlParseAttributeListDecl' file='parserInternals'>
      <info>: parse the Attribute list def for an element </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseAttributeType' file='parserInternals'>
      <info>parse the Attribute list def for an element </info>
      <return type='int' info='the attribute type '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='tree' type='xmlEnumerationPtr *' info='the enumeration tree built while parsing '/>
    </function>
    <function name='xmlParseBalancedChunkMemory' file='parser'>
      <info>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: </info>
      <return type='int' info='0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise '/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL) '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL) '/>
      <arg name='depth' type='int' info='Used for loop detection, use 0 '/>
      <arg name='string' type='const xmlChar *' info='the input string in UTF8 or ISO-Latin (zero terminated) '/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes '/>
    </function>
    <function name='xmlParseBalancedChunkMemoryRecover' file='parser'>
      <info>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar: </info>
      <return type='int' info='0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise In case recover is set to 1, the nodelist will not be empty even if the parsed chunk is not well balanced. '/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL) '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL) '/>
      <arg name='depth' type='int' info='Used for loop detection, use 0 '/>
      <arg name='string' type='const xmlChar *' info='the input string in UTF8 or ISO-Latin (zero terminated) '/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes '/>
      <arg name='recover' type='int' info='return nodes even if the data is broken (use 0) '/>
    </function>
    <function name='xmlParseCDSect' file='parserInternals'>
      <info>Parse escaped pure raw content. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseCatalogFile' file='catalog'>
      <info>parse an XML file and build a tree. It&apos;s like xmlParseFile() except it bypass all catalog lookups.</info>
      <return type='xmlDocPtr' info='the resulting document tree or NULL in case of error '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlParseCharData' file='parserInternals'>
      <info>parse a CharData section. if we are within a CDATA section &apos;]]&gt;&apos; marks an end of section. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='cdata' type='int' info='int indicating whether we are within a CDATA section '/>
    </function>
    <function name='xmlParseCharEncoding' file='encoding'>
      <info>Compare the string to the known encoding schemes already known. Note that the comparison is case insensitive accordingly to the section [XML] 4.3.3 Character Encoding in Entities.</info>
      <return type='xmlCharEncoding' info='one of the XML_CHAR_ENCODING_... values or XML_CHAR_ENCODING_NONE if not recognized. '/>
      <arg name='name' type='const char *' info='the encoding name as parsed, in UTF-8 format (ASCII actually) '/>
    </function>
    <function name='xmlParseCharRef' file='parserInternals'>
      <info>parse Reference declarations </info>
      <return type='int' info='the value parsed (as an int), 0 in case of error '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseChunk' file='parser'>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='chunk' type='const char *' info='an char array '/>
      <arg name='size' type='int' info='the size in byte of the chunk '/>
      <arg name='terminate' type='int' info='last chunk indicator '/>
    </function>
    <function name='xmlParseComment' file='parserInternals'>
      <info>Skip an XML (SGML) comment &lt;!-- .... --&gt; The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen) must not occur within comments. &quot; </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseContent' file='parserInternals'>
      <info>Parse a content: </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseCtxtExternalEntity' file='parser'>
      <info>Parse an external general entity within an existing parsing context An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int' info='0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise '/>
      <arg name='ctx' type='xmlParserCtxtPtr' info='the existing parsing context '/>
      <arg name='URL' type='const xmlChar *' info='the URL for the entity to load '/>
      <arg name='ID' type='const xmlChar *' info='the System ID for the entity to load '/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes '/>
    </function>
    <function name='xmlParseDTD' file='parser'>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr' info='the resulting xmlDtdPtr or NULL in case of error. '/>
      <arg name='ExternalID' type='const xmlChar *' info='a NAME* containing the External ID of the DTD '/>
      <arg name='SystemID' type='const xmlChar *' info='a NAME* containing the URL to the DTD '/>
    </function>
    <function name='xmlParseDefaultDecl' file='parserInternals'>
      <info>Parse an attribute default declaration </info>
      <return type='int' info='XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED or XML_ATTRIBUTE_FIXED. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='value' type='xmlChar **' info='Receive a possible fixed default value for the attribute '/>
    </function>
    <function name='xmlParseDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
    </function>
    <function name='xmlParseDocTypeDecl' file='parserInternals'>
      <info>parse a DOCTYPE declaration </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseDocument' file='parser'>
      <info>parse an XML document (and build a tree if using the standard SAX interface). </info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseElement' file='parserInternals'>
      <info>parse an XML element, this is highly recursive </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseElementChildrenContentD' file='parserInternals'>
      <info>VMS version of xmlParseElementChildrenContentDecl()</info>
      <return type='xmlElementContentPtr' info='the tree of xmlElementContentPtr describing the element hierarchy. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseElementChildrenContentDecl' file='parserInternals'>
      <info>parse the declaration for a Mixed Element content The leading &apos;(&apos; and spaces have been skipped in xmlParseElementContentDecl </info>
      <return type='xmlElementContentPtr' info='the tree of xmlElementContentPtr describing the element hierarchy. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='inputchk' type='xmlParserInputPtr'/>
    </function>
    <function name='xmlParseElementContentDecl' file='parserInternals'>
      <info>parse the declaration for an Element content either Mixed or Children, the cases EMPTY and ANY are handled directly in xmlParseElementDecl </info>
      <return type='int' info='the type of element content XML_ELEMENT_TYPE_xxx '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='name' type='xmlChar *' info='the name of the element being defined. '/>
      <arg name='result' type='xmlElementContentPtr *' info='the Element Content pointer will be stored here if any '/>
    </function>
    <function name='xmlParseElementDecl' file='parserInternals'>
      <info>parse an Element declaration. </info>
      <return type='int' info='the type of the element, or -1 in case of error '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseElementMixedContentDecl' file='parserInternals'>
      <info>parse the declaration for a Mixed Element content The leading &apos;(&apos; and spaces have been skipped in xmlParseElementContentDecl </info>
      <return type='xmlElementContentPtr' info='the list of the xmlElementContentPtr describing the element choices '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='inputchk' type='xmlParserInputPtr'/>
    </function>
    <function name='xmlParseEncName' file='parserInternals'>
      <info>parse the XML encoding name </info>
      <return type='xmlChar *' info='the encoding name value or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseEncodingDecl' file='parserInternals'>
      <info>parse the XML encoding declaration </info>
      <return type='xmlChar *' info='the encoding value or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseEndTag' file='parserInternals'>
      <info>parse an end of tag </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseEntity' file='parser'>
      <info>parse an XML external entity out of context and build a tree. </info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlParseEntityDecl' file='parserInternals'>
      <info>parse &lt;!ENTITY declarations </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseEntityRef' file='parserInternals'>
      <info>parse ENTITY references declarations </info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found, or NULL otherwise. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseEntityValue' file='parserInternals'>
      <info>parse a value for ENTITY declarations </info>
      <return type='xmlChar *' info='the EntityValue parsed with reference substituted or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='orig' type='xmlChar **' info='if non-NULL store a copy of the original entity value '/>
    </function>
    <function name='xmlParseEnumeratedType' file='parserInternals'>
      <info>parse an Enumerated attribute type. </info>
      <return type='int' info='XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='tree' type='xmlEnumerationPtr *' info='the enumeration tree built while parsing '/>
    </function>
    <function name='xmlParseEnumerationType' file='parserInternals'>
      <info>parse an Enumeration attribute type. </info>
      <return type='xmlEnumerationPtr' info='the enumeration attribute tree built while parsing '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseExtParsedEnt' file='parser'>
      <info>parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseExternalEntity' file='parser'>
      <info>Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt. </info>
      <return type='int' info='0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise '/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL) '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL) '/>
      <arg name='depth' type='int' info='Used for loop detection, use 0 '/>
      <arg name='URL' type='const xmlChar *' info='the URL for the entity to load '/>
      <arg name='ID' type='const xmlChar *' info='the System ID for the entity to load '/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes '/>
    </function>
    <function name='xmlParseExternalID' file='parserInternals'>
      <info>Parse an External ID or a Public ID </info>
      <return type='xmlChar *' info='the function returns SystemLiteral and in the second case publicID receives PubidLiteral, is strict is off it is possible to return NULL and have publicID set. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='publicID' type='xmlChar **' info='a xmlChar** receiving PubidLiteral '/>
      <arg name='strict' type='int' info='indicate whether we should restrict parsing to only production [75], see NOTE below '/>
    </function>
    <function name='xmlParseExternalSubset' file='parserInternals'>
      <info>parse Markup declarations from an external subset </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='ExternalID' type='const xmlChar *' info='the external identifier '/>
      <arg name='SystemID' type='const xmlChar *' info='the system identifier (or URL) '/>
    </function>
    <function name='xmlParseFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlDocPtr' info='the resulting document tree if the file was wellformed, NULL otherwise. '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlParseMarkupDecl' file='parserInternals'>
      <info>parse Markup declarations </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseMemory' file='parser'>
      <info>parse an XML in-memory block and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='buffer' type='const char *' info='an pointer to a char array '/>
      <arg name='size' type='int' info='the size of the array '/>
    </function>
    <function name='xmlParseMisc' file='parserInternals'>
      <info>parse an XML Misc* optional field. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseName' file='parserInternals'>
      <info>parse an XML name. </info>
      <return type='xmlChar *' info='the Name parsed or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseNamespace' file='parserInternals'>
      <info>xmlParseNamespace: parse specific PI &apos;&lt;?namespace ...&apos; constructs. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseNmtoken' file='parserInternals'>
      <info>parse an XML Nmtoken. </info>
      <return type='xmlChar *' info='the Nmtoken parsed or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseNotationDecl' file='parserInternals'>
      <info>parse a notation declaration </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseNotationType' file='parserInternals'>
      <info>parse an Notation attribute type. </info>
      <return type='xmlEnumerationPtr' info='the notation attribute tree built while parsing '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParsePEReference' file='parserInternals'>
      <info>parse PEReference declarations The entity content is handled directly by pushing it&apos;s content as a new input stream. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParsePI' file='parserInternals'>
      <info>parse an XML Processing Instruction. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParsePITarget' file='parserInternals'>
      <info>parse the name of a PI </info>
      <return type='xmlChar *' info='the PITarget name or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParsePubidLiteral' file='parserInternals'>
      <info>parse an XML public literal </info>
      <return type='xmlChar *' info='the PubidLiteral parsed or NULL. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseQuotedString' file='parserInternals'>
      <info>Parse and return a string between quotes or doublequotes </info>
      <return type='xmlChar *' info='the string parser or NULL. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseReference' file='parserInternals'>
      <info>parse and handle entity references in content, depending on the SAX interface, this may end-up in a call to character() if this is a CharRef, a predefined entity, if there is no reference() callback. or if the parser was asked to switch to that mode. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseSDDecl' file='parserInternals'>
      <info>parse the XML standalone declaration </info>
      <return type='int' info='1 if standalone, 0 otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseStartTag' file='parserInternals'>
      <info>parse a start of tag either for rule element or EmptyElement. In both case we don&apos;t parse the tag closing chars. </info>
      <return type='xmlChar *' info='the element name parsed '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseSystemLiteral' file='parserInternals'>
      <info>parse an XML Literal </info>
      <return type='xmlChar *' info='the SystemLiteral parsed or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseTextDecl' file='parserInternals'>
      <info>parse an XML declaration header for external entities </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseURI' file='uri'>
      <info>Parse an URI </info>
      <return type='xmlURIPtr' info='a newly build xmlURIPtr or NULL in case of error '/>
      <arg name='str' type='const char *' info='the URI string to analyze '/>
    </function>
    <function name='xmlParseURIReference' file='uri'>
      <info>Parse an URI reference string and fills in the appropriate fields of the uri structure </info>
      <return type='int' info='0 or the error code '/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an URI structure '/>
      <arg name='str' type='const char *' info='the string to analyze '/>
    </function>
    <function name='xmlParseVersionInfo' file='parserInternals'>
      <info>parse the XML version. </info>
      <return type='xmlChar *' info='the version string, e.g. &quot;1.0&quot; '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseVersionNum' file='parserInternals'>
      <info>parse the XML version value. </info>
      <return type='xmlChar *' info='the string giving the XML version number, or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParseXMLDecl' file='parserInternals'>
      <info>parse an XML declaration header </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlParserAddNodeInfo' file='parser'>
      <info>Insert node info record into the sorted sequence</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='info' type='const xmlParserNodeInfoPtr' info='a node info sequence pointer '/>
    </function>
    <struct name='xmlParserCtxt' file='tree' info='The parser context. NOTE This doesn&apos;t completely define the parser state, the (current ?) design of the parser uses recursive function calls since this allow and easy mapping from the production rules of the specification to the actual code. The drawback is that the actual function call also reflect the parser state. However most of the parsing routines takes as the only argument the parser context pointer, so migrating to a state based parser for progressive parsing shouldn&apos;t be too hard.'/>
    <typedef name='xmlParserCtxtPtr' file='tree'/>
    <macro name='xmlParserDebugEntities' file='globals'>
      <info>Global setting, asking the parser to print out debugging informations. while handling entities. Disabled by default</info>
    </macro>
    <function name='xmlParserError' file='xmlerror'>
      <info>Display and format an error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </function>
    <enum name='xmlParserErrors' file='xmlerror'/>
    <function name='xmlParserFindNodeInfo' file='parser'>
      <info>Find the parser node info struct for a given node</info>
      <return type='const xmlParserNodeInfo *' info='an xmlParserNodeInfo block pointer or NULL '/>
      <arg name='ctxt' type='const xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='node' type='const xmlNodePtr' info='an XML node within the tree '/>
    </function>
    <function name='xmlParserFindNodeInfoIndex' file='parser'>
      <info>xmlParserFindNodeInfoIndex : Find the index that the info record for the given node is or should be at in a sorted sequence</info>
      <return type='unsigned long' info='a long indicating the position of the record '/>
      <arg name='seq' type='const xmlParserNodeInfoSeqPtr' info='a node info sequence pointer '/>
      <arg name='node' type='const xmlNodePtr' info='an XML node pointer '/>
    </function>
    <function name='xmlParserGetDirectory' file='xmlIO'>
      <info>lookup the directory for that file</info>
      <return type='char *' info='a new allocated string containing the directory, or NULL. '/>
      <arg name='filename' type='const char *' info='the path to a file '/>
    </function>
    <function name='xmlParserHandlePEReference' file='parserInternals'>
      <info>[69] PEReference ::= &apos;%&apos; Name &apos;;&apos; </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
    </function>
    <function name='xmlParserHandleReference' file='parserInternals'>
      <info>TODO: Remove, now deprecated ... the test is done directly in the content parsing routines. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
    </function>
    <struct name='xmlParserInput' file='tree' info='An xmlParserInput is an input flow for the XML processor. Each entity parsed is associated an xmlParserInput (except the few predefined ones). This is the case both for internal entities - in which case the flow is already completely in memory - or external entities - in which case we use the buf structure for progressive reading and I18N conversions to the internal UTF-8 format.'/>
    <struct name='xmlParserInputBuffer' file='xmlIO'/>
    <function name='xmlParserInputBufferCreateFd' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a file descriptor</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='fd' type='int' info='a file descriptor number '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferCreateFile' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a FILE * buffered C I/O</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='file' type='FILE *' info='a FILE* '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferCreateFilename' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a file If filename is &quot;-&apos; then we use stdin as the input. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Do an encoding check if enc == XML_CHAR_ENCODING_NONE</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='URI' type='const char *' info='a C string containing the URI or filename '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferCreateFname' file='xmlIO'>
      <info>VMS version of xmlParserInputBufferCreateFilename()</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='URI' type='const char *' info='a C string containing the URI or filename '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferCreateIO' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from an I/O handler</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function '/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function '/>
      <arg name='ioctx' type='void *' info='an I/O handler '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferCreateMem' file='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a memory area.</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL '/>
      <arg name='mem' type='const char *' info='the memory input '/>
      <arg name='size' type='int' info='the length of the memory block '/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known '/>
    </function>
    <function name='xmlParserInputBufferGrow' file='xmlIO'>
      <info>Grow up the content of the input buffer, the old data are preserved This routine handle the I18N transcoding to internal UTF-8 This routine is used when operating the parser in normal (pull) mode </info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error. '/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input '/>
      <arg name='len' type='int' info='indicative value of the amount of chars to read '/>
    </function>
    <typedef name='xmlParserInputBufferPtr' file='tree'/>
    <function name='xmlParserInputBufferPush' file='xmlIO'>
      <info>Push the content of the arry in the input buffer This routine handle the I18N transcoding to internal UTF-8 This is used when operating the parser in progressive (push) mode.</info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error. '/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input '/>
      <arg name='len' type='int' info='the size in bytes of the array. '/>
      <arg name='buf' type='const char *' info='an char array '/>
    </function>
    <function name='xmlParserInputBufferRead' file='xmlIO'>
      <info>Refresh the content of the input buffer, the old data are considered consumed This routine handle the I18N transcoding to internal UTF-8</info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error. '/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input '/>
      <arg name='len' type='int' info='indicative value of the amount of chars to read '/>
    </function>
    <functype name='xmlParserInputDeallocate' file='parser'>
      <info>Callback for freeing some parser input allocations.</info>
      <return type='void'/>
      <arg name='str' type='xmlChar *' info='the string to deallocate '/>
    </functype>
    <function name='xmlParserInputGrow' file='parser'>
      <info>This function increase the input for the parser. It tries to preserve pointers to the input buffer, and keep already read data</info>
      <return type='int' info='the number of xmlChars read, or -1 in case of error, 0 indicate the end of this entity '/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input '/>
      <arg name='len' type='int' info='an indicative size for the lookahead '/>
    </function>
    <typedef name='xmlParserInputPtr' file='tree'/>
    <function name='xmlParserInputRead' file='parser'>
      <info>This function refresh the input for the parser. It doesn&apos;t try to preserve pointers to the input buffer, and discard already read data</info>
      <return type='int' info='the number of xmlChars read, or -1 in case of error, 0 indicate the end of this entity '/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input '/>
      <arg name='len' type='int' info='an indicative size for the lookahead '/>
    </function>
    <function name='xmlParserInputShrink' file='parserInternals'>
      <info>This function removes used input for the parser.</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input '/>
    </function>
    <enum name='xmlParserInputState' file='parser'/>
    <struct name='xmlParserNodeInfo' file='parser' info='The parser can be asked to collect Node informations, i.e. at what place in the file they were detected. NOTE: This is off by default and not very well tested.'/>
    <typedef name='xmlParserNodeInfoPtr' file='parser'/>
    <struct name='xmlParserNodeInfoSeq' file='parser'/>
    <typedef name='xmlParserNodeInfoSeqPtr' file='parser'/>
    <function name='xmlParserPrintFileContext' file='xmlerror'>
      <info>Displays current context within the input content for error tracking</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr input '/>
    </function>
    <function name='xmlParserPrintFileInfo' file='xmlerror'>
      <info>Displays the associated file and line informations for the current input</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr input '/>
    </function>
    <function name='xmlParserValidityError' file='xmlerror'>
      <info>Display and format an validity error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </function>
    <function name='xmlParserValidityWarning' file='xmlerror'>
      <info>Display and format a validity warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </function>
    <macro name='xmlParserVersion' file='globals'>
      <info>Constant string describing the internal version of the library</info>
    </macro>
    <function name='xmlParserWarning' file='xmlerror'>
      <info>Display and format a warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context '/>
      <arg name='msg' type='const char *' info='the message to display/transmit '/>
      <arg name='' type='...'/>
    </function>
    <function name='xmlPedanticParserDefault' file='parser'>
      <info>Set and return the previous value for enabling pedantic warnings.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution. '/>
      <arg name='val' type='int' info='int 0 or 1 '/>
    </function>
    <macro name='xmlPedanticParserDefaultValue' file='globals'>
      <info>Global setting, indicate that the parser be pedantic Disabled by default.</info>
    </macro>
    <function name='xmlPopInput' file='parserInternals'>
      <info>xmlPopInput: the current input pointed by ctxt-&gt;input came to an end pop it and return the next char.</info>
      <return type='xmlChar' info='the current xmlChar in the parser context '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlPrintURI' file='uri'>
      <info>Prints the URI in the stream steam.</info>
      <return type='void'/>
      <arg name='stream' type='FILE *' info='a FILE* for the output '/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI '/>
    </function>
    <function name='xmlPushInput' file='parserInternals'>
      <info>xmlPushInput: switch to a new input stream which is stacked on top of the previous one(s).</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='input' type='xmlParserInputPtr' info='an XML parser input fragment (entity, XML fragment ...). '/>
    </function>
    <struct name='xmlRMutex' file='threads'/>
    <function name='xmlRMutexLock' file='threads'>
      <info>xmlRMutexLock() is used to lock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr' info='the reentrant mutex '/>
    </function>
    <typedef name='xmlRMutexPtr' file='threads'/>
    <function name='xmlRMutexUnlock' file='threads'>
      <info>xmlRMutexUnlock() is used to unlock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr' info='the reentrant mutex '/>
    </function>
    <macro name='xmlRealloc' file='globals'>
      <info>Wrapper for the realloc() function used in the XML library.</info>
      <arg name='ptr' info='pointer to the existing allocated area '/>
      <arg name='size' info='number of bytes to allocate '/>
    </macro>
    <functype name='xmlReallocFunc' file='xmlmemory'>
      <info>Signature for a realloc() implementation.</info>
      <return type='void *'/>
      <arg name='mem' type='void *' info='an already allocated block of memory '/>
      <arg name='size' type='size_t' info='the new size requested in bytes '/>
    </functype>
    <function name='xmlReallocLoc' file='xmlmemory'>
      <info>a realloc() equivalent, with logging of the allocation info.</info>
      <return type='void *'/>
      <arg name='ptr' type='void *' info='the initial memory block pointer '/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate. '/>
      <arg name='file' type='const char *' info='the file name or NULL '/>
      <arg name='line' type='int' info='the line number '/>
    </function>
    <function name='xmlReconciliateNs' file='tree'>
      <info>This function checks that all the namespaces declared within the given tree are properly declared. This is needed for example after Copy or Cut and then paste operations. The subtree may still hold pointers to namespace declarations outside the subtree or invalid/masked. As much as possible the function try to reuse the existing namespaces found in the new environment. If not possible the new namespaces are redeclared on tree at the top of the given subtree.</info>
      <return type='int' info='the number of namespace declarations created or -1 in case of error. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='tree' type='xmlNodePtr' info='a node defining the subtree to reconciliate '/>
    </function>
    <function name='xmlRecoverDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
    </function>
    <function name='xmlRecoverFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlRecoverMemory' file='parser'>
      <info>parse an XML in-memory block and build a tree. In the case the document is not Well Formed, a tree is built anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='buffer' type='const char *' info='an pointer to a char array '/>
      <arg name='size' type='int' info='the size of the array '/>
    </function>
    <struct name='xmlRef' file='tree' info='An XML IDREF instance.'/>
    <typedef name='xmlRefPtr' file='tree'/>
    <typedef name='xmlRefTablePtr' file='valid'/>
    <functype name='xmlRegExecCallbacks' file='xmlregexp'>
      <return type='void'/>
      <arg name='exec' type='xmlRegExecCtxtPtr'/>
      <arg name='token' type='const xmlChar *'/>
      <arg name='transdata' type='void *'/>
      <arg name='inputdata' type='void *'/>
    </functype>
    <struct name='xmlRegExecCtxt' file='xmlregexp'/>
    <typedef name='xmlRegExecCtxtPtr' file='xmlregexp' info='A libxml progressive regular expression evaluation context'/>
    <function name='xmlRegExecPushString' file='xmlregexp'>
      <info>Push one input token in the execution context</info>
      <return type='int' info='1 if the regexp reached a final state, 0 if non-final, and a negative value in case of error. '/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regexp execution context '/>
      <arg name='value' type='const xmlChar *' info='a string token input '/>
      <arg name='data' type='void *' info='data associated to the token to reuse in callbacks '/>
    </function>
    <function name='xmlRegFreeExecCtxt' file='xmlregexp'>
      <info>Free the structures associated to a regular expression evaulation context.</info>
      <return type='void'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regular expression evaulation context '/>
    </function>
    <function name='xmlRegFreeRegexp' file='xmlregexp'>
      <info>Free a regexp</info>
      <return type='void'/>
      <arg name='regexp' type='xmlRegexpPtr' info='the regexp '/>
    </function>
    <function name='xmlRegNewExecCtxt' file='xmlregexp'>
      <return type='xmlRegExecCtxtPtr'/>
      <arg name='comp' type='xmlRegexpPtr'/>
      <arg name='callback' type='xmlRegExecCallbacks'/>
      <arg name='data' type='void *'/>
    </function>
    <struct name='xmlRegexp' file='xmlregexp'/>
    <function name='xmlRegexpCompile' file='xmlregexp'>
      <info>Parses a regular expression conforming to XML Schemas Part 2 Datatype Appendix F and build an automata suitable for testing strings against that regular expression</info>
      <return type='xmlRegexpPtr' info='the compiled expression or NULL in case of error '/>
      <arg name='regexp' type='const xmlChar *' info='a regular expression string '/>
    </function>
    <function name='xmlRegexpExec' file='xmlregexp'>
      <info>Check if the regular expression generate the value</info>
      <return type='int' info='1 if it matches, 0 if not and a negativa value in case of error '/>
      <arg name='comp' type='xmlRegexpPtr' info='the compiled regular expression '/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlRegexpIsDeterminist' file='xmlregexp'>
      <info>Check if the regular expression is determinist</info>
      <return type='int' info='1 if it yes, 0 if not and a negativa value in case of error '/>
      <arg name='comp' type='xmlRegexpPtr' info='the compiled regular expression '/>
    </function>
    <function name='xmlRegexpPrint' file='xmlregexp'>
      <info>Print the content of the compiled regular expression</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the file for the output debug '/>
      <arg name='regexp' type='xmlRegexpPtr' info='the compiled regexp '/>
    </function>
    <typedef name='xmlRegexpPtr' file='xmlregexp' info='A libxml regular expression, they can actually be far more complex thank the POSIX regex expressions.'/>
    <function name='xmlRegisterCharEncodingHandler' file='encoding'>
      <info>Register the char encoding handler, surprising, isn&apos;t it ?</info>
      <return type='void'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr handler block '/>
    </function>
    <function name='xmlRegisterDefaultInputCallbacks' file='xmlIO'>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterDefaultOutputCallbacks' file='xmlIO'>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterHTTPPostCallbacks' file='xmlIO'>
      <info>By default, libxml submits HTTP output requests using the &quot;PUT&quot; method. Calling this method changes the HTTP output method to use the &quot;POST&quot; method instead.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterInputCallbacks' file='xmlIO'>
      <info>Register a new set of I/O callback for handling parser input.</info>
      <return type='int' info='the registered handler number or -1 in case of error '/>
      <arg name='matchFunc' type='xmlInputMatchCallback' info='the xmlInputMatchCallback '/>
      <arg name='openFunc' type='xmlInputOpenCallback' info='the xmlInputOpenCallback '/>
      <arg name='readFunc' type='xmlInputReadCallback' info='the xmlInputReadCallback '/>
      <arg name='closeFunc' type='xmlInputCloseCallback' info='the xmlInputCloseCallback '/>
    </function>
    <function name='xmlRegisterOutputCallbacks' file='xmlIO'>
      <info>Register a new set of I/O callback for handling output.</info>
      <return type='int' info='the registered handler number or -1 in case of error '/>
      <arg name='matchFunc' type='xmlOutputMatchCallback' info='the xmlOutputMatchCallback '/>
      <arg name='openFunc' type='xmlOutputOpenCallback' info='the xmlOutputOpenCallback '/>
      <arg name='writeFunc' type='xmlOutputWriteCallback' info='the xmlOutputWriteCallback '/>
      <arg name='closeFunc' type='xmlOutputCloseCallback' info='the xmlOutputCloseCallback '/>
    </function>
    <function name='xmlRemoveID' file='valid'>
      <info>Remove the given attribute from the ID table maintained internally.</info>
      <return type='int' info='-1 if the lookup failed and 0 otherwise '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute '/>
    </function>
    <function name='xmlRemoveProp' file='tree'>
      <info>Unlink and free one attribute, all the content is freed too Note this doesn&apos;t work for namespace definition attributes</info>
      <return type='int' info='0 if success and -1 in case of error. '/>
      <arg name='cur' type='xmlAttrPtr' info='an attribute '/>
    </function>
    <function name='xmlRemoveRef' file='valid'>
      <info>Remove the given attribute from the Ref table maintained internally.</info>
      <return type='int' info='-1 if the lookup failed and 0 otherwise '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute '/>
    </function>
    <function name='xmlReplaceNode' file='tree'>
      <info>Unlink the old node from it&apos;s current context, prune the new one at the same place. If cur was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr' info='old node '/>
      <arg name='old' type='xmlNodePtr' info='the old node '/>
      <arg name='cur' type='xmlNodePtr' info='the node '/>
    </function>
    <macro name='xmlRootNode' file='tree'>
      <info>Macro for compatibility naming layer with libxml1.</info>
    </macro>
    <struct name='xmlSAXHandler' file='tree' info='A SAX handler is bunch of callbacks called by the parser when processing of the input generate data or structure informations.'/>
    <typedef name='xmlSAXHandlerPtr' file='tree'/>
    <struct name='xmlSAXLocator' file='tree' info='A SAX Locator.'/>
    <typedef name='xmlSAXLocatorPtr' file='tree'/>
    <function name='xmlSAXParseDTD' file='parser'>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr' info='the resulting xmlDtdPtr or NULL in case of error. '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='ExternalID' type='const xmlChar *' info='a NAME* containing the External ID of the DTD '/>
      <arg name='SystemID' type='const xmlChar *' info='a NAME* containing the URL to the DTD '/>
    </function>
    <function name='xmlSAXParseDoc' file='parser'>
      <info>parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar '/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents '/>
    </function>
    <function name='xmlSAXParseEntity' file='parser'>
      <info>parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. </info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='filename' type='const char *' info='the filename '/>
    </function>
    <function name='xmlSAXParseFile' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents '/>
    </function>
    <function name='xmlSAXParseFileWithData' file='parser'>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines. </info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='filename' type='const char *' info='the filename '/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents '/>
      <arg name='data' type='void *' info='the userdata '/>
    </function>
    <function name='xmlSAXParseMemory' file='parser'>
      <info>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block '/>
      <arg name='buffer' type='const char *' info='an pointer to a char array '/>
      <arg name='size' type='int' info='the size of the array '/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read not Well Formed documents '/>
    </function>
    <function name='xmlSAXUserParseFile' file='parser'>
      <info>parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided</info>
      <return type='int' info='0 in case of success or a error number otherwise '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='filename' type='const char *' info='a file name '/>
    </function>
    <function name='xmlSAXUserParseMemory' file='parser'>
      <info>A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines.</info>
      <return type='int' info='0 in case of success or a error number otherwise '/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler '/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks '/>
      <arg name='buffer' type='const char *' info='an in-memory XML document input '/>
      <arg name='size' type='int' info='the length of the XML document in bytes '/>
    </function>
    <function name='xmlSaveFile' file='tree'>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If filename is &quot;-&quot; the stdout file is used.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename (or URL) '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlSaveFileEnc' file='tree'>
      <info>Dump an XML document, converting it to the given encoding</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename (or URL) '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the name of an encoding (or NULL) '/>
    </function>
    <function name='xmlSaveFileTo' file='tree'>
      <info>Dump an XML document to an I/O buffer.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output I/O buffer '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the encoding if any assuming the I/O layer handles the trancoding '/>
    </function>
    <function name='xmlSaveFormatFile' file='tree'>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If filename is &quot;-&quot; the stdout file is used. If format is set then the document will be indented on output.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='filename' type='const char *' info='the filename (or URL) '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <function name='xmlSaveFormatFileEnc' file='tree'>
      <return type='int' info='the number of bytes written or -1 in case of error. '/>
      <arg name='filename' type='const char *' info='the filename or URL to output '/>
      <arg name='cur' type='xmlDocPtr' info='the document being saved '/>
      <arg name='encoding' type='const char *' info='the name of the encoding to use or NULL. '/>
      <arg name='format' type='int' info='should formatting spaces be added. '/>
    </function>
    <function name='xmlSaveFormatFileTo' file='tree'>
      <info>Dump an XML document to an I/O buffer.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output I/O buffer '/>
      <arg name='cur' type='xmlDocPtr' info='the document '/>
      <arg name='encoding' type='const char *' info='the encoding if any assuming the I/O layer handles the trancoding '/>
      <arg name='format' type='int' info='should formatting spaces been added '/>
    </function>
    <macro name='xmlSaveNoEmptyTags' file='globals'>
      <info>Global setting, asking the serializer to not output empty tags as &lt;empty/&gt; but &lt;empty&gt;&lt;/empty&gt;. those two forms are undistinguishable once parsed. Disabled by default</info>
    </macro>
    <function name='xmlSaveUri' file='uri'>
      <info>Save the URI as an escaped string</info>
      <return type='xmlChar *' info='a new string (to be deallocated by caller) '/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI '/>
    </function>
    <function name='xmlScanName' file='parserInternals'>
      <info>Trickery: parse an XML name but without consuming the input flow Needed for rollback cases. Used only when parsing entities references. </info>
      <return type='xmlChar *' info='the Name parsed or NULL '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <struct name='xmlSchema' file='schemasInternals'/>
    <struct name='xmlSchemaAnnot' file='schemasInternals'/>
    <typedef name='xmlSchemaAnnotPtr' file='schemasInternals'/>
    <struct name='xmlSchemaAttribute' file='schemasInternals'/>
    <struct name='xmlSchemaAttributeGroup' file='schemasInternals'/>
    <typedef name='xmlSchemaAttributeGroupPtr' file='schemasInternals'/>
    <typedef name='xmlSchemaAttributePtr' file='schemasInternals'/>
    <enum name='xmlSchemaContentType' file='schemasInternals'/>
    <struct name='xmlSchemaElement' file='schemasInternals'/>
    <typedef name='xmlSchemaElementPtr' file='schemasInternals'/>
    <struct name='xmlSchemaFacet' file='schemasInternals'/>
    <typedef name='xmlSchemaFacetPtr' file='schemasInternals'/>
    <function name='xmlSchemaFreeType' file='schemasInternals'>
      <info>Deallocate a Schema Type structure.</info>
      <return type='void'/>
      <arg name='type' type='xmlSchemaTypePtr' info='a schema type structure '/>
    </function>
    <struct name='xmlSchemaNotation' file='schemasInternals'/>
    <typedef name='xmlSchemaNotationPtr' file='schemasInternals'/>
    <struct name='xmlSchemaType' file='schemasInternals'/>
    <typedef name='xmlSchemaTypePtr' file='schemasInternals'/>
    <enum name='xmlSchemaTypeType' file='schemasInternals'/>
    <struct name='xmlSchemaVal' file='schemasInternals'/>
    <typedef name='xmlSchemaValPtr' file='schemasInternals'/>
    <function name='xmlSearchNs' file='tree'>
      <info>Search a Ns registered under a given name space for a document. recurse on the parents until it finds the defined namespace or return NULL otherwise. nameSpace can be NULL, this is a search for the default namespace. We don&apos;t allow to cross entities boundaries. If you don&apos;t declare the namespace within those you will be in troubles !!! A warning is generated to cover this case.</info>
      <return type='xmlNsPtr' info='the namespace pointer or NULL. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='node' type='xmlNodePtr' info='the current node '/>
      <arg name='nameSpace' type='const xmlChar *' info='the namespace prefix '/>
    </function>
    <function name='xmlSearchNsByHref' file='tree'>
      <info>Search a Ns aliasing a given URI. Recurse on the parents until it finds the defined namespace or return NULL otherwise.</info>
      <return type='xmlNsPtr' info='the namespace pointer or NULL. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='node' type='xmlNodePtr' info='the current node '/>
      <arg name='href' type='const xmlChar *' info='the namespace value '/>
    </function>
    <function name='xmlSetBufferAllocationScheme' file='tree'>
      <info>Set the buffer allocation method. Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, improves performance</info>
      <return type='void'/>
      <arg name='scheme' type='xmlBufferAllocationScheme' info='allocation method to use '/>
    </function>
    <function name='xmlSetCompressMode' file='tree'>
      <info>set the default compression mode used, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='mode' type='int' info='the compression ratio '/>
    </function>
    <function name='xmlSetDocCompressMode' file='tree'>
      <info>set the compression ratio for a document, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='mode' type='int' info='the compression ratio '/>
    </function>
    <function name='xmlSetEntityReferenceFunc' file='parserInternals'>
      <info>Set the function to call call back when a xml reference has been made</info>
      <return type='void'/>
      <arg name='func' type='xmlEntityReferenceFunc' info='A valid function '/>
    </function>
    <function name='xmlSetExternalEntityLoader' file='parser'>
      <info>Changes the defaultexternal entity resolver function for the application</info>
      <return type='void'/>
      <arg name='f' type='xmlExternalEntityLoader' info='the new entity resolver function '/>
    </function>
    <function name='xmlSetFeature' file='parser'>
      <info>Change the current value of one feature of this parser instance</info>
      <return type='int' info='-1 in case or error, 0 otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context '/>
      <arg name='name' type='const char *' info='the feature name '/>
      <arg name='value' type='void *' info='pointer to the location of the new value '/>
    </function>
    <function name='xmlSetGenericErrorFunc' file='xmlerror'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that handler will be called for subsequent error messages while not parsing nor validating. And ctx will be passed as first argument to handler One can simply force messages to be emitted to another FILE * than stderr by setting ctx to this file handle and handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context '/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function '/>
    </function>
    <function name='xmlSetListDoc' file='tree'>
      <info>update all nodes in the list to point to the right document</info>
      <return type='void'/>
      <arg name='list' type='xmlNodePtr' info='the first element '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlSetNs' file='tree'>
      <info>Associate a namespace to a node, a posteriori.</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='a node in the document '/>
      <arg name='ns' type='xmlNsPtr' info='a namespace pointer '/>
    </function>
    <function name='xmlSetNsProp' file='tree'>
      <info>Set (or reset) an attribute carried by a node. The ns structure must be in scope, this is not checked.</info>
      <return type='xmlAttrPtr' info='the attribute pointer. '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='ns' type='xmlNsPtr' info='the namespace definition '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='value' type='const xmlChar *' info='the attribute value '/>
    </function>
    <function name='xmlSetProp' file='tree'>
      <info>Set (or reset) an attribute carried by a node.</info>
      <return type='xmlAttrPtr' info='the attribute pointer. '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='value' type='const xmlChar *' info='the attribute value '/>
    </function>
    <function name='xmlSetTreeDoc' file='tree'>
      <info>update all nodes under the tree to point to the right document</info>
      <return type='void'/>
      <arg name='tree' type='xmlNodePtr' info='the top element '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
    </function>
    <function name='xmlSetupParserForBuffer' file='parser'>
      <info>Setup the parser context to parse a new buffer; Clears any prior contents from the parser context. The buffer parameter must not be NULL, but the filename parameter can be</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='buffer' type='const xmlChar*' info='a xmlChar * buffer '/>
      <arg name='filename' type='const char *' info='a file name '/>
    </function>
    <function name='xmlShell' file='debugXML'>
      <info>Implements the XML shell This allow to load, validate, view, modify and save a document using a environment similar to a UNIX commandline.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr' info='the initial document '/>
      <arg name='filename' type='char *' info='the output buffer '/>
      <arg name='input' type='xmlShellReadlineFunc' info='the line reading function '/>
      <arg name='output' type='FILE *' info='the output FILE* '/>
    </function>
    <function name='xmlShellBase' file='debugXML'>
      <info>Implements the XML shell function &quot;base&quot; dumps the current XML base of the node</info>
      <return type='int' info='0 '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='arg' type='char *' info='unused '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellCat' file='debugXML'>
      <info>Implements the XML shell function &quot;cat&quot; dumps the serialization node content (XML or HTML).</info>
      <return type='int' info='0 '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='arg' type='char *' info='unused '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <functype name='xmlShellCmd' file='debugXML'>
      <info>This is a generic signature for the XML shell functions.</info>
      <return type='int' info='an int, negative returns indicating errors. '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='a shell context '/>
      <arg name='arg' type='char *' info='a string argument '/>
      <arg name='node' type='xmlNodePtr' info='a first node '/>
      <arg name='node2' type='xmlNodePtr' info='a second node '/>
    </functype>
    <struct name='xmlShellCtxt' file='debugXML' info='A debugging shell context. TODO: add the defined function tables.'/>
    <typedef name='xmlShellCtxtPtr' file='debugXML'/>
    <function name='xmlShellDir' file='debugXML'>
      <info>Implements the XML shell function &quot;dir&quot; dumps informations about the node (namespace, attributes, content).</info>
      <return type='int' info='0 '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='arg' type='char *' info='unused '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellDu' file='debugXML'>
      <info>Implements the XML shell function &quot;du&quot; show the structure of the subtree under node tree If tree is null, the command works on the current node.</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='arg' type='char *' info='unused '/>
      <arg name='tree' type='xmlNodePtr' info='a node defining a subtree '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellList' file='debugXML'>
      <info>Implements the XML shell function &quot;ls&quot; Does an Unix like listing of the given node (like a directory)</info>
      <return type='int' info='0 '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='arg' type='char *' info='unused '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellLoad' file='debugXML'>
      <info>Implements the XML shell function &quot;load&quot; loads a new document specified by the filename</info>
      <return type='int' info='0 or -1 if loading failed '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='filename' type='char *' info='the file name '/>
      <arg name='node' type='xmlNodePtr' info='unused '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellPrintNode' file='debugXML'>
      <info>Print node to stdout</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='a non-null node to print to stdout '/>
    </function>
    <function name='xmlShellPrintXPathError' file='debugXML'>
      <info>Print the xpath error to libxml default error channel</info>
      <return type='void'/>
      <arg name='errorType' type='int' info='valid xpath error id '/>
      <arg name='arg' type='const char *' info='the argument that cause xpath to fail '/>
    </function>
    <function name='xmlShellPrintXPathResult' file='debugXML'>
      <info>Prints result to stdout</info>
      <return type='void'/>
      <arg name='list' type='xmlXPathObjectPtr' info='a valid result generated by an xpath evaluation '/>
    </function>
    <function name='xmlShellPwd' file='debugXML'>
      <info>Implements the XML shell function &quot;pwd&quot; Show the full path from the root to the node, if needed building thumblers when similar elements exists at a given ancestor level. The output is compatible with XPath commands.</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='buffer' type='char *' info='the output buffer '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <functype name='xmlShellReadlineFunc' file='debugXML'>
      <info>This is a generic signature for the XML shell input function.</info>
      <return type='char *' info='a string which will be freed by the Shell. '/>
      <arg name='prompt' type='char *' info='a string prompt '/>
    </functype>
    <function name='xmlShellSave' file='debugXML'>
      <info>Implements the XML shell function &quot;save&quot; Write the current document to the filename, or it&apos;s original name</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='filename' type='char *' info='the file name (optional) '/>
      <arg name='node' type='xmlNodePtr' info='unused '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellValidate' file='debugXML'>
      <info>Implements the XML shell function &quot;validate&quot; Validate the document, if a DTD path is provided, then the validation is done against the given DTD.</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='dtd' type='char *' info='the DTD URI (optional) '/>
      <arg name='node' type='xmlNodePtr' info='unused '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlShellWrite' file='debugXML'>
      <info>Implements the XML shell function &quot;write&quot; Write the current node to the filename, it saves the serialization of the subtree under the node specified</info>
      <return type='int' info='0 or -1 in case of error '/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context '/>
      <arg name='filename' type='char *' info='the file name '/>
      <arg name='node' type='xmlNodePtr' info='a node in the tree '/>
      <arg name='node2' type='xmlNodePtr' info='unused '/>
    </function>
    <function name='xmlSkipBlankChars' file='parserInternals'>
      <info>skip all blanks character found at that point in the input streams. It pops up finished entities in the process if allowable at that point.</info>
      <return type='int' info='the number of space chars skipped '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context '/>
    </function>
    <function name='xmlSnprintfElementContent' file='valid'>
      <info>This will dump the content of the element content definition Intended just for the debug routine</info>
      <return type='void'/>
      <arg name='buf' type='char *' info='an output buffer '/>
      <arg name='size' type='int' info='the buffer size '/>
      <arg name='content' type='xmlElementContentPtr' info='An element table '/>
      <arg name='glob' type='int' info='1 if one must print the englobing parenthesis, 0 otherwise '/>
    </function>
    <function name='xmlSplitQName' file='parserInternals'>
      <info>parse an UTF8 encoded XML qualified name string </info>
      <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any. '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
      <arg name='name' type='const xmlChar *' info='an XML parser context '/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar ** '/>
    </function>
    <function name='xmlSplitQName2' file='valid'>
      <info>parse an XML qualified name string </info>
      <return type='xmlChar *' info='NULL if not a QName, otherwise the local part, and prefix is updated to get the Prefix if any. '/>
      <arg name='name' type='const xmlChar *' info='an XML parser context '/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar ** '/>
    </function>
    <function name='xmlSprintfElementContent' file='valid'>
      <info>Deprecated, unsafe, use xmlSnprintfElementContent</info>
      <return type='void'/>
      <arg name='buf' type='char *' info='an output buffer '/>
      <arg name='content' type='xmlElementContentPtr' info='An element table '/>
      <arg name='glob' type='int' info='1 if one must print the englobing parenthesis, 0 otherwise '/>
    </function>
    <function name='xmlStopParser' file='parser'>
      <info>Blocks further parser processing</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context '/>
    </function>
    <function name='xmlStrEqual' file='parser'>
      <info>Check if both string are equal of have same content Should be a bit more readable and faster than xmlStrEqual()</info>
      <return type='int' info='1 if they are equal, 0 if they are different '/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar * '/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar * '/>
    </function>
    <function name='xmlStrcasecmp' file='parser'>
      <info>a strcasecmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison '/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar * '/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar * '/>
    </function>
    <function name='xmlStrcasestr' file='parser'>
      <info>a case-ignoring strstr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL. '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack) '/>
      <arg name='val' type='xmlChar *' info='the xmlChar to search (needle) '/>
    </function>
    <function name='xmlStrcat' file='parser'>
      <info>a strcat for array of xmlChar&apos;s. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of &apos;0&apos;.</info>
      <return type='xmlChar *' info='a new xmlChar * containing the concatenated string. '/>
      <arg name='cur' type='xmlChar *' info='the original xmlChar * array '/>
      <arg name='add' type='const xmlChar *' info='the xmlChar * array added '/>
    </function>
    <function name='xmlStrchr' file='parser'>
      <info>a strchr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL. '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array '/>
      <arg name='val' type='xmlChar' info='the xmlChar to search '/>
    </function>
    <function name='xmlStrcmp' file='parser'>
      <info>a strcmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison '/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar * '/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar * '/>
    </function>
    <function name='xmlStrdup' file='parser'>
      <info>a strdup for array of xmlChar&apos;s. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of &apos;0&apos;.</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL '/>
      <arg name='cur' type='const xmlChar *' info='the input xmlChar * '/>
    </function>
    <functype name='xmlStrdupFunc' file='xmlmemory'>
      <info>Signature for an strdup() implementation.</info>
      <return type='char *' info='the copy of the string or NULL in case of error. '/>
      <arg name='str' type='const char *' info='a zero terminated string '/>
    </functype>
    <function name='xmlStringCurrentChar' file='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer.</info>
      <return type='int' info='the current char value and its length '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context '/>
      <arg name='cur' type='const xmlChar *' info='pointer to the beginning of the char '/>
      <arg name='len' type='int *' info='pointer to the length of the char read '/>
    </function>
    <function name='xmlStringDecodeEntities' file='parserInternals'>
      <info>Takes a entity string content and process to do the adequate substitutions. </info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it ! '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
      <arg name='str' type='const xmlChar *' info='the input string '/>
      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF '/>
      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none '/>
    </function>
    <function name='xmlStringGetNodeList' file='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr' info='a pointer to the first child '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute '/>
    </function>
    <function name='xmlStringLenGetNodeList' file='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr' info='a pointer to the first child '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='value' type='const xmlChar *' info='the value of the text '/>
      <arg name='len' type='int' info='the length of the string value '/>
    </function>
    <function name='xmlStrlen' file='parser'>
      <info>length of a xmlChar&apos;s string</info>
      <return type='int' info='the number of xmlChar contained in the ARRAY. '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array '/>
    </function>
    <function name='xmlStrncasecmp' file='parser'>
      <info>a strncasecmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison '/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar * '/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar * '/>
      <arg name='len' type='int' info='the max comparison length '/>
    </function>
    <function name='xmlStrncat' file='parser'>
      <info>a strncat for array of xmlChar&apos;s, it will extend cur with the len first bytes of add.</info>
      <return type='xmlChar *' info='cur is reallocated if needed and should not be freed '/>
      <arg name='cur' type='xmlChar *' info='the original xmlChar * array '/>
      <arg name='add' type='const xmlChar *' info='the xmlChar * array added '/>
      <arg name='len' type='int' info='add '/>
    </function>
    <function name='xmlStrncmp' file='parser'>
      <info>a strncmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison '/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar * '/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar * '/>
      <arg name='len' type='int' info='the max comparison length '/>
    </function>
    <function name='xmlStrndup' file='parser'>
      <info>a strndup for array of xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL '/>
      <arg name='cur' type='const xmlChar *' info='the input xmlChar * '/>
      <arg name='len' type='int' info='cur '/>
    </function>
    <function name='xmlStrstr' file='parser'>
      <info>a strstr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL. '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack) '/>
      <arg name='val' type='const xmlChar *' info='the xmlChar to search (needle) '/>
    </function>
    <function name='xmlStrsub' file='parser'>
      <info>Extract a substring of a given string</info>
      <return type='xmlChar *' info='the xmlChar * for the first occurrence or NULL. '/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack) '/>
      <arg name='start' type='int' info='the index of the first char (zero based) '/>
      <arg name='len' type='int' info='the length of the substring '/>
    </function>
    <function name='xmlSubstituteEntitiesDefault' file='parser'>
      <info>Set and return the previous value for default entity support. Initially the parser always keep entity references instead of substituting entity values in the output. This function has to be used to change the default parser behavior SAX::substituteEntities() has to be used for changing that on a file by file basis.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution. '/>
      <arg name='val' type='int' info='int 0 or 1 '/>
    </function>
    <macro name='xmlSubstituteEntitiesDefaultValue' file='globals'>
      <info>Global variable controlling the entity substitution default behavior.</info>
    </macro>
    <function name='xmlSwitchEncoding' file='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int' info='0 in case of success, -1 otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
      <arg name='enc' type='xmlCharEncoding' info='the encoding value (number) '/>
    </function>
    <function name='xmlSwitchToEncoding' file='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int' info='0 in case of success, -1 otherwise '/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context '/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the encoding handler '/>
    </function>
    <function name='xmlTextConcat' file='tree'>
      <info>Concat the given string at the end of the existing node content</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='content' type='const xmlChar *' info='the content '/>
      <arg name='len' type='int' info='content length '/>
    </function>
    <function name='xmlTextMerge' file='tree'>
      <info>Merge two text nodes into one</info>
      <return type='xmlNodePtr' info='the first text node augmented '/>
      <arg name='first' type='xmlNodePtr' info='the first text node '/>
      <arg name='second' type='xmlNodePtr' info='the second text node being merged '/>
    </function>
    <macro name='xmlTreeIndentString' file='globals'>
      <info>The string used to do one-level indent. By default is equal to &quot; &quot; (two spaces)</info>
    </macro>
    <function name='xmlUCSIsAlphabeticPresentationForms' file='xmlunicode'>
      <info>Check whether the character is part of AlphabeticPresentationForms UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsArabic' file='xmlunicode'>
      <info>Check whether the character is part of Arabic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsArabicPresentationFormsA' file='xmlunicode'>
      <info>Check whether the character is part of ArabicPresentationForms-A UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsArabicPresentationFormsB' file='xmlunicode'>
      <info>Check whether the character is part of ArabicPresentationForms-B UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsArmenian' file='xmlunicode'>
      <info>Check whether the character is part of Armenian UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsArrows' file='xmlunicode'>
      <info>Check whether the character is part of Arrows UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBasicLatin' file='xmlunicode'>
      <info>Check whether the character is part of BasicLatin UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBengali' file='xmlunicode'>
      <info>Check whether the character is part of Bengali UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBlock' file='xmlunicode'>
      <info>Check whether the caracter is part of the UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
      <arg name='block' type='const char *'/>
    </function>
    <function name='xmlUCSIsBlockElements' file='xmlunicode'>
      <info>Check whether the character is part of BlockElements UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBopomofo' file='xmlunicode'>
      <info>Check whether the character is part of Bopomofo UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBopomofoExtended' file='xmlunicode'>
      <info>Check whether the character is part of BopomofoExtended UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBoxDrawing' file='xmlunicode'>
      <info>Check whether the character is part of BoxDrawing UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsBraillePatterns' file='xmlunicode'>
      <info>Check whether the character is part of BraillePatterns UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsByzantineMusicalSymbols' file='xmlunicode'>
      <info>Check whether the character is part of ByzantineMusicalSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKCompatibility' file='xmlunicode'>
      <info>Check whether the character is part of CJKCompatibility UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityForms' file='xmlunicode'>
      <info>Check whether the character is part of CJKCompatibilityForms UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityIdeographs' file='xmlunicode'>
      <info>Check whether the character is part of CJKCompatibilityIdeographs UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityIdeographsSupplement' file='xmlunicode'>
      <info>Check whether the character is part of CJKCompatibilityIdeographsSupplement UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKRadicalsSupplement' file='xmlunicode'>
      <info>Check whether the character is part of CJKRadicalsSupplement UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKSymbolsandPunctuation' file='xmlunicode'>
      <info>Check whether the character is part of CJKSymbolsandPunctuation UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographs' file='xmlunicode'>
      <info>Check whether the character is part of CJKUnifiedIdeographs UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographsExtensionA' file='xmlunicode'>
      <info>Check whether the character is part of CJKUnifiedIdeographsExtensionA UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographsExtensionB' file='xmlunicode'>
      <info>Check whether the character is part of CJKUnifiedIdeographsExtensionB UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCat' file='xmlunicode'>
      <info>Check whether the caracter is part of the UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
      <arg name='cat' type='const char *'/>
    </function>
    <function name='xmlUCSIsCatC' file='xmlunicode'>
      <info>Check whether the character is part of C UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatCc' file='xmlunicode'>
      <info>Check whether the character is part of Cc UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatCf' file='xmlunicode'>
      <info>Check whether the character is part of Cf UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatCo' file='xmlunicode'>
      <info>Check whether the character is part of Co UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatCs' file='xmlunicode'>
      <info>Check whether the character is part of Cs UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatL' file='xmlunicode'>
      <info>Check whether the character is part of L UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatLl' file='xmlunicode'>
      <info>Check whether the character is part of Ll UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatLm' file='xmlunicode'>
      <info>Check whether the character is part of Lm UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatLo' file='xmlunicode'>
      <info>Check whether the character is part of Lo UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatLt' file='xmlunicode'>
      <info>Check whether the character is part of Lt UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatLu' file='xmlunicode'>
      <info>Check whether the character is part of Lu UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatM' file='xmlunicode'>
      <info>Check whether the character is part of M UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatMc' file='xmlunicode'>
      <info>Check whether the character is part of Mc UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatMe' file='xmlunicode'>
      <info>Check whether the character is part of Me UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatMn' file='xmlunicode'>
      <info>Check whether the character is part of Mn UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatN' file='xmlunicode'>
      <info>Check whether the character is part of N UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatNd' file='xmlunicode'>
      <info>Check whether the character is part of Nd UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatNl' file='xmlunicode'>
      <info>Check whether the character is part of Nl UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatNo' file='xmlunicode'>
      <info>Check whether the character is part of No UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatP' file='xmlunicode'>
      <info>Check whether the character is part of P UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPc' file='xmlunicode'>
      <info>Check whether the character is part of Pc UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPd' file='xmlunicode'>
      <info>Check whether the character is part of Pd UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPe' file='xmlunicode'>
      <info>Check whether the character is part of Pe UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPf' file='xmlunicode'>
      <info>Check whether the character is part of Pf UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPi' file='xmlunicode'>
      <info>Check whether the character is part of Pi UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPo' file='xmlunicode'>
      <info>Check whether the character is part of Po UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatPs' file='xmlunicode'>
      <info>Check whether the character is part of Ps UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatS' file='xmlunicode'>
      <info>Check whether the character is part of S UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatSc' file='xmlunicode'>
      <info>Check whether the character is part of Sc UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatSk' file='xmlunicode'>
      <info>Check whether the character is part of Sk UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatSm' file='xmlunicode'>
      <info>Check whether the character is part of Sm UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatSo' file='xmlunicode'>
      <info>Check whether the character is part of So UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatZ' file='xmlunicode'>
      <info>Check whether the character is part of Z UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatZl' file='xmlunicode'>
      <info>Check whether the character is part of Zl UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatZp' file='xmlunicode'>
      <info>Check whether the character is part of Zp UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCatZs' file='xmlunicode'>
      <info>Check whether the character is part of Zs UCS Category</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCherokee' file='xmlunicode'>
      <info>Check whether the character is part of Cherokee UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCombiningDiacriticalMarks' file='xmlunicode'>
      <info>Check whether the character is part of CombiningDiacriticalMarks UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCombiningHalfMarks' file='xmlunicode'>
      <info>Check whether the character is part of CombiningHalfMarks UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCombiningMarksforSymbols' file='xmlunicode'>
      <info>Check whether the character is part of CombiningMarksforSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsControlPictures' file='xmlunicode'>
      <info>Check whether the character is part of ControlPictures UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCurrencySymbols' file='xmlunicode'>
      <info>Check whether the character is part of CurrencySymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsCyrillic' file='xmlunicode'>
      <info>Check whether the character is part of Cyrillic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsDeseret' file='xmlunicode'>
      <info>Check whether the character is part of Deseret UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsDevanagari' file='xmlunicode'>
      <info>Check whether the character is part of Devanagari UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsDingbats' file='xmlunicode'>
      <info>Check whether the character is part of Dingbats UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsEnclosedAlphanumerics' file='xmlunicode'>
      <info>Check whether the character is part of EnclosedAlphanumerics UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsEnclosedCJKLettersandMonths' file='xmlunicode'>
      <info>Check whether the character is part of EnclosedCJKLettersandMonths UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsEthiopic' file='xmlunicode'>
      <info>Check whether the character is part of Ethiopic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGeneralPunctuation' file='xmlunicode'>
      <info>Check whether the character is part of GeneralPunctuation UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGeometricShapes' file='xmlunicode'>
      <info>Check whether the character is part of GeometricShapes UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGeorgian' file='xmlunicode'>
      <info>Check whether the character is part of Georgian UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGothic' file='xmlunicode'>
      <info>Check whether the character is part of Gothic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGreek' file='xmlunicode'>
      <info>Check whether the character is part of Greek UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGreekExtended' file='xmlunicode'>
      <info>Check whether the character is part of GreekExtended UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGujarati' file='xmlunicode'>
      <info>Check whether the character is part of Gujarati UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsGurmukhi' file='xmlunicode'>
      <info>Check whether the character is part of Gurmukhi UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHalfwidthandFullwidthForms' file='xmlunicode'>
      <info>Check whether the character is part of HalfwidthandFullwidthForms UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHangulCompatibilityJamo' file='xmlunicode'>
      <info>Check whether the character is part of HangulCompatibilityJamo UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHangulJamo' file='xmlunicode'>
      <info>Check whether the character is part of HangulJamo UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHangulSyllables' file='xmlunicode'>
      <info>Check whether the character is part of HangulSyllables UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHebrew' file='xmlunicode'>
      <info>Check whether the character is part of Hebrew UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHighPrivateUseSurrogates' file='xmlunicode'>
      <info>Check whether the character is part of HighPrivateUseSurrogates UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHighSurrogates' file='xmlunicode'>
      <info>Check whether the character is part of HighSurrogates UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsHiragana' file='xmlunicode'>
      <info>Check whether the character is part of Hiragana UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsIPAExtensions' file='xmlunicode'>
      <info>Check whether the character is part of IPAExtensions UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsIdeographicDescriptionCharacters' file='xmlunicode'>
      <info>Check whether the character is part of IdeographicDescriptionCharacters UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsKanbun' file='xmlunicode'>
      <info>Check whether the character is part of Kanbun UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsKangxiRadicals' file='xmlunicode'>
      <info>Check whether the character is part of KangxiRadicals UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsKannada' file='xmlunicode'>
      <info>Check whether the character is part of Kannada UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsKatakana' file='xmlunicode'>
      <info>Check whether the character is part of Katakana UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsKhmer' file='xmlunicode'>
      <info>Check whether the character is part of Khmer UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLao' file='xmlunicode'>
      <info>Check whether the character is part of Lao UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLatin1Supplement' file='xmlunicode'>
      <info>Check whether the character is part of Latin-1Supplement UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLatinExtendedA' file='xmlunicode'>
      <info>Check whether the character is part of LatinExtended-A UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLatinExtendedAdditional' file='xmlunicode'>
      <info>Check whether the character is part of LatinExtendedAdditional UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLatinExtendedB' file='xmlunicode'>
      <info>Check whether the character is part of LatinExtended-B UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLetterlikeSymbols' file='xmlunicode'>
      <info>Check whether the character is part of LetterlikeSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsLowSurrogates' file='xmlunicode'>
      <info>Check whether the character is part of LowSurrogates UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMalayalam' file='xmlunicode'>
      <info>Check whether the character is part of Malayalam UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMathematicalAlphanumericSymbols' file='xmlunicode'>
      <info>Check whether the character is part of MathematicalAlphanumericSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMathematicalOperators' file='xmlunicode'>
      <info>Check whether the character is part of MathematicalOperators UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMiscellaneousSymbols' file='xmlunicode'>
      <info>Check whether the character is part of MiscellaneousSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMiscellaneousTechnical' file='xmlunicode'>
      <info>Check whether the character is part of MiscellaneousTechnical UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMongolian' file='xmlunicode'>
      <info>Check whether the character is part of Mongolian UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMusicalSymbols' file='xmlunicode'>
      <info>Check whether the character is part of MusicalSymbols UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsMyanmar' file='xmlunicode'>
      <info>Check whether the character is part of Myanmar UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsNumberForms' file='xmlunicode'>
      <info>Check whether the character is part of NumberForms UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsOgham' file='xmlunicode'>
      <info>Check whether the character is part of Ogham UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsOldItalic' file='xmlunicode'>
      <info>Check whether the character is part of OldItalic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsOpticalCharacterRecognition' file='xmlunicode'>
      <info>Check whether the character is part of OpticalCharacterRecognition UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsOriya' file='xmlunicode'>
      <info>Check whether the character is part of Oriya UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsPrivateUse' file='xmlunicode'>
      <info>Check whether the character is part of PrivateUse UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsRunic' file='xmlunicode'>
      <info>Check whether the character is part of Runic UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSinhala' file='xmlunicode'>
      <info>Check whether the character is part of Sinhala UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSmallFormVariants' file='xmlunicode'>
      <info>Check whether the character is part of SmallFormVariants UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSpacingModifierLetters' file='xmlunicode'>
      <info>Check whether the character is part of SpacingModifierLetters UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSpecials' file='xmlunicode'>
      <info>Check whether the character is part of Specials UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSuperscriptsandSubscripts' file='xmlunicode'>
      <info>Check whether the character is part of SuperscriptsandSubscripts UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsSyriac' file='xmlunicode'>
      <info>Check whether the character is part of Syriac UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsTags' file='xmlunicode'>
      <info>Check whether the character is part of Tags UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsTamil' file='xmlunicode'>
      <info>Check whether the character is part of Tamil UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsTelugu' file='xmlunicode'>
      <info>Check whether the character is part of Telugu UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsThaana' file='xmlunicode'>
      <info>Check whether the character is part of Thaana UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsThai' file='xmlunicode'>
      <info>Check whether the character is part of Thai UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsTibetan' file='xmlunicode'>
      <info>Check whether the character is part of Tibetan UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsUnifiedCanadianAboriginalSyllabics' file='xmlunicode'>
      <info>Check whether the character is part of UnifiedCanadianAboriginalSyllabics UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsYiRadicals' file='xmlunicode'>
      <info>Check whether the character is part of YiRadicals UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <function name='xmlUCSIsYiSyllables' file='xmlunicode'>
      <info>Check whether the character is part of YiSyllables UCS Block</info>
      <return type='int'/>
      <arg name='code' type='int'/>
    </function>
    <struct name='xmlURI' file='uri' info='A parsed URI reference. This is a struct containing the various fields as described in RFC 2396 but separated for further processing.'/>
    <function name='xmlURIEscape' file='uri'>
      <info>Escaping routine, does not do validity checks ! It will try to escape the chars needing this, but this is heuristic based it&apos;s impossible to be sure.</info>
      <return type='xmlChar *' info='an copy of the string, but escaped 25 May 2001 Uses xmlParseURI and xmlURIEscapeStr to try to escape correctly according to RFC2396. - Carl Douglas '/>
      <arg name='str' type='const xmlChar *' info='the string of the URI to escape '/>
    </function>
    <function name='xmlURIEscapeStr' file='uri'>
      <info>This routine escapes a string to hex, ignoring reserved characters (a-z) and the characters in the exception list.</info>
      <return type='xmlChar *' info='a new escaped string or NULL in case of error. '/>
      <arg name='str' type='const xmlChar *' info='string to escape '/>
      <arg name='list' type='const xmlChar *' info='exception list string of chars not to escape '/>
    </function>
    <typedef name='xmlURIPtr' file='uri'/>
    <function name='xmlURIUnescapeString' file='uri'>
      <info>Unescaping routine, does not do validity checks ! Output is direct unsigned char translation of XX values (no encoding)</info>
      <return type='char *' info='an copy of the string, but unescaped '/>
      <arg name='str' type='const char *' info='the string to unescape '/>
      <arg name='len' type='int' info='the length in bytes to unescape (or &lt;= 0 to indicate full string) '/>
      <arg name='target' type='char *' info='optional destination buffer '/>
    </function>
    <function name='xmlUTF8Strlen' file='encoding'>
      <info>compute the length of an UTF8 string, it doesn&apos;t do a full UTF8 checking of the content of the string.</info>
      <return type='int' info='the number of characters in the string or -1 in case of error '/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes '/>
    </function>
    <function name='xmlUTF8Strloc' file='encoding'>
      <info>a function to provide relative location of a UTF8 char</info>
      <return type='int' info='the relative character position of the desired char or -1 if not found '/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 * '/>
      <arg name='utfchar' type='const xmlChar *' info='the UTF8 character to be found '/>
    </function>
    <function name='xmlUTF8Strndup' file='encoding'>
      <info>a strndup for array of UTF8&apos;s</info>
      <return type='xmlChar *' info='a new UTF8 * or NULL '/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 * '/>
      <arg name='len' type='int' info='utf (in chars) '/>
    </function>
    <function name='xmlUTF8Strpos' file='encoding'>
      <info>a function to provide the equivalent of fetching a character from a string array</info>
      <return type='xmlChar *' info='a pointer to the UTF8 character or NULL '/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 * '/>
      <arg name='pos' type='int' info='the position of the desired UTF8 char (in chars) '/>
    </function>
    <function name='xmlUTF8Strsize' file='encoding'>
      <info>storage size of an UTF8 string</info>
      <return type='int' info='the storage size of the first &apos;len&apos; characters of ARRAY '/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes '/>
      <arg name='len' type='int' info='the number of characters in the array '/>
    </function>
    <function name='xmlUTF8Strsub' file='encoding'>
      <info>Note: positions are given in units of UTF-8 chars</info>
      <return type='xmlChar *' info='a pointer to a newly created string or NULL if any problem '/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes '/>
      <arg name='start' type='int' info='relative pos of first char '/>
      <arg name='len' type='int' info='total number to copy '/>
    </function>
    <function name='xmlUnlinkNode' file='tree'>
      <info>Unlink a node from it&apos;s current context, the node is not freed</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node '/>
    </function>
    <function name='xmlUnlockLibrary' file='threads'>
      <info>xmlUnlockLibrary() is used to release a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlUnsetNsProp' file='tree'>
      <info>Remove an attribute carried by a node.</info>
      <return type='int' info='0 if successful, -1 if not found '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='ns' type='xmlNsPtr' info='the namespace definition '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
    </function>
    <function name='xmlUnsetProp' file='tree'>
      <info>Remove an attribute carried by a node.</info>
      <return type='int' info='0 if successful, -1 if not found '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
    </function>
    <function name='xmlValidBuildContentModel' file='valid'>
      <info>(Re)Build the automata associated to the content model of this element</info>
      <return type='int' info='1 in case of success, 0 in case of error '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='a validation context '/>
      <arg name='elem' type='xmlElementPtr' info='an element declaration node '/>
    </function>
    <struct name='xmlValidCtxt' file='valid'/>
    <function name='xmlValidCtxtNormalizeAttributeValue' file='valid'>
      <info>Does the validation related extra step of the normalization of attribute values: </info>
      <return type='xmlChar *' info='a new normalized string if normalization is needed, NULL otherwise the caller must free the returned value. '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='elem' type='xmlNodePtr' info='the parent '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='value' type='const xmlChar *' info='the attribute value '/>
    </function>
    <typedef name='xmlValidCtxtPtr' file='valid'/>
    <function name='xmlValidGetPotentialChildren' file='valid'>
      <info>Build/extend a list of potential children allowed by the content tree</info>
      <return type='int' info='the number of element in the list, or -1 in case of error. '/>
      <arg name='ctree' type='xmlElementContent *' info='an element content tree '/>
      <arg name='list' type='const xmlChar **' info='an array to store the list of child names '/>
      <arg name='len' type='int *' info='a pointer to the number of element in the list '/>
      <arg name='max' type='int' info='the size of the array '/>
    </function>
    <function name='xmlValidGetValidElements' file='valid'>
      <info>This function returns the list of authorized children to insert within an existing tree while respecting the validity constraints forced by the Dtd. The insertion point is defined using prev and next in the following ways: to insert before &apos;node&apos;: xmlValidGetValidElements(node-&gt;prev, node, ... to insert next &apos;node&apos;: xmlValidGetValidElements(node, node-&gt;next, ... to replace &apos;node&apos;: xmlValidGetValidElements(node-&gt;prev, node-&gt;next, ... to prepend a child to &apos;node&apos;: xmlValidGetValidElements(NULL, node-&gt;childs, to append a child to &apos;node&apos;: xmlValidGetValidElements(node-&gt;last, NULL, ... </info>
      <return type='int' info='max the caller is invited to grow the receiving array and retry. '/>
      <arg name='prev' type='xmlNode *' info='an element to insert after '/>
      <arg name='next' type='xmlNode *' info='an element to insert next '/>
      <arg name='list' type='const xmlChar **' info='an array to store the list of child names '/>
      <arg name='max' type='int' info='the size of the array '/>
    </function>
    <function name='xmlValidNormalizeAttributeValue' file='valid'>
      <info>Does the validation related extra step of the normalization of attribute values: </info>
      <return type='xmlChar *' info='a new normalized string if normalization is needed, NULL otherwise the caller must free the returned value. '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='elem' type='xmlNodePtr' info='the parent '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='value' type='const xmlChar *' info='the attribute value '/>
    </function>
    <struct name='xmlValidState' file='valid'/>
    <typedef name='xmlValidStatePtr' file='valid'/>
    <function name='xmlValidateAttributeDecl' file='valid'>
      <info>Try to validate a single attribute definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Default Legal ] - [ VC: Enumeration ] - [ VC: ID Attribute Default ] </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='attr' type='xmlAttributePtr' info='an attribute definition '/>
    </function>
    <function name='xmlValidateAttributeValue' file='valid'>
      <info>Validate that the given attribute value match the proper production </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='type' type='xmlAttributeType' info='an attribute type '/>
      <arg name='value' type='const xmlChar *' info='an attribute value '/>
    </function>
    <function name='xmlValidateDocument' file='valid'>
      <info>Try to validate the document instance </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
    </function>
    <function name='xmlValidateDocumentFinal' file='valid'>
      <info>Does the final step for the document validation once all the incremental validation steps have been completed </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
    </function>
    <function name='xmlValidateDtd' file='valid'>
      <info>Try to validate the document against the dtd instance </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='dtd' type='xmlDtdPtr' info='a dtd instance '/>
    </function>
    <function name='xmlValidateDtdFinal' file='valid'>
      <info>Does the final step for the dtds validation once all the subsets have been parsed </info>
      <return type='int' info='1 if valid or 0 if invalid and -1 if not well-formed '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
    </function>
    <function name='xmlValidateElement' file='valid'>
      <info>Try to validate the subtree under an element</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='elem' type='xmlNodePtr' info='an element instance '/>
    </function>
    <function name='xmlValidateElementDecl' file='valid'>
      <info>Try to validate a single element definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: One ID per Element Type ] - [ VC: No Duplicate Types ] - [ VC: Unique Element Type Declaration ]</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='elem' type='xmlElementPtr' info='an element definition '/>
    </function>
    <function name='xmlValidateNameValue' file='valid'>
      <info>Validate that the given value match Name production</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='value' type='const xmlChar *' info='an Name value '/>
    </function>
    <function name='xmlValidateNamesValue' file='valid'>
      <info>Validate that the given value match Names production</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='value' type='const xmlChar *' info='an Names value '/>
    </function>
    <function name='xmlValidateNmtokenValue' file='valid'>
      <info>Validate that the given value match Nmtoken production </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='value' type='const xmlChar *' info='an Nmtoken value '/>
    </function>
    <function name='xmlValidateNmtokensValue' file='valid'>
      <info>Validate that the given value match Nmtokens production </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='value' type='const xmlChar *' info='an Nmtokens value '/>
    </function>
    <function name='xmlValidateNotationDecl' file='valid'>
      <info>Try to validate a single notation definition basically it does the following checks as described by the XML-1.0 recommendation: - it seems that no validity constraint exists on notation declarations But this function get called anyway ...</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='nota' type='xmlNotationPtr' info='a notation definition '/>
    </function>
    <function name='xmlValidateNotationUse' file='valid'>
      <info>Validate that the given name match a notation declaration. - [ VC: Notation Declared ]</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='the document '/>
      <arg name='notationName' type='const xmlChar *' info='the notation name to check '/>
    </function>
    <function name='xmlValidateOneAttribute' file='valid'>
      <info>Try to validate a single attribute for an element basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Value Type ] - [ VC: Fixed Attribute Default ] - [ VC: Entity Name ] - [ VC: Name Token ] - [ VC: ID ] - [ VC: IDREF ] - [ VC: Entity Name ] - [ VC: Notation Attributes ] </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='elem' type='xmlNodePtr' info='an element instance '/>
      <arg name='attr' type='xmlAttrPtr' info='an attribute instance '/>
      <arg name='value' type='const xmlChar *' info='the attribute value (without entities processing) '/>
    </function>
    <function name='xmlValidateOneElement' file='valid'>
      <info>Try to validate a single element and it&apos;s attributes, basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Element Valid ] - [ VC: Required Attribute ] Then call xmlValidateOneAttribute() for each attribute present. </info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
      <arg name='elem' type='xmlNodePtr' info='an element instance '/>
    </function>
    <function name='xmlValidateOneNamespace' file='valid'>
      <return type='int'/>
      <arg name='ctxt' type='xmlValidCtxtPtr'/>
      <arg name='doc' type='xmlDocPtr'/>
      <arg name='elem' type='xmlNodePtr'/>
      <arg name='prefix' type='const xmlChar *'/>
      <arg name='ns' type='xmlNsPtr'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xmlValidateRoot' file='valid'>
      <info>Try to validate a the root element basically it does the following check as described by the XML-1.0 recommendation: - [ VC: Root Element Type ] it doesn&apos;t try to recurse or apply other check to the element</info>
      <return type='int' info='1 if valid or 0 otherwise '/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context '/>
      <arg name='doc' type='xmlDocPtr' info='a document instance '/>
    </function>
    <functype name='xmlValidityErrorFunc' file='valid'>
      <info>Callback called when a validity error is found. This is a message oriented function similar to an *printf function.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an xmlValidCtxtPtr validity error context '/>
      <arg name='msg' type='const char *' info='the string to format *printf like vararg '/>
      <arg name='' type='...'/>
    </functype>
    <functype name='xmlValidityWarningFunc' file='valid'>
      <info>Callback called when a validity warning is found. This is a message oriented function similar to an *printf function.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an xmlValidCtxtPtr validity error context '/>
      <arg name='msg' type='const char *' info='the string to format *printf like vararg '/>
      <arg name='' type='...'/>
    </functype>
    <function name='xmlXIncludeProcess' file='xinclude'>
      <info>Implement the XInclude substitution on the XML document doc</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done. '/>
      <arg name='doc' type='xmlDocPtr' info='an XML document '/>
    </function>
    <function name='xmlXPathAddValues' file='xpathInternals'>
      <info>Implement the add operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <struct name='xmlXPathAxis' file='xpath'/>
    <functype name='xmlXPathAxisFunc' file='xpath'>
      <info>An axis traversal function. To traverse an axis, the engine calls the first time with cur == NULL and repeat until the function returns NULL indicating the end of the axis traversal.</info>
      <return type='xmlXPathObjectPtr' info='the next node in that axis or NULL if at the end of the axis. '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath interpreter context '/>
      <arg name='cur' type='xmlXPathObjectPtr' info='the previous node being explored on that axis '/>
    </functype>
    <typedef name='xmlXPathAxisPtr' file='xpath'/>
    <function name='xmlXPathBooleanFunction' file='xpathInternals'>
      <info>Implement the boolean() XPath function boolean boolean(object) he boolean function converts its argument to a boolean as follows: - a number is true if and only if it is neither positive or negative zero nor NaN - a node-set is true if and only if it is non-empty - a string is true if and only if its length is non-zero</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathCastBooleanToNumber' file='xpath'>
      <info>Converts a boolean to its number value</info>
      <return type='double' info='the number value '/>
      <arg name='val' type='int' info='a boolean '/>
    </function>
    <function name='xmlXPathCastBooleanToString' file='xpath'>
      <info>Converts a boolean to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string. '/>
      <arg name='val' type='int' info='a boolean '/>
    </function>
    <function name='xmlXPathCastNodeSetToBoolean' file='xpath'>
      <info>Converts a node-set to its boolean value</info>
      <return type='int' info='the boolean value '/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathCastNodeSetToNumber' file='xpath'>
      <info>Converts a node-set to its number value</info>
      <return type='double' info='the number value '/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathCastNodeSetToString' file='xpath'>
      <info>Converts a node-set to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string. '/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathCastNodeToNumber' file='xpath'>
      <info>Converts a node to its number value</info>
      <return type='double' info='the number value '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathCastNodeToString' file='xpath'>
      <info>Converts a node to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string. '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathCastNumberToBoolean' file='xpath'>
      <info>Converts a number to its boolean value</info>
      <return type='int' info='the boolean value '/>
      <arg name='val' type='double' info='a number '/>
    </function>
    <function name='xmlXPathCastNumberToString' file='xpath'>
      <info>Converts a number to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string. '/>
      <arg name='val' type='double' info='a number '/>
    </function>
    <function name='xmlXPathCastStringToBoolean' file='xpath'>
      <info>Converts a string to its boolean value</info>
      <return type='int' info='the boolean value '/>
      <arg name='val' type='const xmlChar *' info='a string '/>
    </function>
    <function name='xmlXPathCastStringToNumber' file='xpath'>
      <info>Converts a string to its number value</info>
      <return type='double' info='the number value '/>
      <arg name='val' type='const xmlChar *' info='a string '/>
    </function>
    <function name='xmlXPathCastToBoolean' file='xpath'>
      <info>Converts an XPath object to its boolean value</info>
      <return type='int' info='the boolean value '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <function name='xmlXPathCastToNumber' file='xpath'>
      <info>Converts an XPath object to its number value</info>
      <return type='double' info='the number value '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <function name='xmlXPathCastToString' file='xpath'>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlChar *' info='val isn&apos;t a string object). '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <function name='xmlXPathCeilingFunction' file='xpathInternals'>
      <info>Implement the ceiling() XPath function number ceiling(number) The ceiling function returns the smallest (closest to negative infinity) number that is not less than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <macro name='xmlXPathCheckError' file='xpathInternals'>
      <info>Check if an XPath error was raised.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <function name='xmlXPathCmpNodes' file='xpath'>
      <info>Compare two nodes w.r.t document order</info>
      <return type='int' info='-2 in case of error 1 if first point &lt; second point, 0 if that&apos;s the same node, -1 otherwise '/>
      <arg name='node1' type='xmlNodePtr' info='the first node '/>
      <arg name='node2' type='xmlNodePtr' info='the second node '/>
    </function>
    <struct name='xmlXPathCompExpr' file='xpath' info='[14] Expr ::= OrExpr [21] OrExpr ::= AndExpr | OrExpr &apos;or&apos; AndExpr '/>
    <typedef name='xmlXPathCompExprPtr' file='xpath'/>
    <function name='xmlXPathCompareValues' file='xpathInternals'>
      <info>Implement the compare operation on XPath objects: arg1 &lt; arg2 (1, 1, ... arg1 &lt;= arg2 (1, 0, ... arg1 &gt; arg2 (0, 1, ... arg1 &gt;= arg2 (0, 0, ... </info>
      <return type='int' info='1 if the comparison succeeded, 0 if it failed '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='inf' type='int' info='less than (1) or greater than (0) '/>
      <arg name='strict' type='int' info='is the comparison strict '/>
    </function>
    <function name='xmlXPathCompile' file='xpath'>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object. '/>
      <arg name='str' type='const xmlChar *' info='the XPath expression '/>
    </function>
    <function name='xmlXPathCompiledEval' file='xpath'>
      <info>Evaluate the Precompiled XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object. '/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression '/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathConcatFunction' file='xpathInternals'>
      <info>Implement the concat() XPath function string concat(string, string, string*) The concat function returns the concatenation of its arguments.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathContainsFunction' file='xpathInternals'>
      <info>Implement the contains() XPath function boolean contains(string, string) The contains function returns true if the first argument string contains the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <struct name='xmlXPathContext' file='xpath' info='Expression evaluation occurs with respect to a context. he context consists of: - a node (the context node) - a node list (the context node list) - a set of variable bindings - a function library - the set of namespace declarations in scope for the expression Following the switch to hash tables, this need to be trimmed up at the next binary incompatible release.'/>
    <typedef name='xmlXPathContextPtr' file='xpath'/>
    <function name='xmlXPathConvertBoolean' file='xpath'>
      <info>Converts an existing object to its boolean() equivalent</info>
      <return type='xmlXPathObjectPtr' info='val) '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <functype name='xmlXPathConvertFunc' file='xpath'>
      <info>A conversion function is associated to a type and used to cast the new type to primitive values.</info>
      <return type='int' info='-1 in case of error, 0 otherwise '/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an XPath object '/>
      <arg name='type' type='int' info='the number of the target type '/>
    </functype>
    <function name='xmlXPathConvertNumber' file='xpath'>
      <info>Converts an existing object to its number() equivalent</info>
      <return type='xmlXPathObjectPtr' info='val) '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <function name='xmlXPathConvertString' file='xpath'>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlXPathObjectPtr' info='val) '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object '/>
    </function>
    <function name='xmlXPathCountFunction' file='xpathInternals'>
      <info>Implement the count() XPath function number count(node-set)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathDebugDumpCompExpr' file='xpathInternals'>
      <info>Dumps the tree of the compiled XPath expression.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output '/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the precompiled XPath expression '/>
      <arg name='depth' type='int' info='the indentation level. '/>
    </function>
    <function name='xmlXPathDebugDumpObject' file='xpathInternals'>
      <info>Dump the content of the object for debugging purposes</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * to dump the output '/>
      <arg name='cur' type='xmlXPathObjectPtr' info='the object to inspect '/>
      <arg name='depth' type='int' info='indentation level '/>
    </function>
    <function name='xmlXPathDifference' file='xpathInternals'>
      <info>Implements the EXSLT - Sets difference() function: node-set set:difference (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the difference between the two node sets, or nodes1 if nodes2 is empty '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathDistinct' file='xpathInternals'>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set) nodes is sorted by document order, then exslSetsDistinctSorted is called with the sorted node-set</info>
      <return type='xmlNodeSetPtr' info='nodes if it is empty '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathDistinctSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set)</info>
      <return type='xmlNodeSetPtr' info='nodes if it is empty '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
    </function>
    <function name='xmlXPathDivValues' file='xpathInternals'>
      <info>Implement the div operation on XPath objects arg1 / arg2: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <macro name='xmlXPathEmptyNodeSet' file='xpathInternals'>
      <info>Empties a node-set.</info>
      <arg name='ns' info='a node-set '/>
    </macro>
    <function name='xmlXPathEqualValues' file='xpathInternals'>
      <info>Implement the equal operation on XPath objects content: arg1 == arg2</info>
      <return type='int' info='0 or 1 depending on the results of the test. '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <enum name='xmlXPathError' file='xpath'/>
    <function name='xmlXPathEval' file='xpath'>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object. '/>
      <arg name='str' type='const xmlChar *' info='the XPath expression '/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathEvalExpr' file='xpathInternals'>
      <info>Parse and evaluate an XPath expression in the given context, then push the result on the context stack</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathEvalExpression' file='xpath'>
      <info>Evaluate the XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object. '/>
      <arg name='str' type='const xmlChar *' info='the XPath expression '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <functype name='xmlXPathEvalFunc' file='xpath'>
      <info>An XPath evaluation function, the parameters are on the XPath context stack.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
      <arg name='nargs' type='int' info='the number of arguments passed to the function '/>
    </functype>
    <function name='xmlXPathEvalPredicate' file='xpath'>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int' info='1 if predicate is true, 0 otherwise '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='res' type='xmlXPathObjectPtr' info='the Predicate Expression evaluation result '/>
    </function>
    <function name='xmlXPathEvaluatePredicateResult' file='xpathInternals'>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int' info='1 if predicate is true, 0 otherwise '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='res' type='xmlXPathObjectPtr' info='the Predicate Expression evaluation result '/>
    </function>
    <function name='xmlXPathFalseFunction' file='xpathInternals'>
      <info>Implement the false() XPath function boolean false()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathFloorFunction' file='xpathInternals'>
      <info>Implement the floor() XPath function number floor(number) The floor function returns the largest (closest to positive infinity) number that is not greater than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathFreeCompExpr' file='xpath'>
      <info>Free up the memory allocated by comp</info>
      <return type='void'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='an XPATH comp '/>
    </function>
    <function name='xmlXPathFreeContext' file='xpath'>
      <info>Free up an xmlXPathContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the context to free '/>
    </function>
    <function name='xmlXPathFreeNodeSet' file='xpath'>
      <info>Free the NodeSet compound (not the actual nodes !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlNodeSetPtr' info='the xmlNodeSetPtr to free '/>
    </function>
    <function name='xmlXPathFreeNodeSetList' file='xpath'>
      <info>Free up the xmlXPathObjectPtr obj but don&apos;t deallocate the objects in the list contrary to xmlXPathFreeObject().</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an existing NodeSetList object '/>
    </function>
    <function name='xmlXPathFreeObject' file='xpath'>
      <info>Free up an xmlXPathObjectPtr object.</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='the object to free '/>
    </function>
    <function name='xmlXPathFreeParserContext' file='xpathInternals'>
      <info>Free up an xmlXPathParserContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the context to free '/>
    </function>
    <functype name='xmlXPathFuncLookupFunc' file='xpathInternals'>
      <info>Prototype for callbacks used to plug function lookup in the XPath engine.</info>
      <return type='xmlXPathFunction' info='the XPath function or NULL if not found. '/>
      <arg name='ctxt' type='void *' info='an XPath context '/>
      <arg name='name' type='const xmlChar *' info='name of the function '/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name hosting this function '/>
    </functype>
    <typedef name='xmlXPathFuncPtr' file='xpath'/>
    <struct name='xmlXPathFunct' file='xpath'/>
    <functype name='xmlXPathFunction' file='xpath'>
      <info>An XPath function. The arguments (if any) are popped out from the context stack and the result is pushed on the stack.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath interprestation context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </functype>
    <function name='xmlXPathFunctionLookup' file='xpathInternals'>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction' info='the xmlXPathFunction or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
    </function>
    <function name='xmlXPathFunctionLookupNS' file='xpathInternals'>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction' info='the xmlXPathFunction or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI '/>
    </function>
    <macro name='xmlXPathGetContextNode' file='xpathInternals'>
      <info>Get the context node of an XPath context.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathGetDocument' file='xpathInternals'>
      <info>Get the document of an XPath context.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathGetError' file='xpathInternals'>
      <info>Get the error code of an XPath context.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <function name='xmlXPathHasSameNodes' file='xpathInternals'>
      <info>Implements the EXSLT - Sets has-same-nodes function: boolean set:has-same-node(node-set, node-set)</info>
      <return type='int' info='nodes2, false (0) otherwise '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathIdFunction' file='xpathInternals'>
      <info>Implement the id() XPath function node-set id(object) The id function selects elements by their unique ID (see [5.2.1 Unique IDs]). When the argument to id is of type node-set, then the result is the union of the result of applying id to the string value of each of the nodes in the argument node-set. When the argument to id is of any other type, the argument is converted to a string as if by a call to the string function; the string is split into a whitespace-separated list of tokens (whitespace is any sequence of characters matching the production S); the result is a node-set containing the elements in the same document as the context node that have a unique ID equal to any of the tokens in the list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathInit' file='xpath'>
      <info>Initialize the XPath environment</info>
      <return type='void'/>
    </function>
    <function name='xmlXPathIntersection' file='xpathInternals'>
      <info>Implements the EXSLT - Sets intersection() function: node-set set:intersection (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='a node set comprising the nodes that are within both the node sets passed as arguments '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathIsInf' file='xpath'>
      <info>Provides a portable isinf() function to detect whether a double is a +Infinite or -Infinite. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int' info='1 vi the value is +Infinite, -1 if -Infinite, 0 otherwise '/>
      <arg name='val' type='double' info='a double value '/>
    </function>
    <function name='xmlXPathIsNaN' file='xpath'>
      <info>Provides a portable isnan() function to detect whether a double is a NotaNumber. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int' info='1 if the value is a NaN, 0 otherwise '/>
      <arg name='val' type='double' info='a double value '/>
    </function>
    <function name='xmlXPathIsNodeType' file='xpathInternals'>
      <info>Is the name given a NodeType one. </info>
      <return type='int' info='1 if true 0 otherwise '/>
      <arg name='name' type='const xmlChar *' info='a name string '/>
    </function>
    <function name='xmlXPathLangFunction' file='xpathInternals'>
      <info>Implement the lang() XPath function boolean lang(string) The lang function returns true or false depending on whether the language of the context node as specified by xml:lang attributes is the same as or is a sublanguage of the language specified by the argument string. The language of the context node is determined by the value of the xml:lang attribute on the context node, or, if the context node has no xml:lang attribute, by the value of the xml:lang attribute on the nearest ancestor of the context node that has an xml:lang attribute. If there is no such attribute, then lang</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathLastFunction' file='xpathInternals'>
      <info>Implement the last() XPath function number last() The last function returns the number of nodes in the context node list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathLeading' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) nodes1 and nodes2 are sorted by document order, then exslSetsLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='nodes2 '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathLeadingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='nodes2 '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
    </function>
    <function name='xmlXPathLocalNameFunction' file='xpathInternals'>
      <info>Implement the local-name() XPath function string local-name(node-set?) The local-name function returns a string containing the local part of the name of the node in the argument node-set that is first in document order. If the node-set is empty or the first node has no name, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathModValues' file='xpathInternals'>
      <info>Implement the mod operation on XPath objects: arg1 / arg2 The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathMultValues' file='xpathInternals'>
      <info>Implement the multiply operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathNamespaceURIFunction' file='xpathInternals'>
      <info>Implement the namespace-uri() XPath function string namespace-uri(node-set?) The namespace-uri function returns a string containing the namespace URI of the expanded name of the node in the argument node-set that is first in document order. If the node-set is empty, the first node has no name, or the expanded name has no namespace URI, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathNewBoolean' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type boolean and of value val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='int' info='the boolean value '/>
    </function>
    <function name='xmlXPathNewCString' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type string and of value val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='const char *' info='the char * value '/>
    </function>
    <function name='xmlXPathNewContext' file='xpath'>
      <info>Create a new xmlXPathContext</info>
      <return type='xmlXPathContextPtr' info='the xmlXPathContext just allocated. The caller will need to free it. '/>
      <arg name='doc' type='xmlDocPtr' info='the XML document '/>
    </function>
    <function name='xmlXPathNewFloat' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type double and of value val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='double' info='the double value '/>
    </function>
    <function name='xmlXPathNewNodeSet' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the single Node val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlNodePtr' info='the NodePtr value '/>
    </function>
    <function name='xmlXPathNewNodeSetList' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the Nodeset val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlNodeSetPtr' info='an existing NodeSet '/>
    </function>
    <function name='xmlXPathNewParserContext' file='xpathInternals'>
      <info>Create a new xmlXPathParserContext</info>
      <return type='xmlXPathParserContextPtr' info='the xmlXPathParserContext just allocated. '/>
      <arg name='str' type='const xmlChar *' info='the XPath expression '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathNewString' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type string and of value val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='const xmlChar *' info='the xmlChar * value '/>
    </function>
    <function name='xmlXPathNewValueTree' file='xpathInternals'>
      <info>Create a new xmlXPathObjectPtr of type Value Tree (XSLT) and initialize it with the tree root val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlNodePtr' info='the NodePtr value '/>
    </function>
    <function name='xmlXPathNextAncestor' file='xpathInternals'>
      <info>Traversal function for the &quot;ancestor&quot; direction the ancestor axis contains the ancestors of the context node; the ancestors of the context node consist of the parent of context node and the parent&apos;s parent and so on; the nodes are ordered in reverse document order; thus the parent is the first node on the axis, and the parent&apos;s parent is the second node on the axis</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextAncestorOrSelf' file='xpathInternals'>
      <info>Traversal function for the &quot;ancestor-or-self&quot; direction he ancestor-or-self axis contains the context node and ancestors of the context node in reverse document order; thus the context node is the first node on the axis, and the context node&apos;s parent the second; parent here is defined the same as with the parent axis.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextAttribute' file='xpathInternals'>
      <info>Traversal function for the &quot;attribute&quot; direction TODO: support DTD inherited default attributes</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current attribute in the traversal '/>
    </function>
    <function name='xmlXPathNextChild' file='xpathInternals'>
      <info>Traversal function for the &quot;child&quot; direction The child axis contains the children of the context node in document order.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextDescendant' file='xpathInternals'>
      <info>Traversal function for the &quot;descendant&quot; direction the descendant axis contains the descendants of the context node in document order; a descendant is a child or a child of a child and so on.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextDescendantOrSelf' file='xpathInternals'>
      <info>Traversal function for the &quot;descendant-or-self&quot; direction the descendant-or-self axis contains the context node and the descendants of the context node in document order; thus the context node is the first node on the axis, and the first child of the context node is the second node on the axis</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextFollowing' file='xpathInternals'>
      <info>Traversal function for the &quot;following&quot; direction The following axis contains all nodes in the same document as the context node that are after the context node in document order, excluding any descendants and excluding attribute nodes and namespace nodes; the nodes are ordered in document order</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextFollowingSibling' file='xpathInternals'>
      <info>Traversal function for the &quot;following-sibling&quot; direction The following-sibling axis contains the following siblings of the context node in document order.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextNamespace' file='xpathInternals'>
      <info>Traversal function for the &quot;namespace&quot; direction the namespace axis contains the namespace nodes of the context node; the order of nodes on this axis is implementation-defined; the axis will be empty unless the context node is an element </info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current attribute in the traversal '/>
    </function>
    <function name='xmlXPathNextParent' file='xpathInternals'>
      <info>Traversal function for the &quot;parent&quot; direction The parent axis contains the parent of the context node, if there is one.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextPreceding' file='xpathInternals'>
      <info>Traversal function for the &quot;preceding&quot; direction the preceding axis contains all nodes in the same document as the context node that are before the context node in document order, excluding any ancestors and excluding attribute nodes and namespace nodes; the nodes are ordered in reverse document order</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextPrecedingSibling' file='xpathInternals'>
      <info>Traversal function for the &quot;preceding-sibling&quot; direction The preceding-sibling axis contains the preceding siblings of the context node in reverse document order; the first preceding sibling is first on the axis; the sibling preceding that node is the second on the axis and so on.</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNextSelf' file='xpathInternals'>
      <info>Traversal function for the &quot;self&quot; direction The self axis contains just the context node itself</info>
      <return type='xmlNodePtr' info='the next element following that axis '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal '/>
    </function>
    <function name='xmlXPathNodeLeading' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) nodes is sorted by document order, then exslSetsNodeLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='node '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathNodeLeadingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='node '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathNodeSetAdd' file='xpathInternals'>
      <info>add a new xmlNodePtr to an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set '/>
      <arg name='val' type='xmlNodePtr' info='a new xmlNodePtr '/>
    </function>
    <function name='xmlXPathNodeSetAddNs' file='xpathInternals'>
      <info>add a new namespace node to an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set '/>
      <arg name='node' type='xmlNodePtr' info='the hosting node '/>
      <arg name='ns' type='xmlNsPtr' info='a the namespace node '/>
    </function>
    <function name='xmlXPathNodeSetAddUnique' file='xpathInternals'>
      <info>add a new xmlNodePtr to an existing NodeSet, optimized version when we are sure the node is not already in the set.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set '/>
      <arg name='val' type='xmlNodePtr' info='a new xmlNodePtr '/>
    </function>
    <function name='xmlXPathNodeSetContains' file='xpathInternals'>
      <info>checks whether cur contains val</info>
      <return type='int' info='val, false (0) otherwise '/>
      <arg name='cur' type='xmlNodeSetPtr' info='the node-set '/>
      <arg name='val' type='xmlNodePtr' info='the node '/>
    </function>
    <function name='xmlXPathNodeSetCreate' file='xpath'>
      <info>Create a new xmlNodeSetPtr of type double and of value val</info>
      <return type='xmlNodeSetPtr' info='the newly created object. '/>
      <arg name='val' type='xmlNodePtr' info='an initial xmlNodePtr, or NULL '/>
    </function>
    <function name='xmlXPathNodeSetDel' file='xpathInternals'>
      <info>Removes an xmlNodePtr from an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set '/>
      <arg name='val' type='xmlNodePtr' info='an xmlNodePtr '/>
    </function>
    <function name='xmlXPathNodeSetFreeNs' file='xpathInternals'>
      <info>Namespace node in libxml don&apos;t match the XPath semantic. In a node set the namespace nodes are duplicated and the next pointer is set to the parent node in the XPath semantic. Check if such a node need to be freed</info>
      <return type='void'/>
      <arg name='ns' type='xmlNsPtr' info='the XPath namespace node found in a nodeset. '/>
    </function>
    <macro name='xmlXPathNodeSetGetLength' file='xpath'>
      <info>Implement a functionality similar to the DOM NodeList.length.</info>
      <arg name='ns' info='a node-set '/>
    </macro>
    <macro name='xmlXPathNodeSetIsEmpty' file='xpath'>
      <info>Checks whether ns is empty or not.</info>
      <arg name='ns' info='a node-set '/>
    </macro>
    <macro name='xmlXPathNodeSetItem' file='xpath'>
      <info>Implements a functionality similar to the DOM NodeList.item().</info>
      <arg name='ns' info='a node-set '/>
      <arg name='index' info='index of a node in the set '/>
    </macro>
    <function name='xmlXPathNodeSetMerge' file='xpathInternals'>
      <info>Merges two nodesets, all nodes from val2 are added to val1 if val1 is NULL, a new set is created and copied from val2</info>
      <return type='xmlNodeSetPtr' info='val1 once extended or NULL in case of error. '/>
      <arg name='val1' type='xmlNodeSetPtr' info='the first NodeSet or NULL '/>
      <arg name='val2' type='xmlNodeSetPtr' info='the second NodeSet '/>
    </function>
    <function name='xmlXPathNodeSetRemove' file='xpathInternals'>
      <info>Removes an entry from an existing NodeSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set '/>
      <arg name='val' type='int' info='the index to remove '/>
    </function>
    <function name='xmlXPathNodeSetSort' file='xpathInternals'>
      <info>Sort the node set in document order</info>
      <return type='void'/>
      <arg name='set' type='xmlNodeSetPtr' info='the node set '/>
    </function>
    <function name='xmlXPathNodeTrailing' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) nodes is sorted by document order, then xmlXPathNodeTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='node '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathNodeTrailingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='node '/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
    </function>
    <function name='xmlXPathNormalizeFunction' file='xpathInternals'>
      <info>Implement the normalize-space() XPath function string normalize-space(string?) The normalize-space function returns the argument string with white space normalized by stripping leading and trailing whitespace and replacing sequences of whitespace characters by a single space. Whitespace characters are the same allowed by the S production in XML. If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathNotEqualValues' file='xpathInternals'>
      <info>Implement the equal operation on XPath objects content: arg1 == arg2</info>
      <return type='int' info='0 or 1 depending on the results of the test. '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathNotFunction' file='xpathInternals'>
      <info>Implement the not() XPath function boolean not(boolean) The not function returns true if its argument is false, and false otherwise.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathNsLookup' file='xpathInternals'>
      <info>Search in the namespace declaration array of the context for the given namespace name associated to the given prefix</info>
      <return type='const xmlChar *' info='the value or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix value '/>
    </function>
    <function name='xmlXPathNumberFunction' file='xpathInternals'>
      <info>Implement the number() XPath function number number(object?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <struct name='xmlXPathObject' file='xpath'/>
    <function name='xmlXPathObjectCopy' file='xpath'>
      <info>allocate a new copy of a given object</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlXPathObjectPtr' info='the original object '/>
    </function>
    <typedef name='xmlXPathObjectPtr' file='xpath'/>
    <enum name='xmlXPathObjectType' file='xpath'/>
    <function name='xmlXPathParseNCName' file='xpathInternals'>
      <info>parse an XML namespace non qualified name. </info>
      <return type='xmlChar *' info='the namespace name or NULL '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathParseName' file='xpathInternals'>
      <info>parse an XML name </info>
      <return type='xmlChar *' info='the namespace name or NULL '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <struct name='xmlXPathParserContext' file='xpath' info='An XPath parser context. It contains pure parsing informations, an xmlXPathContext, and the stack of objects.'/>
    <typedef name='xmlXPathParserContextPtr' file='xpath'/>
    <function name='xmlXPathPopBoolean' file='xpathInternals'>
      <info>Pops a boolean from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='int' info='the boolean '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
    </function>
    <function name='xmlXPathPopExternal' file='xpathInternals'>
      <info>Pops an external object from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='void *'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
    </function>
    <function name='xmlXPathPopNodeSet' file='xpathInternals'>
      <info>Pops a node-set from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='xmlNodeSetPtr' info='the node-set '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
    </function>
    <function name='xmlXPathPopNumber' file='xpathInternals'>
      <info>Pops a number from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='double' info='the number '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
    </function>
    <function name='xmlXPathPopString' file='xpathInternals'>
      <info>Pops a string from the stack, handling conversion if needed. Check error with xmlXPathCheckError.</info>
      <return type='xmlChar *' info='the string '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context '/>
    </function>
    <function name='xmlXPathPositionFunction' file='xpathInternals'>
      <info>Implement the position() XPath function number position() The position function returns the position of the context node in the context node list. The first position is 1, and so the last position will be equal to last().</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathRegisterAllFunctions' file='xpathInternals'>
      <info>Registers all default XPath functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathRegisterFunc' file='xpathInternals'>
      <info>Register a new function. If f is NULL it unregisters the function</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='f' type='xmlXPathFunction' info='the function implementation or NULL '/>
    </function>
    <function name='xmlXPathRegisterFuncLookup' file='xpathInternals'>
      <info>Registers an external mechanism to do function lookup.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='f' type='xmlXPathFuncLookupFunc' info='the lookup function '/>
      <arg name='funcCtxt' type='void *' info='the lookup data '/>
    </function>
    <function name='xmlXPathRegisterFuncNS' file='xpathInternals'>
      <info>Register a new function. If f is NULL it unregisters the function</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI '/>
      <arg name='f' type='xmlXPathFunction' info='the function implementation or NULL '/>
    </function>
    <function name='xmlXPathRegisterNs' file='xpathInternals'>
      <info>Register a new namespace. If ns_uri is NULL it unregisters the namespace</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix '/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name '/>
    </function>
    <function name='xmlXPathRegisterVariable' file='xpathInternals'>
      <info>Register a new variable value. If value is NULL it unregisters the variable</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
      <arg name='value' type='xmlXPathObjectPtr' info='the variable value or NULL '/>
    </function>
    <function name='xmlXPathRegisterVariableLookup' file='xpathInternals'>
      <info>register an external mechanism to do variable lookup</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='f' type='xmlXPathVariableLookupFunc' info='the lookup function '/>
      <arg name='data' type='void *' info='the lookup data '/>
    </function>
    <function name='xmlXPathRegisterVariableNS' file='xpathInternals'>
      <info>Register a new variable value. If value is NULL it unregisters the variable</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI '/>
      <arg name='value' type='xmlXPathObjectPtr' info='the variable value or NULL '/>
    </function>
    <function name='xmlXPathRegisteredFuncsCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered functions</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathRegisteredNsCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xmlXPathRegisteredVariablesCleanup' file='xpathInternals'>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <macro name='xmlXPathReturnBoolean' file='xpathInternals'>
      <info>Pushes the boolean val on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='val' info='a boolean '/>
    </macro>
    <macro name='xmlXPathReturnEmptyNodeSet' file='xpathInternals'>
      <info>Pushes an empty node-set on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathReturnEmptyString' file='xpathInternals'>
      <info>Pushes an empty string on the stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathReturnExternal' file='xpathInternals'>
      <info>Pushes user data on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='val' info='user data '/>
    </macro>
    <macro name='xmlXPathReturnFalse' file='xpathInternals'>
      <info>Pushes false on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathReturnNodeSet' file='xpathInternals'>
      <info>Pushes the node-set ns on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='ns' info='a node-set '/>
    </macro>
    <macro name='xmlXPathReturnNumber' file='xpathInternals'>
      <info>Pushes the double val on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='val' info='a double '/>
    </macro>
    <macro name='xmlXPathReturnString' file='xpathInternals'>
      <info>Pushes the string str on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='str' info='a string '/>
    </macro>
    <macro name='xmlXPathReturnTrue' file='xpathInternals'>
      <info>Pushes true on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <function name='xmlXPathRoot' file='xpathInternals'>
      <info>Initialize the context to the root of the document</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathRoundFunction' file='xpathInternals'>
      <info>Implement the round() XPath function number round(number) The round function returns the number that is closest to the argument and that is an integer. If there are two such numbers, then the one that is even is returned.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <macro name='xmlXPathSetArityError' file='xpathInternals'>
      <info>Raises an XPATH_INVALID_ARITY error.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathSetError' file='xpathInternals'>
      <info>Raises an error.</info>
      <arg name='ctxt' info='an XPath parser context '/>
      <arg name='err' info='an xmlXPathError code '/>
    </macro>
    <macro name='xmlXPathSetTypeError' file='xpathInternals'>
      <info>Raises an XPATH_INVALID_TYPE error.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathStackIsExternal' file='xpathInternals'>
      <info>Checks if the current value on the XPath stack is an external object.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <macro name='xmlXPathStackIsNodeSet' file='xpathInternals'>
      <info>Check if the current value on the XPath stack is a node set or an XSLT value tree.</info>
      <arg name='ctxt' info='an XPath parser context '/>
    </macro>
    <function name='xmlXPathStartsWithFunction' file='xpathInternals'>
      <info>Implement the starts-with() XPath function boolean starts-with(string, string) The starts-with function returns true if the first argument string starts with the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathStringEvalNumber' file='xpathInternals'>
      <info>[30a] Float ::= Number (&apos;e&apos; Digits?)? </info>
      <return type='double' info='the double value. '/>
      <arg name='str' type='const xmlChar *' info='A string to scan '/>
    </function>
    <function name='xmlXPathStringFunction' file='xpathInternals'>
      <info>Implement the string() XPath function string string(object?) he string function converts an object to a string as follows: - A node-set is converted to a string by returning the value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned. - A number is converted to a string as follows + NaN is converted to the string NaN + positive zero is converted to the string 0 + negative zero is converted to the string 0 + positive infinity is converted to the string Infinity + negative infinity is converted to the string -Infinity + if the number is an integer, the number is represented in decimal form as a Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is negative + otherwise, the number is represented in decimal form as a Number including a decimal point with at least one digit before the decimal point and at least one digit after the decimal point, preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the decimal point apart possibly from the one required digit immediately before the decimal point; beyond the one required digit after the decimal point there must be as many, but only as many, more digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. - The boolean false value is converted to the string false. The boolean true value is converted to the string true. </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathStringLengthFunction' file='xpathInternals'>
      <info>Implement the string-length() XPath function number string-length(string?) The string-length returns the number of characters in the string (see [3.6 Strings]). If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathSubValues' file='xpathInternals'>
      <info>Implement the subtraction operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <function name='xmlXPathSubstringAfterFunction' file='xpathInternals'>
      <info>Implement the substring-after() XPath function string substring-after(string, string) The substring-after function returns the substring of the first argument string that follows the first occurrence of the second argument string in the first argument string, or the empty stringi if the first argument string does not contain the second argument string. For example, substring-after(&quot;1999/04/01&quot;,&quot;/&quot;) returns 04/01, and substring-after(&quot;1999/04/01&quot;,&quot;19&quot;) returns 99/04/01.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathSubstringBeforeFunction' file='xpathInternals'>
      <info>Implement the substring-before() XPath function string substring-before(string, string) The substring-before function returns the substring of the first argument string that precedes the first occurrence of the second argument string in the first argument string, or the empty string if the first argument string does not contain the second argument string. For example, substring-before(&quot;1999/04/01&quot;,&quot;/&quot;) returns 1999.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathSubstringFunction' file='xpathInternals'>
      <info>Implement the substring() XPath function string substring(string, number, number?) The substring function returns the substring of the first argument starting at the position specified in the second argument with length specified in the third argument. For example, substring(&quot;12345&quot;,2,3) returns &quot;234&quot;. If the third argument is not specified, it returns the substring starting at the position specified in the second argument and continuing to the end of the string. For example, substring(&quot;12345&quot;,2) returns &quot;2345&quot;. More precisely, each character in the string (see [3.6 Strings]) is considered to have a numeric position: the position of the first character is 1, the position of the second character is 2 and so on. The returned substring contains those characters for which the position of the character is greater than or equal to the second argument and, if the third argument is specified, less than the sum of the second and third arguments; the comparisons and addition used for the above follow the standard IEEE 754 rules. Thus: - substring(&quot;12345&quot;, 1.5, 2.6) returns &quot;234&quot; - substring(&quot;12345&quot;, 0, 3) returns &quot;12&quot; - substring(&quot;12345&quot;, 0 div 0, 3) returns &quot;&quot; - substring(&quot;12345&quot;, 1, 0 div 0) returns &quot;&quot; - substring(&quot;12345&quot;, -42, 1 div 0) returns &quot;12345&quot; - substring(&quot;12345&quot;, -1 div 0, 1 div 0) returns &quot;&quot;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathSumFunction' file='xpathInternals'>
      <info>Implement the sum() XPath function number sum(node-set) The sum function returns the sum of the values of the nodes in the argument node-set.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathTrailing' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) nodes1 and nodes2 are sorted by document order, then xmlXPathTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='nodes2 '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set '/>
    </function>
    <function name='xmlXPathTrailingSorted' file='xpathInternals'>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='nodes2 '/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set, sorted by document order '/>
    </function>
    <function name='xmlXPathTranslateFunction' file='xpathInternals'>
      <info>Implement the translate() XPath function string translate(string, string, string) The translate function returns the first argument string with occurrences of characters in the second argument string replaced by the character at the corresponding position in the third argument string. For example, translate(&quot;bar&quot;,&quot;abc&quot;,&quot;ABC&quot;) returns the string BAr. If there is a character in the second argument string with no character at a corresponding position in the third argument string (because the second argument string is longer than the third argument string), then occurrences of that character in the first argument string are removed. For example, translate(&quot;--aaa--&quot;,&quot;abc-&quot;,&quot;ABC&quot;)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xmlXPathTrueFunction' file='xpathInternals'>
      <info>Implement the true() XPath function boolean true()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <struct name='xmlXPathType' file='xpath'/>
    <typedef name='xmlXPathTypePtr' file='xpath'/>
    <function name='xmlXPathValueFlipSign' file='xpathInternals'>
      <info>Implement the unary - operation on an XPath object The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
    </function>
    <struct name='xmlXPathVariable' file='xpath'/>
    <function name='xmlXPathVariableLookup' file='xpathInternals'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='a copy of the value or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
    </function>
    <functype name='xmlXPathVariableLookupFunc' file='xpathInternals'>
      <info>Prototype for callbacks used to plug variable lookup in the XPath engine.</info>
      <return type='xmlXPathObjectPtr' info='the XPath object value or NULL if not found. '/>
      <arg name='ctxt' type='void *' info='an XPath context '/>
      <arg name='name' type='const xmlChar *' info='name of the variable '/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name hosting this variable '/>
    </functype>
    <function name='xmlXPathVariableLookupNS' file='xpathInternals'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='the a copy of the value or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI '/>
    </function>
    <typedef name='xmlXPathVariablePtr' file='xpath'/>
    <function name='xmlXPathWrapCString' file='xpathInternals'>
      <info>Wraps a string into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='char *' info='the char * value '/>
    </function>
    <function name='xmlXPathWrapExternal' file='xpathInternals'>
      <info>Wraps the val data into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='void *' info='the user data '/>
    </function>
    <function name='xmlXPathWrapNodeSet' file='xpathInternals'>
      <info>Wrap the Nodeset val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlNodeSetPtr' info='the NodePtr value '/>
    </function>
    <function name='xmlXPathWrapString' file='xpathInternals'>
      <info>Wraps the val string into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlChar *' info='the xmlChar * value '/>
    </function>
    <function name='xmlXPatherror' file='xpathInternals'>
      <info>Formats an error message.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='file' type='const char *' info='the file name '/>
      <arg name='line' type='int' info='the line number '/>
      <arg name='no' type='int' info='the error number '/>
    </function>
    <function name='xmlXPtrBuildNodeList' file='xpointer'>
      <info>Build a node list tree copy of the XPointer result. This will drop Attributes and Namespace declarations.</info>
      <return type='xmlNodePtr' info='an xmlNodePtr list or NULL. the caller has to free the node tree. '/>
      <arg name='obj' type='xmlXPathObjectPtr' info='the XPointer result from the evaluation. '/>
    </function>
    <function name='xmlXPtrEval' file='xpointer'>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object. '/>
      <arg name='str' type='const xmlChar *' info='the XPointer expression '/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPointer context '/>
    </function>
    <function name='xmlXPtrEvalRangePredicate' file='xpointer'>
      <info>[8] Predicate ::= &apos;[&apos; PredicateExpr &apos;]&apos; [9] PredicateExpr ::= Expr </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context '/>
    </function>
    <function name='xmlXPtrFreeLocationSet' file='xpointer'>
      <info>Free the LocationSet compound (not the actual ranges !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlLocationSetPtr' info='the xmlLocationSetPtr to free '/>
    </function>
    <function name='xmlXPtrLocationSetAdd' file='xpointer'>
      <info>add a new xmlXPathObjectPtr to an existing LocationSet If the location already exist in the set val is freed.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set '/>
      <arg name='val' type='xmlXPathObjectPtr' info='a new xmlXPathObjectPtr '/>
    </function>
    <function name='xmlXPtrLocationSetCreate' file='xpointer'>
      <info>Create a new xmlLocationSetPtr of type double and of value val</info>
      <return type='xmlLocationSetPtr' info='the newly created object. '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an initial xmlXPathObjectPtr, or NULL '/>
    </function>
    <function name='xmlXPtrLocationSetDel' file='xpointer'>
      <info>Removes an xmlXPathObjectPtr from an existing LocationSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set '/>
      <arg name='val' type='xmlXPathObjectPtr' info='an xmlXPathObjectPtr '/>
    </function>
    <function name='xmlXPtrLocationSetMerge' file='xpointer'>
      <info>Merges two rangesets, all ranges from val2 are added to val1</info>
      <return type='xmlLocationSetPtr' info='val1 once extended or NULL in case of error. '/>
      <arg name='val1' type='xmlLocationSetPtr' info='the first LocationSet '/>
      <arg name='val2' type='xmlLocationSetPtr' info='the second LocationSet '/>
    </function>
    <function name='xmlXPtrLocationSetRemove' file='xpointer'>
      <info>Removes an entry from an existing LocationSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set '/>
      <arg name='val' type='int' info='the index to remove '/>
    </function>
    <function name='xmlXPtrNewCollapsedRange' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using a single nodes</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the starting and ending node '/>
    </function>
    <function name='xmlXPtrNewContext' file='xpointer'>
      <info>Create a new XPointer context</info>
      <return type='xmlXPathContextPtr' info='the xmlXPathContext just allocated. '/>
      <arg name='doc' type='xmlDocPtr' info='the XML document '/>
      <arg name='here' type='xmlNodePtr' info='the node that directly contains the XPointer being evaluated or NULL '/>
      <arg name='origin' type='xmlNodePtr' info='the element from which a user or program initiated traversal of the link, or NULL. '/>
    </function>
    <function name='xmlXPtrNewLocationSetNodeSet' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with all the nodes from set</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='set' type='xmlNodeSetPtr' info='a node set '/>
    </function>
    <function name='xmlXPtrNewLocationSetNodes' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with the single range made of the two nodes start and end</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the start NodePtr value '/>
      <arg name='end' type='xmlNodePtr' info='the end NodePtr value or NULL '/>
    </function>
    <function name='xmlXPtrNewRange' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the starting node '/>
      <arg name='startindex' type='int' info='the start index '/>
      <arg name='end' type='xmlNodePtr' info='the ending point '/>
      <arg name='endindex' type='int' info='the ending index '/>
    </function>
    <function name='xmlXPtrNewRangeNodeObject' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a not to an object</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the starting node '/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending object '/>
    </function>
    <function name='xmlXPtrNewRangeNodePoint' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a node to a point</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the starting node '/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending point '/>
    </function>
    <function name='xmlXPtrNewRangeNodes' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using 2 nodes</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlNodePtr' info='the starting node '/>
      <arg name='end' type='xmlNodePtr' info='the ending node '/>
    </function>
    <function name='xmlXPtrNewRangePointNode' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range from a point to a node</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlXPathObjectPtr' info='the starting point '/>
      <arg name='end' type='xmlNodePtr' info='the ending node '/>
    </function>
    <function name='xmlXPtrNewRangePoints' file='xpointer'>
      <info>Create a new xmlXPathObjectPtr of type range using 2 Points</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='start' type='xmlXPathObjectPtr' info='the starting point '/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending point '/>
    </function>
    <function name='xmlXPtrRangeToFunction' file='xpointer'>
      <info>Implement the range-to() XPointer function</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context '/>
      <arg name='nargs' type='int' info='the number of args '/>
    </function>
    <function name='xmlXPtrWrapLocationSet' file='xpointer'>
      <info>Wrap the LocationSet val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr' info='the newly created object. '/>
      <arg name='val' type='xmlLocationSetPtr' info='the LocationSet value '/>
    </function>
  </symbols>
</api>
